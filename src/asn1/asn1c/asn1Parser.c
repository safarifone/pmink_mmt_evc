/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : /secure/release14_git/mink/src/asn1/asn1c/asn1.g
 *     -                            On : 2012-05-26 21:23:23
 *     -                for the parser : asn1ParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "asn1Parser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pasn1Parser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pasn1Parser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pasn1Parser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pasn1Parser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   asn1ParserTokenNames[129+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "A_ROND",
        (pANTLR3_UINT8) "STAR",
        (pANTLR3_UINT8) "ASSIGN_OP",
        (pANTLR3_UINT8) "BOOLEAN_LITERAL",
        (pANTLR3_UINT8) "TRUE_LITERAL",
        (pANTLR3_UINT8) "FALSE_LITERAL",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "DOUBLE_DOT",
        (pANTLR3_UINT8) "ELLIPSIS",
        (pANTLR3_UINT8) "APOSTROPHE",
        (pANTLR3_UINT8) "AMPERSAND",
        (pANTLR3_UINT8) "LESS_THAN",
        (pANTLR3_UINT8) "GREATER_THAN",
        (pANTLR3_UINT8) "LESS_THAN_SLASH",
        (pANTLR3_UINT8) "SHASH_GREATER_THEN",
        (pANTLR3_UINT8) "TRUE_SMALL_LITERAL",
        (pANTLR3_UINT8) "FALSE_SMALL_LITERAL",
        (pANTLR3_UINT8) "INTEGER_LITERAL",
        (pANTLR3_UINT8) "IA5_STRING_LITERAL",
        (pANTLR3_UINT8) "L_BRACE",
        (pANTLR3_UINT8) "R_BRACE",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "L_PARAN",
        (pANTLR3_UINT8) "R_PARAN",
        (pANTLR3_UINT8) "MINUS",
        (pANTLR3_UINT8) "ENUMERATED_LITERAL",
        (pANTLR3_UINT8) "REAL_LITERAL",
        (pANTLR3_UINT8) "PLUS_INFINITY_LITERAL",
        (pANTLR3_UINT8) "MINUS_INFINITY_LITERAL",
        (pANTLR3_UINT8) "BIT_LITERAL",
        (pANTLR3_UINT8) "STRING_LITERAL",
        (pANTLR3_UINT8) "CONTAINING_LITERAL",
        (pANTLR3_UINT8) "OCTET_LITERAL",
        (pANTLR3_UINT8) "NULL_LITERAL",
        (pANTLR3_UINT8) "SEQUENCE_LITERAL",
        (pANTLR3_UINT8) "OPTIONAL_LITERAL",
        (pANTLR3_UINT8) "DEFAULT_LITERAL",
        (pANTLR3_UINT8) "COMPONENTS_LITERAL",
        (pANTLR3_UINT8) "OF_LITERAL",
        (pANTLR3_UINT8) "SET_LITERAL",
        (pANTLR3_UINT8) "EXCLAM",
        (pANTLR3_UINT8) "ALL_LITERAL",
        (pANTLR3_UINT8) "EXCEPT_LITERAL",
        (pANTLR3_UINT8) "POWER",
        (pANTLR3_UINT8) "PIPE",
        (pANTLR3_UINT8) "UNION_LITERAL",
        (pANTLR3_UINT8) "INTERSECTION_LITERAL",
        (pANTLR3_UINT8) "INCLUDES_LITERAL",
        (pANTLR3_UINT8) "MIN_LITERAL",
        (pANTLR3_UINT8) "MAX_LITERAL",
        (pANTLR3_UINT8) "SIZE_LITERAL",
        (pANTLR3_UINT8) "FROM_LITERAL",
        (pANTLR3_UINT8) "WITH_LITERAL",
        (pANTLR3_UINT8) "COMPONENT_LITERAL",
        (pANTLR3_UINT8) "PRESENT_LITERAL",
        (pANTLR3_UINT8) "ABSENT_LITERAL",
        (pANTLR3_UINT8) "PATTERN_LITERAL",
        (pANTLR3_UINT8) "TYPE_IDENTIFIER_LITERAL",
        (pANTLR3_UINT8) "ABSTRACT_SYNTAX_LITERAL",
        (pANTLR3_UINT8) "CLASS_LITERAL",
        (pANTLR3_UINT8) "UNIQUE_LITERAL",
        (pANTLR3_UINT8) "SYNTAX_LITERAL",
        (pANTLR3_UINT8) "L_BRACKET",
        (pANTLR3_UINT8) "R_BRACKET",
        (pANTLR3_UINT8) "INSTANCE_LITERAL",
        (pANTLR3_UINT8) "SEMI_COLON",
        (pANTLR3_UINT8) "IMPORTS_LITERAL",
        (pANTLR3_UINT8) "EXPORTS_LITERAL",
        (pANTLR3_UINT8) "EXTENSIBILITY_LITERAL",
        (pANTLR3_UINT8) "IMPLIED_LITERAL",
        (pANTLR3_UINT8) "EXPLICIT_LITERAL",
        (pANTLR3_UINT8) "TAGS_LITERAL",
        (pANTLR3_UINT8) "IMPLICIT_LITERAL",
        (pANTLR3_UINT8) "AUTOMATIC_LITERAL",
        (pANTLR3_UINT8) "DEFINITIONS_LITERAL",
        (pANTLR3_UINT8) "BEGIN_LITERAL",
        (pANTLR3_UINT8) "END_LITERAL",
        (pANTLR3_UINT8) "DOUBLE_L_BRACKET",
        (pANTLR3_UINT8) "DOUBLE_R_BRACKET",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "CHOICE_LITERAL",
        (pANTLR3_UINT8) "UNIVERSAL_LITERAL",
        (pANTLR3_UINT8) "APPLICATION_LITERAL",
        (pANTLR3_UINT8) "PRIVATE_LITERAL",
        (pANTLR3_UINT8) "EMBEDDED_LITERAL",
        (pANTLR3_UINT8) "PDV_LITERAL",
        (pANTLR3_UINT8) "OBJECT_LITERAL",
        (pANTLR3_UINT8) "IDENTIFIER_LITERAL",
        (pANTLR3_UINT8) "RELATIVE_OID_LITERAL",
        (pANTLR3_UINT8) "CHARACTER_LITERAL",
        (pANTLR3_UINT8) "CONSTRAINED_LITERAL",
        (pANTLR3_UINT8) "BY_LITERAL",
        (pANTLR3_UINT8) "A_ROND_DOT",
        (pANTLR3_UINT8) "ENCODED_LITERAL",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "MODULE_ROOT",
        (pANTLR3_UINT8) "MODULE_ID",
        (pANTLR3_UINT8) "MODULE_VERSION",
        (pANTLR3_UINT8) "DEFINITIONS_NODE",
        (pANTLR3_UINT8) "IDENTIFIER_NODE",
        (pANTLR3_UINT8) "VALUE_NODE",
        (pANTLR3_UINT8) "TYPE_NODE",
        (pANTLR3_UINT8) "DEFINITION_NODE",
        (pANTLR3_UINT8) "EXPORTS_NODE",
        (pANTLR3_UINT8) "IMPORTS_NODE",
        (pANTLR3_UINT8) "NODE_INFO",
        (pANTLR3_UINT8) "BODY_NODE",
        (pANTLR3_UINT8) "TAG_DESCRIPTOR",
        (pANTLR3_UINT8) "TAG_DEFINITIONS",
        (pANTLR3_UINT8) "NODE_COMPONENT",
        (pANTLR3_UINT8) "TAG_SPECIFIC",
        (pANTLR3_UINT8) "NODE_NAME",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "EXTENSTIONENDMARKER",
        (pANTLR3_UINT8) "BSTRING",
        (pANTLR3_UINT8) "UNRESTRICTEDCHARACTERSTRINGTYPE",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "UPPER",
        (pANTLR3_UINT8) "LOWER",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "Exponent",
        (pANTLR3_UINT8) "LINE_COMMENT",
        (pANTLR3_UINT8) "HEXDIGIT",
        (pANTLR3_UINT8) "HSTRING",
        (pANTLR3_UINT8) "EscapeSequence",
        (pANTLR3_UINT8) "CSTRING",
        (pANTLR3_UINT8) "LETTER",
        (pANTLR3_UINT8) "JavaIDDigit"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static asn1Parser_moduleDefinition_return	moduleDefinition    (pasn1Parser ctx);
static asn1Parser_tagDefault_return	tagDefault    (pasn1Parser ctx);
static asn1Parser_extensionDefault_return	extensionDefault    (pasn1Parser ctx);
static asn1Parser_moduleBody_return	moduleBody    (pasn1Parser ctx);
static asn1Parser_exports_return	exports    (pasn1Parser ctx);
static asn1Parser_symbolsExported_return	symbolsExported    (pasn1Parser ctx);
static asn1Parser_imports_return	imports    (pasn1Parser ctx);
static asn1Parser_symbolsImported_return	symbolsImported    (pasn1Parser ctx);
static asn1Parser_symbolsFromModuleList_return	symbolsFromModuleList    (pasn1Parser ctx);
static asn1Parser_symbolsFromModule_return	symbolsFromModule    (pasn1Parser ctx);
static asn1Parser_globalModuleReference_return	globalModuleReference    (pasn1Parser ctx);
static asn1Parser_assignedIdentifier_return	assignedIdentifier    (pasn1Parser ctx);
static asn1Parser_symbolList_return	symbolList    (pasn1Parser ctx);
static asn1Parser_symbol_return	symbol    (pasn1Parser ctx);
static asn1Parser_assignmentList_return	assignmentList    (pasn1Parser ctx);
static asn1Parser_assignment_return	assignment    (pasn1Parser ctx);
static asn1Parser_sequenceType_return	sequenceType    (pasn1Parser ctx);
static asn1Parser_extensionAndException_return	extensionAndException    (pasn1Parser ctx);
static asn1Parser_optionalExtensionMarker_return	optionalExtensionMarker    (pasn1Parser ctx);
static asn1Parser_componentTypeLists_return	componentTypeLists    (pasn1Parser ctx);
static asn1Parser_rootComponentTypeList_return	rootComponentTypeList    (pasn1Parser ctx);
static asn1Parser_componentTypeList_return	componentTypeList    (pasn1Parser ctx);
static asn1Parser_componentType_return	componentType    (pasn1Parser ctx);
static asn1Parser_extensionAdditions_return	extensionAdditions    (pasn1Parser ctx);
static asn1Parser_extensionAdditionList_return	extensionAdditionList    (pasn1Parser ctx);
static asn1Parser_extensionAddition_return	extensionAddition    (pasn1Parser ctx);
static asn1Parser_extensionAdditionGroup_return	extensionAdditionGroup    (pasn1Parser ctx);
static asn1Parser_versionNumber_return	versionNumber    (pasn1Parser ctx);
static asn1Parser_sequenceOfType_return	sequenceOfType    (pasn1Parser ctx);
static asn1Parser_sizeConstraint_return	sizeConstraint    (pasn1Parser ctx);
static asn1Parser_parameterizedAssignment_return	parameterizedAssignment    (pasn1Parser ctx);
static asn1Parser_parameterList_return	parameterList    (pasn1Parser ctx);
static asn1Parser_parameter_return	parameter    (pasn1Parser ctx);
static asn1Parser_paramGovernor_return	paramGovernor    (pasn1Parser ctx);
static asn1Parser_governor_return	governor    (pasn1Parser ctx);
static asn1Parser_objectClassAssignment_return	objectClassAssignment    (pasn1Parser ctx);
static asn1Parser_objectClass_return	objectClass    (pasn1Parser ctx);
static asn1Parser_definedObjectClass_return	definedObjectClass    (pasn1Parser ctx);
static asn1Parser_usefulObjectClassReference_return	usefulObjectClassReference    (pasn1Parser ctx);
static asn1Parser_externalObjectClassReference_return	externalObjectClassReference    (pasn1Parser ctx);
static asn1Parser_objectClassDefn_return	objectClassDefn    (pasn1Parser ctx);
static asn1Parser_withSyntaxSpec_return	withSyntaxSpec    (pasn1Parser ctx);
static asn1Parser_syntaxList_return	syntaxList    (pasn1Parser ctx);
static asn1Parser_tokenOrGroupSpec_return	tokenOrGroupSpec    (pasn1Parser ctx);
static asn1Parser_optionalGroup_return	optionalGroup    (pasn1Parser ctx);
static asn1Parser_requiredToken_return	requiredToken    (pasn1Parser ctx);
static asn1Parser_literal_return	literal    (pasn1Parser ctx);
static asn1Parser_primitiveFieldName_return	primitiveFieldName    (pasn1Parser ctx);
static asn1Parser_fieldSpec_return	fieldSpec    (pasn1Parser ctx);
static asn1Parser_typeFieldSpec_return	typeFieldSpec    (pasn1Parser ctx);
static asn1Parser_typeOptionalitySpec_return	typeOptionalitySpec    (pasn1Parser ctx);
static asn1Parser_fixedTypeValueFieldSpec_return	fixedTypeValueFieldSpec    (pasn1Parser ctx);
static asn1Parser_valueOptionalitySpec_return	valueOptionalitySpec    (pasn1Parser ctx);
static asn1Parser_variableTypeValueFieldSpec_return	variableTypeValueFieldSpec    (pasn1Parser ctx);
static asn1Parser_fixedTypeValueSetFieldSpec_return	fixedTypeValueSetFieldSpec    (pasn1Parser ctx);
static asn1Parser_valueSetOptionalitySpec_return	valueSetOptionalitySpec    (pasn1Parser ctx);
static asn1Parser_object_return	object    (pasn1Parser ctx);
static asn1Parser_parameterizedObject_return	parameterizedObject    (pasn1Parser ctx);
static asn1Parser_definedObject_return	definedObject    (pasn1Parser ctx);
static asn1Parser_objectSet_return	objectSet    (pasn1Parser ctx);
static asn1Parser_objectSetSpec_return	objectSetSpec    (pasn1Parser ctx);
static asn1Parser_fieldName_return	fieldName    (pasn1Parser ctx);
static asn1Parser_valueSet_return	valueSet    (pasn1Parser ctx);
static asn1Parser_elementSetSpecs_return	elementSetSpecs    (pasn1Parser ctx);
static asn1Parser_rootElementSetSpec_return	rootElementSetSpec    (pasn1Parser ctx);
static asn1Parser_additionalElementSetSpec_return	additionalElementSetSpec    (pasn1Parser ctx);
static asn1Parser_elementSetSpec_return	elementSetSpec    (pasn1Parser ctx);
static asn1Parser_unions_return	unions    (pasn1Parser ctx);
static asn1Parser_exclusions_return	exclusions    (pasn1Parser ctx);
static asn1Parser_intersections_return	intersections    (pasn1Parser ctx);
static asn1Parser_unionMark_return	unionMark    (pasn1Parser ctx);
static asn1Parser_intersectionMark_return	intersectionMark    (pasn1Parser ctx);
static asn1Parser_elements_return	elements    (pasn1Parser ctx);
static asn1Parser_objectSetElements_return	objectSetElements    (pasn1Parser ctx);
static asn1Parser_intersectionElements_return	intersectionElements    (pasn1Parser ctx);
static asn1Parser_subtypeElements_return	subtypeElements    (pasn1Parser ctx);
static asn1Parser_variableTypeValueSetFieldSpec_return	variableTypeValueSetFieldSpec    (pasn1Parser ctx);
static asn1Parser_objectFieldSpec_return	objectFieldSpec    (pasn1Parser ctx);
static asn1Parser_objectOptionalitySpec_return	objectOptionalitySpec    (pasn1Parser ctx);
static asn1Parser_objectSetFieldSpec_return	objectSetFieldSpec    (pasn1Parser ctx);
static asn1Parser_objectSetOptionalitySpec_return	objectSetOptionalitySpec    (pasn1Parser ctx);
static asn1Parser_typeAssignment_return	typeAssignment    (pasn1Parser ctx);
static asn1Parser_valueAssignment_return	valueAssignment    (pasn1Parser ctx);
static asn1Parser_extraTagDescriptors_return	extraTagDescriptors    (pasn1Parser ctx);
static asn1Parser_type_return	type    (pasn1Parser ctx);
static asn1Parser_builtinType_return	builtinType    (pasn1Parser ctx);
static asn1Parser_objectClassFieldType_return	objectClassFieldType    (pasn1Parser ctx);
static asn1Parser_setType_return	setType    (pasn1Parser ctx);
static asn1Parser_setOfType_return	setOfType    (pasn1Parser ctx);
static asn1Parser_referencedType_return	referencedType    (pasn1Parser ctx);
static asn1Parser_definedType_return	definedType    (pasn1Parser ctx);
static asn1Parser_constraint_return	constraint    (pasn1Parser ctx);
static asn1Parser_constraintSpec_return	constraintSpec    (pasn1Parser ctx);
static asn1Parser_userDefinedConstraint_return	userDefinedConstraint    (pasn1Parser ctx);
static asn1Parser_generalConstraint_return	generalConstraint    (pasn1Parser ctx);
static asn1Parser_userDefinedConstraintParameter_return	userDefinedConstraintParameter    (pasn1Parser ctx);
static asn1Parser_tableConstraint_return	tableConstraint    (pasn1Parser ctx);
static asn1Parser_simpleTableConstraint_return	simpleTableConstraint    (pasn1Parser ctx);
static asn1Parser_contentsConstraint_return	contentsConstraint    (pasn1Parser ctx);
static asn1Parser_subtypeConstraint_return	subtypeConstraint    (pasn1Parser ctx);
static asn1Parser_value_return	value    (pasn1Parser ctx);
static asn1Parser_builtinValue_return	builtinValue    (pasn1Parser ctx);
static asn1Parser_objectIdentifierValue_return	objectIdentifierValue    (pasn1Parser ctx);
static asn1Parser_objIdComponentsList_return	objIdComponentsList    (pasn1Parser ctx);
static asn1Parser_objIdComponents_return	objIdComponents    (pasn1Parser ctx);
static asn1Parser_integerValue_return	integerValue    (pasn1Parser ctx);
static asn1Parser_choiceValue_return	choiceValue    (pasn1Parser ctx);
static asn1Parser_enumeratedValue_return	enumeratedValue    (pasn1Parser ctx);
static asn1Parser_signedNumber_return	signedNumber    (pasn1Parser ctx);
static asn1Parser_choiceType_return	choiceType    (pasn1Parser ctx);
static asn1Parser_alternativeTypeLists_return	alternativeTypeLists    (pasn1Parser ctx);
static asn1Parser_extensionAdditionAlternatives_return	extensionAdditionAlternatives    (pasn1Parser ctx);
static asn1Parser_extensionAdditionAlternativesList_return	extensionAdditionAlternativesList    (pasn1Parser ctx);
static asn1Parser_extensionAdditionAlternative_return	extensionAdditionAlternative    (pasn1Parser ctx);
static asn1Parser_extensionAdditionAlternativesGroup_return	extensionAdditionAlternativesGroup    (pasn1Parser ctx);
static asn1Parser_rootAlternativeTypeList_return	rootAlternativeTypeList    (pasn1Parser ctx);
static asn1Parser_alternativeTypeList_return	alternativeTypeList    (pasn1Parser ctx);
static asn1Parser_namedType_return	namedType    (pasn1Parser ctx);
static asn1Parser_enumeratedType_return	enumeratedType    (pasn1Parser ctx);
static asn1Parser_enumerations_return	enumerations    (pasn1Parser ctx);
static asn1Parser_rootEnumeration_return	rootEnumeration    (pasn1Parser ctx);
static asn1Parser_enumeration_return	enumeration    (pasn1Parser ctx);
static asn1Parser_enumerationItem_return	enumerationItem    (pasn1Parser ctx);
static asn1Parser_namedNumber_return	namedNumber    (pasn1Parser ctx);
static asn1Parser_definedValue_return	definedValue    (pasn1Parser ctx);
static asn1Parser_parameterizedValue_return	parameterizedValue    (pasn1Parser ctx);
static asn1Parser_simpleDefinedValue_return	simpleDefinedValue    (pasn1Parser ctx);
static asn1Parser_actualParameterList_return	actualParameterList    (pasn1Parser ctx);
static asn1Parser_actualParameter_return	actualParameter    (pasn1Parser ctx);
static asn1Parser_exceptionSpec_return	exceptionSpec    (pasn1Parser ctx);
static asn1Parser_exceptionIdentification_return	exceptionIdentification    (pasn1Parser ctx);
static asn1Parser_additionalEnumeration_return	additionalEnumeration    (pasn1Parser ctx);
static asn1Parser_integerType_return	integerType    (pasn1Parser ctx);
static asn1Parser_namedNumberList_return	namedNumberList    (pasn1Parser ctx);
static asn1Parser_objectidentifiertype_return	objectidentifiertype    (pasn1Parser ctx);
static asn1Parser_componentRelationConstraint_return	componentRelationConstraint    (pasn1Parser ctx);
static asn1Parser_atNotation_return	atNotation    (pasn1Parser ctx);
static asn1Parser_level_return	level    (pasn1Parser ctx);
static asn1Parser_componentIdList_return	componentIdList    (pasn1Parser ctx);
static asn1Parser_octetStringType_return	octetStringType    (pasn1Parser ctx);
static asn1Parser_ia5stringType_return	ia5stringType    (pasn1Parser ctx);
static asn1Parser_nullType_return	nullType    (pasn1Parser ctx);
static asn1Parser_booleanType_return	booleanType    (pasn1Parser ctx);
static asn1Parser_bitStringType_return	bitStringType    (pasn1Parser ctx);
static asn1Parser_namedBitList_return	namedBitList    (pasn1Parser ctx);
static asn1Parser_namedBit_return	namedBit    (pasn1Parser ctx);
static asn1Parser_booleanValue_return	booleanValue    (pasn1Parser ctx);
static asn1Parser_bitValue_return	bitValue    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred23_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred24_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred25_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred26_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred27_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred28_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred42_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred43_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred44_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred47_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred48_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred49_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred51_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred52_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred55_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred56_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred57_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred62_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred75_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred78_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred80_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred102_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred104_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred105_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred108_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred109_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred114_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred137_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred138_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred139_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred140_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred142_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred143_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred144_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred145_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred146_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred148_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred150_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred155_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred157_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred158_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred160_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred161_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred169_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred180_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred186_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred187_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred189_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred191_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred192_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred201_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred202_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred204_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred205_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred207_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred208_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred209_asn1    (pasn1Parser ctx);
static ANTLR3_BOOLEAN	synpred210_asn1    (pasn1Parser ctx);
static void	asn1ParserFree(pasn1Parser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/secure/release14_git/mink/src/asn1/asn1c/asn1.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new asn1Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pasn1Parser
asn1ParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return asn1ParserNewSSD(instream, NULL);
}

/** \brief Create a new asn1Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pasn1Parser
asn1ParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pasn1Parser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pasn1Parser) ANTLR3_CALLOC(1, sizeof(asn1Parser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in asn1Parser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our asn1Parser interface
     */
    ctx->moduleDefinition	= moduleDefinition;
    ctx->tagDefault	= tagDefault;
    ctx->extensionDefault	= extensionDefault;
    ctx->moduleBody	= moduleBody;
    ctx->exports	= exports;
    ctx->symbolsExported	= symbolsExported;
    ctx->imports	= imports;
    ctx->symbolsImported	= symbolsImported;
    ctx->symbolsFromModuleList	= symbolsFromModuleList;
    ctx->symbolsFromModule	= symbolsFromModule;
    ctx->globalModuleReference	= globalModuleReference;
    ctx->assignedIdentifier	= assignedIdentifier;
    ctx->symbolList	= symbolList;
    ctx->symbol	= symbol;
    ctx->assignmentList	= assignmentList;
    ctx->assignment	= assignment;
    ctx->sequenceType	= sequenceType;
    ctx->extensionAndException	= extensionAndException;
    ctx->optionalExtensionMarker	= optionalExtensionMarker;
    ctx->componentTypeLists	= componentTypeLists;
    ctx->rootComponentTypeList	= rootComponentTypeList;
    ctx->componentTypeList	= componentTypeList;
    ctx->componentType	= componentType;
    ctx->extensionAdditions	= extensionAdditions;
    ctx->extensionAdditionList	= extensionAdditionList;
    ctx->extensionAddition	= extensionAddition;
    ctx->extensionAdditionGroup	= extensionAdditionGroup;
    ctx->versionNumber	= versionNumber;
    ctx->sequenceOfType	= sequenceOfType;
    ctx->sizeConstraint	= sizeConstraint;
    ctx->parameterizedAssignment	= parameterizedAssignment;
    ctx->parameterList	= parameterList;
    ctx->parameter	= parameter;
    ctx->paramGovernor	= paramGovernor;
    ctx->governor	= governor;
    ctx->objectClassAssignment	= objectClassAssignment;
    ctx->objectClass	= objectClass;
    ctx->definedObjectClass	= definedObjectClass;
    ctx->usefulObjectClassReference	= usefulObjectClassReference;
    ctx->externalObjectClassReference	= externalObjectClassReference;
    ctx->objectClassDefn	= objectClassDefn;
    ctx->withSyntaxSpec	= withSyntaxSpec;
    ctx->syntaxList	= syntaxList;
    ctx->tokenOrGroupSpec	= tokenOrGroupSpec;
    ctx->optionalGroup	= optionalGroup;
    ctx->requiredToken	= requiredToken;
    ctx->literal	= literal;
    ctx->primitiveFieldName	= primitiveFieldName;
    ctx->fieldSpec	= fieldSpec;
    ctx->typeFieldSpec	= typeFieldSpec;
    ctx->typeOptionalitySpec	= typeOptionalitySpec;
    ctx->fixedTypeValueFieldSpec	= fixedTypeValueFieldSpec;
    ctx->valueOptionalitySpec	= valueOptionalitySpec;
    ctx->variableTypeValueFieldSpec	= variableTypeValueFieldSpec;
    ctx->fixedTypeValueSetFieldSpec	= fixedTypeValueSetFieldSpec;
    ctx->valueSetOptionalitySpec	= valueSetOptionalitySpec;
    ctx->object	= object;
    ctx->parameterizedObject	= parameterizedObject;
    ctx->definedObject	= definedObject;
    ctx->objectSet	= objectSet;
    ctx->objectSetSpec	= objectSetSpec;
    ctx->fieldName	= fieldName;
    ctx->valueSet	= valueSet;
    ctx->elementSetSpecs	= elementSetSpecs;
    ctx->rootElementSetSpec	= rootElementSetSpec;
    ctx->additionalElementSetSpec	= additionalElementSetSpec;
    ctx->elementSetSpec	= elementSetSpec;
    ctx->unions	= unions;
    ctx->exclusions	= exclusions;
    ctx->intersections	= intersections;
    ctx->unionMark	= unionMark;
    ctx->intersectionMark	= intersectionMark;
    ctx->elements	= elements;
    ctx->objectSetElements	= objectSetElements;
    ctx->intersectionElements	= intersectionElements;
    ctx->subtypeElements	= subtypeElements;
    ctx->variableTypeValueSetFieldSpec	= variableTypeValueSetFieldSpec;
    ctx->objectFieldSpec	= objectFieldSpec;
    ctx->objectOptionalitySpec	= objectOptionalitySpec;
    ctx->objectSetFieldSpec	= objectSetFieldSpec;
    ctx->objectSetOptionalitySpec	= objectSetOptionalitySpec;
    ctx->typeAssignment	= typeAssignment;
    ctx->valueAssignment	= valueAssignment;
    ctx->extraTagDescriptors	= extraTagDescriptors;
    ctx->type	= type;
    ctx->builtinType	= builtinType;
    ctx->objectClassFieldType	= objectClassFieldType;
    ctx->setType	= setType;
    ctx->setOfType	= setOfType;
    ctx->referencedType	= referencedType;
    ctx->definedType	= definedType;
    ctx->constraint	= constraint;
    ctx->constraintSpec	= constraintSpec;
    ctx->userDefinedConstraint	= userDefinedConstraint;
    ctx->generalConstraint	= generalConstraint;
    ctx->userDefinedConstraintParameter	= userDefinedConstraintParameter;
    ctx->tableConstraint	= tableConstraint;
    ctx->simpleTableConstraint	= simpleTableConstraint;
    ctx->contentsConstraint	= contentsConstraint;
    ctx->subtypeConstraint	= subtypeConstraint;
    ctx->value	= value;
    ctx->builtinValue	= builtinValue;
    ctx->objectIdentifierValue	= objectIdentifierValue;
    ctx->objIdComponentsList	= objIdComponentsList;
    ctx->objIdComponents	= objIdComponents;
    ctx->integerValue	= integerValue;
    ctx->choiceValue	= choiceValue;
    ctx->enumeratedValue	= enumeratedValue;
    ctx->signedNumber	= signedNumber;
    ctx->choiceType	= choiceType;
    ctx->alternativeTypeLists	= alternativeTypeLists;
    ctx->extensionAdditionAlternatives	= extensionAdditionAlternatives;
    ctx->extensionAdditionAlternativesList	= extensionAdditionAlternativesList;
    ctx->extensionAdditionAlternative	= extensionAdditionAlternative;
    ctx->extensionAdditionAlternativesGroup	= extensionAdditionAlternativesGroup;
    ctx->rootAlternativeTypeList	= rootAlternativeTypeList;
    ctx->alternativeTypeList	= alternativeTypeList;
    ctx->namedType	= namedType;
    ctx->enumeratedType	= enumeratedType;
    ctx->enumerations	= enumerations;
    ctx->rootEnumeration	= rootEnumeration;
    ctx->enumeration	= enumeration;
    ctx->enumerationItem	= enumerationItem;
    ctx->namedNumber	= namedNumber;
    ctx->definedValue	= definedValue;
    ctx->parameterizedValue	= parameterizedValue;
    ctx->simpleDefinedValue	= simpleDefinedValue;
    ctx->actualParameterList	= actualParameterList;
    ctx->actualParameter	= actualParameter;
    ctx->exceptionSpec	= exceptionSpec;
    ctx->exceptionIdentification	= exceptionIdentification;
    ctx->additionalEnumeration	= additionalEnumeration;
    ctx->integerType	= integerType;
    ctx->namedNumberList	= namedNumberList;
    ctx->objectidentifiertype	= objectidentifiertype;
    ctx->componentRelationConstraint	= componentRelationConstraint;
    ctx->atNotation	= atNotation;
    ctx->level	= level;
    ctx->componentIdList	= componentIdList;
    ctx->octetStringType	= octetStringType;
    ctx->ia5stringType	= ia5stringType;
    ctx->nullType	= nullType;
    ctx->booleanType	= booleanType;
    ctx->bitStringType	= bitStringType;
    ctx->namedBitList	= namedBitList;
    ctx->namedBit	= namedBit;
    ctx->booleanValue	= booleanValue;
    ctx->bitValue	= bitValue;
    ctx->synpred23_asn1	= synpred23_asn1;
    ctx->synpred24_asn1	= synpred24_asn1;
    ctx->synpred25_asn1	= synpred25_asn1;
    ctx->synpred26_asn1	= synpred26_asn1;
    ctx->synpred27_asn1	= synpred27_asn1;
    ctx->synpred28_asn1	= synpred28_asn1;
    ctx->synpred42_asn1	= synpred42_asn1;
    ctx->synpred43_asn1	= synpred43_asn1;
    ctx->synpred44_asn1	= synpred44_asn1;
    ctx->synpred47_asn1	= synpred47_asn1;
    ctx->synpred48_asn1	= synpred48_asn1;
    ctx->synpred49_asn1	= synpred49_asn1;
    ctx->synpred51_asn1	= synpred51_asn1;
    ctx->synpred52_asn1	= synpred52_asn1;
    ctx->synpred55_asn1	= synpred55_asn1;
    ctx->synpred56_asn1	= synpred56_asn1;
    ctx->synpred57_asn1	= synpred57_asn1;
    ctx->synpred62_asn1	= synpred62_asn1;
    ctx->synpred75_asn1	= synpred75_asn1;
    ctx->synpred78_asn1	= synpred78_asn1;
    ctx->synpred80_asn1	= synpred80_asn1;
    ctx->synpred102_asn1	= synpred102_asn1;
    ctx->synpred104_asn1	= synpred104_asn1;
    ctx->synpred105_asn1	= synpred105_asn1;
    ctx->synpred108_asn1	= synpred108_asn1;
    ctx->synpred109_asn1	= synpred109_asn1;
    ctx->synpred114_asn1	= synpred114_asn1;
    ctx->synpred137_asn1	= synpred137_asn1;
    ctx->synpred138_asn1	= synpred138_asn1;
    ctx->synpred139_asn1	= synpred139_asn1;
    ctx->synpred140_asn1	= synpred140_asn1;
    ctx->synpred142_asn1	= synpred142_asn1;
    ctx->synpred143_asn1	= synpred143_asn1;
    ctx->synpred144_asn1	= synpred144_asn1;
    ctx->synpred145_asn1	= synpred145_asn1;
    ctx->synpred146_asn1	= synpred146_asn1;
    ctx->synpred148_asn1	= synpred148_asn1;
    ctx->synpred150_asn1	= synpred150_asn1;
    ctx->synpred155_asn1	= synpred155_asn1;
    ctx->synpred157_asn1	= synpred157_asn1;
    ctx->synpred158_asn1	= synpred158_asn1;
    ctx->synpred160_asn1	= synpred160_asn1;
    ctx->synpred161_asn1	= synpred161_asn1;
    ctx->synpred169_asn1	= synpred169_asn1;
    ctx->synpred180_asn1	= synpred180_asn1;
    ctx->synpred186_asn1	= synpred186_asn1;
    ctx->synpred187_asn1	= synpred187_asn1;
    ctx->synpred189_asn1	= synpred189_asn1;
    ctx->synpred191_asn1	= synpred191_asn1;
    ctx->synpred192_asn1	= synpred192_asn1;
    ctx->synpred201_asn1	= synpred201_asn1;
    ctx->synpred202_asn1	= synpred202_asn1;
    ctx->synpred204_asn1	= synpred204_asn1;
    ctx->synpred205_asn1	= synpred205_asn1;
    ctx->synpred207_asn1	= synpred207_asn1;
    ctx->synpred208_asn1	= synpred208_asn1;
    ctx->synpred209_asn1	= synpred209_asn1;
    ctx->synpred210_asn1	= synpred210_asn1;
    ctx->free			= asn1ParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */
    ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);
    ctx->vectors	= antlr3VectorFactoryNew(0);
    

    /* Create a LIST for recording rule memos.
     */
     RULEMEMO    = antlr3IntTrieNew(15);	/* 16 bit depth is enough for 32768 rules! */
	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = asn1ParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 asn1ParserFree(pasn1Parser ctx)
 {
    /* Free any scope memory
     */
    
    ctx->vectors->close(ctx->vectors);
    /* We created the adaptor so we must free it
     */
    ADAPTOR->free(ADAPTOR);
	if	(RULEMEMO != NULL)
	{
		RULEMEMO->free(RULEMEMO);
		RULEMEMO = NULL;
	}	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return asn1ParserTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_moduleDefinition3218  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_moduleDefinition3218_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_moduleDefinition3218	= { FOLLOW_IDENTIFIER_in_moduleDefinition3218_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_moduleDefinition3221  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_moduleDefinition3221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_moduleDefinition3221	= { FOLLOW_L_BRACE_in_moduleDefinition3221_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_moduleDefinition3227  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_moduleDefinition3227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000005000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_moduleDefinition3227	= { FOLLOW_IDENTIFIER_in_moduleDefinition3227_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_moduleDefinition3233  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_moduleDefinition3233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000005000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_moduleDefinition3233	= { FOLLOW_NUMBER_in_moduleDefinition3233_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_moduleDefinition3237  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_moduleDefinition3237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_moduleDefinition3237	= { FOLLOW_L_PARAN_in_moduleDefinition3237_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_moduleDefinition3241  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_moduleDefinition3241_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_moduleDefinition3241	= { FOLLOW_NUMBER_in_moduleDefinition3241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_moduleDefinition3243  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_moduleDefinition3243_bits[]	= { ANTLR3_UINT64_LIT(0x0000000005000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_moduleDefinition3243	= { FOLLOW_R_PARAN_in_moduleDefinition3243_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_moduleDefinition3249  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_moduleDefinition3249_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_moduleDefinition3249	= { FOLLOW_R_BRACE_in_moduleDefinition3249_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFINITIONS_LITERAL_in_moduleDefinition3258  */
static	ANTLR3_BITWORD FOLLOW_DEFINITIONS_LITERAL_in_moduleDefinition3258_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040), ANTLR3_UINT64_LIT(0x0000000000003500) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFINITIONS_LITERAL_in_moduleDefinition3258	= { FOLLOW_DEFINITIONS_LITERAL_in_moduleDefinition3258_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagDefault_in_moduleDefinition3267  */
static	ANTLR3_BITWORD FOLLOW_tagDefault_in_moduleDefinition3267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_tagDefault_in_moduleDefinition3267	= { FOLLOW_tagDefault_in_moduleDefinition3267_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionDefault_in_moduleDefinition3274  */
static	ANTLR3_BITWORD FOLLOW_extensionDefault_in_moduleDefinition3274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionDefault_in_moduleDefinition3274	= { FOLLOW_extensionDefault_in_moduleDefinition3274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_OP_in_moduleDefinition3282  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_OP_in_moduleDefinition3282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_OP_in_moduleDefinition3282	= { FOLLOW_ASSIGN_OP_in_moduleDefinition3282_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BEGIN_LITERAL_in_moduleDefinition3290  */
static	ANTLR3_BITWORD FOLLOW_BEGIN_LITERAL_in_moduleDefinition3290_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x00100000000100C0) };
static  ANTLR3_BITSET_LIST FOLLOW_BEGIN_LITERAL_in_moduleDefinition3290	= { FOLLOW_BEGIN_LITERAL_in_moduleDefinition3290_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_moduleBody_in_moduleDefinition3297  */
static	ANTLR3_BITWORD FOLLOW_moduleBody_in_moduleDefinition3297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_moduleBody_in_moduleDefinition3297	= { FOLLOW_moduleBody_in_moduleDefinition3297_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_END_LITERAL_in_moduleDefinition3305  */
static	ANTLR3_BITWORD FOLLOW_END_LITERAL_in_moduleDefinition3305_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_END_LITERAL_in_moduleDefinition3305	= { FOLLOW_END_LITERAL_in_moduleDefinition3305_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_tagDefault3381  */
static	ANTLR3_BITWORD FOLLOW_set_in_tagDefault3381_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_tagDefault3381	= { FOLLOW_set_in_tagDefault3381_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TAGS_LITERAL_in_tagDefault3389  */
static	ANTLR3_BITWORD FOLLOW_TAGS_LITERAL_in_tagDefault3389_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TAGS_LITERAL_in_tagDefault3389	= { FOLLOW_TAGS_LITERAL_in_tagDefault3389_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTENSIBILITY_LITERAL_in_extensionDefault3408  */
static	ANTLR3_BITWORD FOLLOW_EXTENSIBILITY_LITERAL_in_extensionDefault3408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTENSIBILITY_LITERAL_in_extensionDefault3408	= { FOLLOW_EXTENSIBILITY_LITERAL_in_extensionDefault3408_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPLIED_LITERAL_in_extensionDefault3410  */
static	ANTLR3_BITWORD FOLLOW_IMPLIED_LITERAL_in_extensionDefault3410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPLIED_LITERAL_in_extensionDefault3410	= { FOLLOW_IMPLIED_LITERAL_in_extensionDefault3410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exports_in_moduleBody3425  */
static	ANTLR3_BITWORD FOLLOW_exports_in_moduleBody3425_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x00100000000000C0) };
static  ANTLR3_BITSET_LIST FOLLOW_exports_in_moduleBody3425	= { FOLLOW_exports_in_moduleBody3425_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_imports_in_moduleBody3429  */
static	ANTLR3_BITWORD FOLLOW_imports_in_moduleBody3429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x00100000000000C0) };
static  ANTLR3_BITSET_LIST FOLLOW_imports_in_moduleBody3429	= { FOLLOW_imports_in_moduleBody3429_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignmentList_in_moduleBody3433  */
static	ANTLR3_BITWORD FOLLOW_assignmentList_in_moduleBody3433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignmentList_in_moduleBody3433	= { FOLLOW_assignmentList_in_moduleBody3433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXPORTS_LITERAL_in_exports3474  */
static	ANTLR3_BITWORD FOLLOW_EXPORTS_LITERAL_in_exports3474_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_EXPORTS_LITERAL_in_exports3474	= { FOLLOW_EXPORTS_LITERAL_in_exports3474_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolsExported_in_exports3478  */
static	ANTLR3_BITWORD FOLLOW_symbolsExported_in_exports3478_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolsExported_in_exports3478	= { FOLLOW_symbolsExported_in_exports3478_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_COLON_in_exports3480  */
static	ANTLR3_BITWORD FOLLOW_SEMI_COLON_in_exports3480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_COLON_in_exports3480	= { FOLLOW_SEMI_COLON_in_exports3480_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXPORTS_LITERAL_in_exports3494  */
static	ANTLR3_BITWORD FOLLOW_EXPORTS_LITERAL_in_exports3494_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EXPORTS_LITERAL_in_exports3494	= { FOLLOW_EXPORTS_LITERAL_in_exports3494_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ALL_LITERAL_in_exports3496  */
static	ANTLR3_BITWORD FOLLOW_ALL_LITERAL_in_exports3496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_ALL_LITERAL_in_exports3496	= { FOLLOW_ALL_LITERAL_in_exports3496_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_COLON_in_exports3498  */
static	ANTLR3_BITWORD FOLLOW_SEMI_COLON_in_exports3498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_COLON_in_exports3498	= { FOLLOW_SEMI_COLON_in_exports3498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolList_in_symbolsExported3514  */
static	ANTLR3_BITWORD FOLLOW_symbolList_in_symbolsExported3514_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolList_in_symbolsExported3514	= { FOLLOW_symbolList_in_symbolsExported3514_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPORTS_LITERAL_in_imports3535  */
static	ANTLR3_BITWORD FOLLOW_IMPORTS_LITERAL_in_imports3535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPORTS_LITERAL_in_imports3535	= { FOLLOW_IMPORTS_LITERAL_in_imports3535_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolsImported_in_imports3537  */
static	ANTLR3_BITWORD FOLLOW_symbolsImported_in_imports3537_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolsImported_in_imports3537	= { FOLLOW_symbolsImported_in_imports3537_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_COLON_in_imports3539  */
static	ANTLR3_BITWORD FOLLOW_SEMI_COLON_in_imports3539_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_COLON_in_imports3539	= { FOLLOW_SEMI_COLON_in_imports3539_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolsFromModuleList_in_symbolsImported3562  */
static	ANTLR3_BITWORD FOLLOW_symbolsFromModuleList_in_symbolsImported3562_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolsFromModuleList_in_symbolsImported3562	= { FOLLOW_symbolsFromModuleList_in_symbolsImported3562_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolsFromModule_in_symbolsFromModuleList3583  */
static	ANTLR3_BITWORD FOLLOW_symbolsFromModule_in_symbolsFromModuleList3583_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolsFromModule_in_symbolsFromModuleList3583	= { FOLLOW_symbolsFromModule_in_symbolsFromModuleList3583_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolsFromModule_in_symbolsFromModuleList3587  */
static	ANTLR3_BITWORD FOLLOW_symbolsFromModule_in_symbolsFromModuleList3587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolsFromModule_in_symbolsFromModuleList3587	= { FOLLOW_symbolsFromModule_in_symbolsFromModuleList3587_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolList_in_symbolsFromModule3599  */
static	ANTLR3_BITWORD FOLLOW_symbolList_in_symbolsFromModule3599_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolList_in_symbolsFromModule3599	= { FOLLOW_symbolList_in_symbolsFromModule3599_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FROM_LITERAL_in_symbolsFromModule3601  */
static	ANTLR3_BITWORD FOLLOW_FROM_LITERAL_in_symbolsFromModule3601_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_FROM_LITERAL_in_symbolsFromModule3601	= { FOLLOW_FROM_LITERAL_in_symbolsFromModule3601_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_globalModuleReference_in_symbolsFromModule3603  */
static	ANTLR3_BITWORD FOLLOW_globalModuleReference_in_symbolsFromModule3603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_globalModuleReference_in_symbolsFromModule3603	= { FOLLOW_globalModuleReference_in_symbolsFromModule3603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_globalModuleReference3622  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_globalModuleReference3622_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_globalModuleReference3622	= { FOLLOW_IDENTIFIER_in_globalModuleReference3622_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignedIdentifier_in_globalModuleReference3624  */
static	ANTLR3_BITWORD FOLLOW_assignedIdentifier_in_globalModuleReference3624_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignedIdentifier_in_globalModuleReference3624	= { FOLLOW_assignedIdentifier_in_globalModuleReference3624_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_globalModuleReference3627  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_globalModuleReference3627_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_globalModuleReference3627	= { FOLLOW_L_BRACE_in_globalModuleReference3627_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_globalModuleReference3631  */
static	ANTLR3_BITWORD FOLLOW_set_in_globalModuleReference3631_bits[]	= { ANTLR3_UINT64_LIT(0x0000000005000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_globalModuleReference3631	= { FOLLOW_set_in_globalModuleReference3631_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_globalModuleReference3640  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_globalModuleReference3640_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_globalModuleReference3640	= { FOLLOW_L_PARAN_in_globalModuleReference3640_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_globalModuleReference3643  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_globalModuleReference3643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_globalModuleReference3643	= { FOLLOW_NUMBER_in_globalModuleReference3643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_globalModuleReference3645  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_globalModuleReference3645_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_globalModuleReference3645	= { FOLLOW_R_PARAN_in_globalModuleReference3645_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_globalModuleReference3652  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_globalModuleReference3652_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_globalModuleReference3652	= { FOLLOW_R_BRACE_in_globalModuleReference3652_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_symbolList3677  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_symbolList3677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_symbolList3677	= { FOLLOW_symbol_in_symbolList3677_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_symbolList3681  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_symbolList3681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_symbolList3681	= { FOLLOW_COMMA_in_symbolList3681_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbol_in_symbolList3685  */
static	ANTLR3_BITWORD FOLLOW_symbol_in_symbolList3685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_symbol_in_symbolList3685	= { FOLLOW_symbol_in_symbolList3685_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_symbol3708  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_symbol3708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_symbol3708	= { FOLLOW_IDENTIFIER_in_symbol3708_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_symbol3712  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_symbol3712_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_symbol3712	= { FOLLOW_L_BRACE_in_symbol3712_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_symbol3715  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_symbol3715_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_symbol3715	= { FOLLOW_R_BRACE_in_symbol3715_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_assignmentList3738  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_assignmentList3738_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x00100000000000C0) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_assignmentList3738	= { FOLLOW_assignment_in_assignmentList3738_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignment_in_assignmentList3744  */
static	ANTLR3_BITWORD FOLLOW_assignment_in_assignmentList3744_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x00100000000000C0) };
static  ANTLR3_BITSET_LIST FOLLOW_assignment_in_assignmentList3744	= { FOLLOW_assignment_in_assignmentList3744_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_assignment3774  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_assignment3774_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220E000C0), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_assignment3774	= { FOLLOW_IDENTIFIER_in_assignment3774_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueAssignment_in_assignment3783  */
static	ANTLR3_BITWORD FOLLOW_valueAssignment_in_assignment3783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueAssignment_in_assignment3783	= { FOLLOW_valueAssignment_in_assignment3783_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeAssignment_in_assignment3792  */
static	ANTLR3_BITWORD FOLLOW_typeAssignment_in_assignment3792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeAssignment_in_assignment3792	= { FOLLOW_typeAssignment_in_assignment3792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameterizedAssignment_in_assignment3800  */
static	ANTLR3_BITWORD FOLLOW_parameterizedAssignment_in_assignment3800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_parameterizedAssignment_in_assignment3800	= { FOLLOW_parameterizedAssignment_in_assignment3800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectClassAssignment_in_assignment3809  */
static	ANTLR3_BITWORD FOLLOW_objectClassAssignment_in_assignment3809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectClassAssignment_in_assignment3809	= { FOLLOW_objectClassAssignment_in_assignment3809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEQUENCE_LITERAL_in_sequenceType3851  */
static	ANTLR3_BITWORD FOLLOW_SEQUENCE_LITERAL_in_sequenceType3851_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_SEQUENCE_LITERAL_in_sequenceType3851	= { FOLLOW_SEQUENCE_LITERAL_in_sequenceType3851_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_sequenceType3853  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_sequenceType3853_bits[]	= { ANTLR3_UINT64_LIT(0x0000020001001000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_sequenceType3853	= { FOLLOW_L_BRACE_in_sequenceType3853_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAndException_in_sequenceType3856  */
static	ANTLR3_BITWORD FOLLOW_extensionAndException_in_sequenceType3856_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAndException_in_sequenceType3856	= { FOLLOW_extensionAndException_in_sequenceType3856_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_optionalExtensionMarker_in_sequenceType3859  */
static	ANTLR3_BITWORD FOLLOW_optionalExtensionMarker_in_sequenceType3859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_optionalExtensionMarker_in_sequenceType3859	= { FOLLOW_optionalExtensionMarker_in_sequenceType3859_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentTypeLists_in_sequenceType3863  */
static	ANTLR3_BITWORD FOLLOW_componentTypeLists_in_sequenceType3863_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_componentTypeLists_in_sequenceType3863	= { FOLLOW_componentTypeLists_in_sequenceType3863_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_sequenceType3868  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_sequenceType3868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_sequenceType3868	= { FOLLOW_R_BRACE_in_sequenceType3868_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ELLIPSIS_in_extensionAndException3893  */
static	ANTLR3_BITWORD FOLLOW_ELLIPSIS_in_extensionAndException3893_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ELLIPSIS_in_extensionAndException3893	= { FOLLOW_ELLIPSIS_in_extensionAndException3893_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exceptionSpec_in_extensionAndException3897  */
static	ANTLR3_BITWORD FOLLOW_exceptionSpec_in_extensionAndException3897_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exceptionSpec_in_extensionAndException3897	= { FOLLOW_exceptionSpec_in_extensionAndException3897_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_optionalExtensionMarker3909  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_optionalExtensionMarker3909_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_optionalExtensionMarker3909	= { FOLLOW_COMMA_in_optionalExtensionMarker3909_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ELLIPSIS_in_optionalExtensionMarker3912  */
static	ANTLR3_BITWORD FOLLOW_ELLIPSIS_in_optionalExtensionMarker3912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ELLIPSIS_in_optionalExtensionMarker3912	= { FOLLOW_ELLIPSIS_in_optionalExtensionMarker3912_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rootComponentTypeList_in_componentTypeLists3931  */
static	ANTLR3_BITWORD FOLLOW_rootComponentTypeList_in_componentTypeLists3931_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rootComponentTypeList_in_componentTypeLists3931	= { FOLLOW_rootComponentTypeList_in_componentTypeLists3931_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_componentTypeLists3934  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_componentTypeLists3934_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_componentTypeLists3934	= { FOLLOW_COMMA_in_componentTypeLists3934_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAndException_in_componentTypeLists3938  */
static	ANTLR3_BITWORD FOLLOW_extensionAndException_in_componentTypeLists3938_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000), ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAndException_in_componentTypeLists3938	= { FOLLOW_extensionAndException_in_componentTypeLists3938_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAdditions_in_componentTypeLists3941  */
static	ANTLR3_BITWORD FOLLOW_extensionAdditions_in_componentTypeLists3941_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000), ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAdditions_in_componentTypeLists3941	= { FOLLOW_extensionAdditions_in_componentTypeLists3941_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_optionalExtensionMarker_in_componentTypeLists3946  */
static	ANTLR3_BITWORD FOLLOW_optionalExtensionMarker_in_componentTypeLists3946_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_optionalExtensionMarker_in_componentTypeLists3946	= { FOLLOW_optionalExtensionMarker_in_componentTypeLists3946_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTENSTIONENDMARKER_in_componentTypeLists3949  */
static	ANTLR3_BITWORD FOLLOW_EXTENSTIONENDMARKER_in_componentTypeLists3949_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTENSTIONENDMARKER_in_componentTypeLists3949	= { FOLLOW_EXTENSTIONENDMARKER_in_componentTypeLists3949_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_componentTypeLists3952  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_componentTypeLists3952_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_componentTypeLists3952	= { FOLLOW_COMMA_in_componentTypeLists3952_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rootComponentTypeList_in_componentTypeLists3955  */
static	ANTLR3_BITWORD FOLLOW_rootComponentTypeList_in_componentTypeLists3955_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rootComponentTypeList_in_componentTypeLists3955	= { FOLLOW_rootComponentTypeList_in_componentTypeLists3955_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAndException_in_componentTypeLists3966  */
static	ANTLR3_BITWORD FOLLOW_extensionAndException_in_componentTypeLists3966_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000), ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAndException_in_componentTypeLists3966	= { FOLLOW_extensionAndException_in_componentTypeLists3966_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAdditions_in_componentTypeLists3969  */
static	ANTLR3_BITWORD FOLLOW_extensionAdditions_in_componentTypeLists3969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000), ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAdditions_in_componentTypeLists3969	= { FOLLOW_extensionAdditions_in_componentTypeLists3969_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_optionalExtensionMarker_in_componentTypeLists3973  */
static	ANTLR3_BITWORD FOLLOW_optionalExtensionMarker_in_componentTypeLists3973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_optionalExtensionMarker_in_componentTypeLists3973	= { FOLLOW_optionalExtensionMarker_in_componentTypeLists3973_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTENSTIONENDMARKER_in_componentTypeLists3978  */
static	ANTLR3_BITWORD FOLLOW_EXTENSTIONENDMARKER_in_componentTypeLists3978_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTENSTIONENDMARKER_in_componentTypeLists3978	= { FOLLOW_EXTENSTIONENDMARKER_in_componentTypeLists3978_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_componentTypeLists3981  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_componentTypeLists3981_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_componentTypeLists3981	= { FOLLOW_COMMA_in_componentTypeLists3981_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rootComponentTypeList_in_componentTypeLists3986  */
static	ANTLR3_BITWORD FOLLOW_rootComponentTypeList_in_componentTypeLists3986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rootComponentTypeList_in_componentTypeLists3986	= { FOLLOW_rootComponentTypeList_in_componentTypeLists3986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentTypeList_in_rootComponentTypeList3997  */
static	ANTLR3_BITWORD FOLLOW_componentTypeList_in_rootComponentTypeList3997_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_componentTypeList_in_rootComponentTypeList3997	= { FOLLOW_componentTypeList_in_rootComponentTypeList3997_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentType_in_componentTypeList4007  */
static	ANTLR3_BITWORD FOLLOW_componentType_in_componentTypeList4007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_componentType_in_componentTypeList4007	= { FOLLOW_componentType_in_componentTypeList4007_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_componentTypeList4011  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_componentTypeList4011_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_componentTypeList4011	= { FOLLOW_COMMA_in_componentTypeList4011_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentType_in_componentTypeList4014  */
static	ANTLR3_BITWORD FOLLOW_componentType_in_componentTypeList4014_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_componentType_in_componentTypeList4014	= { FOLLOW_componentType_in_componentTypeList4014_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedType_in_componentType4029  */
static	ANTLR3_BITWORD FOLLOW_namedType_in_componentType4029_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedType_in_componentType4029	= { FOLLOW_namedType_in_componentType4029_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTIONAL_LITERAL_in_componentType4034  */
static	ANTLR3_BITWORD FOLLOW_OPTIONAL_LITERAL_in_componentType4034_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTIONAL_LITERAL_in_componentType4034	= { FOLLOW_OPTIONAL_LITERAL_in_componentType4034_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_LITERAL_in_componentType4040  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_LITERAL_in_componentType4040_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_LITERAL_in_componentType4040	= { FOLLOW_DEFAULT_LITERAL_in_componentType4040_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedType_in_componentType4044  */
static	ANTLR3_BITWORD FOLLOW_namedType_in_componentType4044_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedType_in_componentType4044	= { FOLLOW_namedType_in_componentType4044_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMPONENTS_LITERAL_in_componentType4077  */
static	ANTLR3_BITWORD FOLLOW_COMPONENTS_LITERAL_in_componentType4077_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMPONENTS_LITERAL_in_componentType4077	= { FOLLOW_COMPONENTS_LITERAL_in_componentType4077_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OF_LITERAL_in_componentType4079  */
static	ANTLR3_BITWORD FOLLOW_OF_LITERAL_in_componentType4079_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_OF_LITERAL_in_componentType4079	= { FOLLOW_OF_LITERAL_in_componentType4079_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_componentType4082  */
static	ANTLR3_BITWORD FOLLOW_type_in_componentType4082_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_componentType4082	= { FOLLOW_type_in_componentType4082_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_extensionAdditions4094  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_extensionAdditions4094_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0010000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_extensionAdditions4094	= { FOLLOW_COMMA_in_extensionAdditions4094_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAdditionList_in_extensionAdditions4098  */
static	ANTLR3_BITWORD FOLLOW_extensionAdditionList_in_extensionAdditions4098_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAdditionList_in_extensionAdditions4098	= { FOLLOW_extensionAdditionList_in_extensionAdditions4098_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAddition_in_extensionAdditionList4112  */
static	ANTLR3_BITWORD FOLLOW_extensionAddition_in_extensionAdditionList4112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAddition_in_extensionAdditionList4112	= { FOLLOW_extensionAddition_in_extensionAdditionList4112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_extensionAdditionList4116  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_extensionAdditionList4116_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0010000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_extensionAdditionList4116	= { FOLLOW_COMMA_in_extensionAdditionList4116_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAddition_in_extensionAdditionList4120  */
static	ANTLR3_BITWORD FOLLOW_extensionAddition_in_extensionAdditionList4120_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAddition_in_extensionAdditionList4120	= { FOLLOW_extensionAddition_in_extensionAdditionList4120_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentType_in_extensionAddition4133  */
static	ANTLR3_BITWORD FOLLOW_componentType_in_extensionAddition4133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_componentType_in_extensionAddition4133	= { FOLLOW_componentType_in_extensionAddition4133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAdditionGroup_in_extensionAddition4139  */
static	ANTLR3_BITWORD FOLLOW_extensionAdditionGroup_in_extensionAddition4139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAdditionGroup_in_extensionAddition4139	= { FOLLOW_extensionAdditionGroup_in_extensionAddition4139_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOUBLE_L_BRACKET_in_extensionAdditionGroup4151  */
static	ANTLR3_BITWORD FOLLOW_DOUBLE_L_BRACKET_in_extensionAdditionGroup4151_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOUBLE_L_BRACKET_in_extensionAdditionGroup4151	= { FOLLOW_DOUBLE_L_BRACKET_in_extensionAdditionGroup4151_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_versionNumber_in_extensionAdditionGroup4154  */
static	ANTLR3_BITWORD FOLLOW_versionNumber_in_extensionAdditionGroup4154_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_versionNumber_in_extensionAdditionGroup4154	= { FOLLOW_versionNumber_in_extensionAdditionGroup4154_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentTypeList_in_extensionAdditionGroup4157  */
static	ANTLR3_BITWORD FOLLOW_componentTypeList_in_extensionAdditionGroup4157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_componentTypeList_in_extensionAdditionGroup4157	= { FOLLOW_componentTypeList_in_extensionAdditionGroup4157_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOUBLE_R_BRACKET_in_extensionAdditionGroup4160  */
static	ANTLR3_BITWORD FOLLOW_DOUBLE_R_BRACKET_in_extensionAdditionGroup4160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOUBLE_R_BRACKET_in_extensionAdditionGroup4160	= { FOLLOW_DOUBLE_R_BRACKET_in_extensionAdditionGroup4160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_versionNumber4173  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_versionNumber4173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_versionNumber4173	= { FOLLOW_NUMBER_in_versionNumber4173_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_versionNumber4176  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_versionNumber4176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_versionNumber4176	= { FOLLOW_COLON_in_versionNumber4176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEQUENCE_LITERAL_in_sequenceOfType4189  */
static	ANTLR3_BITWORD FOLLOW_SEQUENCE_LITERAL_in_sequenceOfType4189_bits[]	= { ANTLR3_UINT64_LIT(0x1050240814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SEQUENCE_LITERAL_in_sequenceOfType4189	= { FOLLOW_SEQUENCE_LITERAL_in_sequenceOfType4189_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIZE_LITERAL_in_sequenceOfType4193  */
static	ANTLR3_BITWORD FOLLOW_SIZE_LITERAL_in_sequenceOfType4193_bits[]	= { ANTLR3_UINT64_LIT(0x1050240814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SIZE_LITERAL_in_sequenceOfType4193	= { FOLLOW_SIZE_LITERAL_in_sequenceOfType4193_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_sequenceOfType4197  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_sequenceOfType4197_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_sequenceOfType4197	= { FOLLOW_L_PARAN_in_sequenceOfType4197_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_sequenceOfType4203  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_sequenceOfType4203_bits[]	= { ANTLR3_UINT64_LIT(0x0000040008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_sequenceOfType4203	= { FOLLOW_constraint_in_sequenceOfType4203_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sizeConstraint_in_sequenceOfType4209  */
static	ANTLR3_BITWORD FOLLOW_sizeConstraint_in_sequenceOfType4209_bits[]	= { ANTLR3_UINT64_LIT(0x0000040008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sizeConstraint_in_sequenceOfType4209	= { FOLLOW_sizeConstraint_in_sequenceOfType4209_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_sequenceOfType4212  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_sequenceOfType4212_bits[]	= { ANTLR3_UINT64_LIT(0x0000040008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_sequenceOfType4212	= { FOLLOW_R_PARAN_in_sequenceOfType4212_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OF_LITERAL_in_sequenceOfType4217  */
static	ANTLR3_BITWORD FOLLOW_OF_LITERAL_in_sequenceOfType4217_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_OF_LITERAL_in_sequenceOfType4217	= { FOLLOW_OF_LITERAL_in_sequenceOfType4217_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_sequenceOfType4222  */
static	ANTLR3_BITWORD FOLLOW_type_in_sequenceOfType4222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_sequenceOfType4222	= { FOLLOW_type_in_sequenceOfType4222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedType_in_sequenceOfType4228  */
static	ANTLR3_BITWORD FOLLOW_namedType_in_sequenceOfType4228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedType_in_sequenceOfType4228	= { FOLLOW_namedType_in_sequenceOfType4228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIZE_LITERAL_in_sizeConstraint4272  */
static	ANTLR3_BITWORD FOLLOW_SIZE_LITERAL_in_sizeConstraint4272_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SIZE_LITERAL_in_sizeConstraint4272	= { FOLLOW_SIZE_LITERAL_in_sizeConstraint4272_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_sizeConstraint4274  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_sizeConstraint4274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_sizeConstraint4274	= { FOLLOW_constraint_in_sizeConstraint4274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameterList_in_parameterizedAssignment4287  */
static	ANTLR3_BITWORD FOLLOW_parameterList_in_parameterizedAssignment4287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_parameterList_in_parameterizedAssignment4287	= { FOLLOW_parameterList_in_parameterizedAssignment4287_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_OP_in_parameterizedAssignment4291  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_OP_in_parameterizedAssignment4291_bits[]	= { ANTLR3_UINT64_LIT(0x6000087230F80380), ANTLR3_UINT64_LIT(0x00B0000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_OP_in_parameterizedAssignment4291	= { FOLLOW_ASSIGN_OP_in_parameterizedAssignment4291_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_parameterizedAssignment4296  */
static	ANTLR3_BITWORD FOLLOW_type_in_parameterizedAssignment4296_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_parameterizedAssignment4296	= { FOLLOW_type_in_parameterizedAssignment4296_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_parameterizedAssignment4303  */
static	ANTLR3_BITWORD FOLLOW_value_in_parameterizedAssignment4303_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_parameterizedAssignment4303	= { FOLLOW_value_in_parameterizedAssignment4303_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSet_in_parameterizedAssignment4309  */
static	ANTLR3_BITWORD FOLLOW_valueSet_in_parameterizedAssignment4309_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSet_in_parameterizedAssignment4309	= { FOLLOW_valueSet_in_parameterizedAssignment4309_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedObjectClass_in_parameterizedAssignment4319  */
static	ANTLR3_BITWORD FOLLOW_definedObjectClass_in_parameterizedAssignment4319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_definedObjectClass_in_parameterizedAssignment4319	= { FOLLOW_definedObjectClass_in_parameterizedAssignment4319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_OP_in_parameterizedAssignment4321  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_OP_in_parameterizedAssignment4321_bits[]	= { ANTLR3_UINT64_LIT(0xE000087230F80380), ANTLR3_UINT64_LIT(0x00B0000004100000) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_OP_in_parameterizedAssignment4321	= { FOLLOW_ASSIGN_OP_in_parameterizedAssignment4321_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_in_parameterizedAssignment4327  */
static	ANTLR3_BITWORD FOLLOW_object_in_parameterizedAssignment4327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_in_parameterizedAssignment4327	= { FOLLOW_object_in_parameterizedAssignment4327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectClass_in_parameterizedAssignment4334  */
static	ANTLR3_BITWORD FOLLOW_objectClass_in_parameterizedAssignment4334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectClass_in_parameterizedAssignment4334	= { FOLLOW_objectClass_in_parameterizedAssignment4334_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectSet_in_parameterizedAssignment4340  */
static	ANTLR3_BITWORD FOLLOW_objectSet_in_parameterizedAssignment4340_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectSet_in_parameterizedAssignment4340	= { FOLLOW_objectSet_in_parameterizedAssignment4340_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_parameterList4360  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_parameterList4360_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_parameterList4360	= { FOLLOW_L_BRACE_in_parameterList4360_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_in_parameterList4362  */
static	ANTLR3_BITWORD FOLLOW_parameter_in_parameterList4362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_in_parameterList4362	= { FOLLOW_parameter_in_parameterList4362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_parameterList4365  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_parameterList4365_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_parameterList4365	= { FOLLOW_COMMA_in_parameterList4365_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameter_in_parameterList4367  */
static	ANTLR3_BITWORD FOLLOW_parameter_in_parameterList4367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_parameter_in_parameterList4367	= { FOLLOW_parameter_in_parameterList4367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_parameterList4371  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_parameterList4371_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_parameterList4371	= { FOLLOW_R_BRACE_in_parameterList4371_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramGovernor_in_parameter4381  */
static	ANTLR3_BITWORD FOLLOW_paramGovernor_in_parameter4381_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_paramGovernor_in_parameter4381	= { FOLLOW_paramGovernor_in_parameter4381_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_parameter4383  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_parameter4383_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_parameter4383	= { FOLLOW_COLON_in_parameter4383_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_parameter4387  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_parameter4387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_parameter4387	= { FOLLOW_IDENTIFIER_in_parameter4387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_governor_in_paramGovernor4395  */
static	ANTLR3_BITWORD FOLLOW_governor_in_paramGovernor4395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_governor_in_paramGovernor4395	= { FOLLOW_governor_in_paramGovernor4395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_paramGovernor4399  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_paramGovernor4399_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_paramGovernor4399	= { FOLLOW_IDENTIFIER_in_paramGovernor4399_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_governor4411  */
static	ANTLR3_BITWORD FOLLOW_type_in_governor4411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_governor4411	= { FOLLOW_type_in_governor4411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedObjectClass_in_governor4415  */
static	ANTLR3_BITWORD FOLLOW_definedObjectClass_in_governor4415_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedObjectClass_in_governor4415	= { FOLLOW_definedObjectClass_in_governor4415_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_OP_in_objectClassAssignment4429  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_OP_in_objectClassAssignment4429_bits[]	= { ANTLR3_UINT64_LIT(0xE000087230F80380), ANTLR3_UINT64_LIT(0x00B0000004100000) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_OP_in_objectClassAssignment4429	= { FOLLOW_ASSIGN_OP_in_objectClassAssignment4429_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectClass_in_objectClassAssignment4432  */
static	ANTLR3_BITWORD FOLLOW_objectClass_in_objectClassAssignment4432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectClass_in_objectClassAssignment4432	= { FOLLOW_objectClass_in_objectClassAssignment4432_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedObjectClass_in_objectClass4444  */
static	ANTLR3_BITWORD FOLLOW_definedObjectClass_in_objectClass4444_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedObjectClass_in_objectClass4444	= { FOLLOW_definedObjectClass_in_objectClass4444_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectClassDefn_in_objectClass4450  */
static	ANTLR3_BITWORD FOLLOW_objectClassDefn_in_objectClass4450_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectClassDefn_in_objectClass4450	= { FOLLOW_objectClassDefn_in_objectClass4450_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_objectClass4456  */
static	ANTLR3_BITWORD FOLLOW_value_in_objectClass4456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_objectClass4456	= { FOLLOW_value_in_objectClass4456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_definedObjectClass4490  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_definedObjectClass4490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_definedObjectClass4490	= { FOLLOW_IDENTIFIER_in_definedObjectClass4490_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_definedObjectClass4492  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_definedObjectClass4492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_definedObjectClass4492	= { FOLLOW_DOT_in_definedObjectClass4492_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_definedObjectClass4498  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_definedObjectClass4498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_definedObjectClass4498	= { FOLLOW_IDENTIFIER_in_definedObjectClass4498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TYPE_IDENTIFIER_LITERAL_in_definedObjectClass4504  */
static	ANTLR3_BITWORD FOLLOW_TYPE_IDENTIFIER_LITERAL_in_definedObjectClass4504_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TYPE_IDENTIFIER_LITERAL_in_definedObjectClass4504	= { FOLLOW_TYPE_IDENTIFIER_LITERAL_in_definedObjectClass4504_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ABSTRACT_SYNTAX_LITERAL_in_definedObjectClass4510  */
static	ANTLR3_BITWORD FOLLOW_ABSTRACT_SYNTAX_LITERAL_in_definedObjectClass4510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ABSTRACT_SYNTAX_LITERAL_in_definedObjectClass4510	= { FOLLOW_ABSTRACT_SYNTAX_LITERAL_in_definedObjectClass4510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_definedObjectClass4524  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_definedObjectClass4524_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_definedObjectClass4524	= { FOLLOW_L_PARAN_in_definedObjectClass4524_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_definedObjectClass4529  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_definedObjectClass4529_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_definedObjectClass4529	= { FOLLOW_constraint_in_definedObjectClass4529_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sizeConstraint_in_definedObjectClass4535  */
static	ANTLR3_BITWORD FOLLOW_sizeConstraint_in_definedObjectClass4535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sizeConstraint_in_definedObjectClass4535	= { FOLLOW_sizeConstraint_in_definedObjectClass4535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_definedObjectClass4538  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_definedObjectClass4538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_definedObjectClass4538	= { FOLLOW_R_PARAN_in_definedObjectClass4538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_usefulObjectClassReference0  */
static	ANTLR3_BITWORD FOLLOW_set_in_usefulObjectClassReference0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_usefulObjectClassReference0	= { FOLLOW_set_in_usefulObjectClassReference0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_externalObjectClassReference4598  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_externalObjectClassReference4598_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_externalObjectClassReference4598	= { FOLLOW_IDENTIFIER_in_externalObjectClassReference4598_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_externalObjectClassReference4600  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_externalObjectClassReference4600_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_externalObjectClassReference4600	= { FOLLOW_DOT_in_externalObjectClassReference4600_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_externalObjectClassReference4602  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_externalObjectClassReference4602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_externalObjectClassReference4602	= { FOLLOW_IDENTIFIER_in_externalObjectClassReference4602_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLASS_LITERAL_in_objectClassDefn4612  */
static	ANTLR3_BITWORD FOLLOW_CLASS_LITERAL_in_objectClassDefn4612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_CLASS_LITERAL_in_objectClassDefn4612	= { FOLLOW_CLASS_LITERAL_in_objectClassDefn4612_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_objectClassDefn4614  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_objectClassDefn4614_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_objectClassDefn4614	= { FOLLOW_L_BRACE_in_objectClassDefn4614_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fieldSpec_in_objectClassDefn4617  */
static	ANTLR3_BITWORD FOLLOW_fieldSpec_in_objectClassDefn4617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_fieldSpec_in_objectClassDefn4617	= { FOLLOW_fieldSpec_in_objectClassDefn4617_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_objectClassDefn4620  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_objectClassDefn4620_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_objectClassDefn4620	= { FOLLOW_COMMA_in_objectClassDefn4620_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fieldSpec_in_objectClassDefn4622  */
static	ANTLR3_BITWORD FOLLOW_fieldSpec_in_objectClassDefn4622_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_fieldSpec_in_objectClassDefn4622	= { FOLLOW_fieldSpec_in_objectClassDefn4622_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_objectClassDefn4629  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_objectClassDefn4629_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_objectClassDefn4629	= { FOLLOW_R_BRACE_in_objectClassDefn4629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_withSyntaxSpec_in_objectClassDefn4632  */
static	ANTLR3_BITWORD FOLLOW_withSyntaxSpec_in_objectClassDefn4632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_withSyntaxSpec_in_objectClassDefn4632	= { FOLLOW_withSyntaxSpec_in_objectClassDefn4632_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WITH_LITERAL_in_withSyntaxSpec4642  */
static	ANTLR3_BITWORD FOLLOW_WITH_LITERAL_in_withSyntaxSpec4642_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_WITH_LITERAL_in_withSyntaxSpec4642	= { FOLLOW_WITH_LITERAL_in_withSyntaxSpec4642_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYNTAX_LITERAL_in_withSyntaxSpec4644  */
static	ANTLR3_BITWORD FOLLOW_SYNTAX_LITERAL_in_withSyntaxSpec4644_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_SYNTAX_LITERAL_in_withSyntaxSpec4644	= { FOLLOW_SYNTAX_LITERAL_in_withSyntaxSpec4644_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_syntaxList_in_withSyntaxSpec4646  */
static	ANTLR3_BITWORD FOLLOW_syntaxList_in_withSyntaxSpec4646_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_syntaxList_in_withSyntaxSpec4646	= { FOLLOW_syntaxList_in_withSyntaxSpec4646_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_syntaxList4655  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_syntaxList4655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002004000), ANTLR3_UINT64_LIT(0x0010000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_syntaxList4655	= { FOLLOW_L_BRACE_in_syntaxList4655_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tokenOrGroupSpec_in_syntaxList4657  */
static	ANTLR3_BITWORD FOLLOW_tokenOrGroupSpec_in_syntaxList4657_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003004000), ANTLR3_UINT64_LIT(0x0010000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_tokenOrGroupSpec_in_syntaxList4657	= { FOLLOW_tokenOrGroupSpec_in_syntaxList4657_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_syntaxList4660  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_syntaxList4660_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_syntaxList4660	= { FOLLOW_R_BRACE_in_syntaxList4660_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_requiredToken_in_tokenOrGroupSpec4670  */
static	ANTLR3_BITWORD FOLLOW_requiredToken_in_tokenOrGroupSpec4670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_requiredToken_in_tokenOrGroupSpec4670	= { FOLLOW_requiredToken_in_tokenOrGroupSpec4670_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_optionalGroup_in_tokenOrGroupSpec4674  */
static	ANTLR3_BITWORD FOLLOW_optionalGroup_in_tokenOrGroupSpec4674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_optionalGroup_in_tokenOrGroupSpec4674	= { FOLLOW_optionalGroup_in_tokenOrGroupSpec4674_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACKET_in_optionalGroup4684  */
static	ANTLR3_BITWORD FOLLOW_L_BRACKET_in_optionalGroup4684_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002004000), ANTLR3_UINT64_LIT(0x0010000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACKET_in_optionalGroup4684	= { FOLLOW_L_BRACKET_in_optionalGroup4684_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tokenOrGroupSpec_in_optionalGroup4687  */
static	ANTLR3_BITWORD FOLLOW_tokenOrGroupSpec_in_optionalGroup4687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002004000), ANTLR3_UINT64_LIT(0x001000000000000C) };
static  ANTLR3_BITSET_LIST FOLLOW_tokenOrGroupSpec_in_optionalGroup4687	= { FOLLOW_tokenOrGroupSpec_in_optionalGroup4687_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACKET_in_optionalGroup4691  */
static	ANTLR3_BITWORD FOLLOW_R_BRACKET_in_optionalGroup4691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACKET_in_optionalGroup4691	= { FOLLOW_R_BRACKET_in_optionalGroup4691_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_requiredToken4701  */
static	ANTLR3_BITWORD FOLLOW_literal_in_requiredToken4701_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_requiredToken4701	= { FOLLOW_literal_in_requiredToken4701_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_primitiveFieldName_in_requiredToken4705  */
static	ANTLR3_BITWORD FOLLOW_primitiveFieldName_in_requiredToken4705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_primitiveFieldName_in_requiredToken4705	= { FOLLOW_primitiveFieldName_in_requiredToken4705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_literal0  */
static	ANTLR3_BITWORD FOLLOW_set_in_literal0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_literal0	= { FOLLOW_set_in_literal0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_primitiveFieldName4728  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_primitiveFieldName4728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_primitiveFieldName4728	= { FOLLOW_AMPERSAND_in_primitiveFieldName4728_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_primitiveFieldName4730  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_primitiveFieldName4730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_primitiveFieldName4730	= { FOLLOW_IDENTIFIER_in_primitiveFieldName4730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_fieldSpec4741  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_fieldSpec4741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_fieldSpec4741	= { FOLLOW_AMPERSAND_in_fieldSpec4741_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_fieldSpec4743  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_fieldSpec4743_bits[]	= { ANTLR3_UINT64_LIT(0x600009F220604082), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_fieldSpec4743	= { FOLLOW_IDENTIFIER_in_fieldSpec4743_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeOptionalitySpec_in_fieldSpec4752  */
static	ANTLR3_BITWORD FOLLOW_typeOptionalitySpec_in_fieldSpec4752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeOptionalitySpec_in_fieldSpec4752	= { FOLLOW_typeOptionalitySpec_in_fieldSpec4752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_fieldSpec4762  */
static	ANTLR3_BITWORD FOLLOW_type_in_fieldSpec4762_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_fieldSpec4762	= { FOLLOW_type_in_fieldSpec4762_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSetOptionalitySpec_in_fieldSpec4765  */
static	ANTLR3_BITWORD FOLLOW_valueSetOptionalitySpec_in_fieldSpec4765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSetOptionalitySpec_in_fieldSpec4765	= { FOLLOW_valueSetOptionalitySpec_in_fieldSpec4765_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNIQUE_LITERAL_in_fieldSpec4771  */
static	ANTLR3_BITWORD FOLLOW_UNIQUE_LITERAL_in_fieldSpec4771_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNIQUE_LITERAL_in_fieldSpec4771	= { FOLLOW_UNIQUE_LITERAL_in_fieldSpec4771_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueOptionalitySpec_in_fieldSpec4774  */
static	ANTLR3_BITWORD FOLLOW_valueOptionalitySpec_in_fieldSpec4774_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueOptionalitySpec_in_fieldSpec4774	= { FOLLOW_valueOptionalitySpec_in_fieldSpec4774_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fieldName_in_fieldSpec4782  */
static	ANTLR3_BITWORD FOLLOW_fieldName_in_fieldSpec4782_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fieldName_in_fieldSpec4782	= { FOLLOW_fieldName_in_fieldSpec4782_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTIONAL_LITERAL_in_fieldSpec4785  */
static	ANTLR3_BITWORD FOLLOW_OPTIONAL_LITERAL_in_fieldSpec4785_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTIONAL_LITERAL_in_fieldSpec4785	= { FOLLOW_OPTIONAL_LITERAL_in_fieldSpec4785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_LITERAL_in_fieldSpec4790  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_LITERAL_in_fieldSpec4790_bits[]	= { ANTLR3_UINT64_LIT(0x6000087230F80380), ANTLR3_UINT64_LIT(0x00B0000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_LITERAL_in_fieldSpec4790	= { FOLLOW_DEFAULT_LITERAL_in_fieldSpec4790_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSet_in_fieldSpec4793  */
static	ANTLR3_BITWORD FOLLOW_valueSet_in_fieldSpec4793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSet_in_fieldSpec4793	= { FOLLOW_valueSet_in_fieldSpec4793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_fieldSpec4797  */
static	ANTLR3_BITWORD FOLLOW_value_in_fieldSpec4797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_fieldSpec4797	= { FOLLOW_value_in_fieldSpec4797_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedObjectClass_in_fieldSpec4806  */
static	ANTLR3_BITWORD FOLLOW_definedObjectClass_in_fieldSpec4806_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedObjectClass_in_fieldSpec4806	= { FOLLOW_definedObjectClass_in_fieldSpec4806_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTIONAL_LITERAL_in_fieldSpec4809  */
static	ANTLR3_BITWORD FOLLOW_OPTIONAL_LITERAL_in_fieldSpec4809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTIONAL_LITERAL_in_fieldSpec4809	= { FOLLOW_OPTIONAL_LITERAL_in_fieldSpec4809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_LITERAL_in_fieldSpec4814  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_LITERAL_in_fieldSpec4814_bits[]	= { ANTLR3_UINT64_LIT(0xE000087230F80380), ANTLR3_UINT64_LIT(0x00B0000004100000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_LITERAL_in_fieldSpec4814	= { FOLLOW_DEFAULT_LITERAL_in_fieldSpec4814_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectSet_in_fieldSpec4817  */
static	ANTLR3_BITWORD FOLLOW_objectSet_in_fieldSpec4817_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectSet_in_fieldSpec4817	= { FOLLOW_objectSet_in_fieldSpec4817_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_in_fieldSpec4821  */
static	ANTLR3_BITWORD FOLLOW_object_in_fieldSpec4821_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_in_fieldSpec4821	= { FOLLOW_object_in_fieldSpec4821_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_typeFieldSpec4847  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_typeFieldSpec4847_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_typeFieldSpec4847	= { FOLLOW_AMPERSAND_in_typeFieldSpec4847_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_typeFieldSpec4849  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_typeFieldSpec4849_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_typeFieldSpec4849	= { FOLLOW_IDENTIFIER_in_typeFieldSpec4849_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeOptionalitySpec_in_typeFieldSpec4851  */
static	ANTLR3_BITWORD FOLLOW_typeOptionalitySpec_in_typeFieldSpec4851_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeOptionalitySpec_in_typeFieldSpec4851	= { FOLLOW_typeOptionalitySpec_in_typeFieldSpec4851_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTIONAL_LITERAL_in_typeOptionalitySpec4861  */
static	ANTLR3_BITWORD FOLLOW_OPTIONAL_LITERAL_in_typeOptionalitySpec4861_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTIONAL_LITERAL_in_typeOptionalitySpec4861	= { FOLLOW_OPTIONAL_LITERAL_in_typeOptionalitySpec4861_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_LITERAL_in_typeOptionalitySpec4866  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_LITERAL_in_typeOptionalitySpec4866_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_LITERAL_in_typeOptionalitySpec4866	= { FOLLOW_DEFAULT_LITERAL_in_typeOptionalitySpec4866_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_typeOptionalitySpec4868  */
static	ANTLR3_BITWORD FOLLOW_type_in_typeOptionalitySpec4868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_typeOptionalitySpec4868	= { FOLLOW_type_in_typeOptionalitySpec4868_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_fixedTypeValueFieldSpec4877  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_fixedTypeValueFieldSpec4877_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_fixedTypeValueFieldSpec4877	= { FOLLOW_AMPERSAND_in_fixedTypeValueFieldSpec4877_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_fixedTypeValueFieldSpec4879  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_fixedTypeValueFieldSpec4879_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_fixedTypeValueFieldSpec4879	= { FOLLOW_IDENTIFIER_in_fixedTypeValueFieldSpec4879_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_fixedTypeValueFieldSpec4881  */
static	ANTLR3_BITWORD FOLLOW_type_in_fixedTypeValueFieldSpec4881_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_fixedTypeValueFieldSpec4881	= { FOLLOW_type_in_fixedTypeValueFieldSpec4881_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNIQUE_LITERAL_in_fixedTypeValueFieldSpec4883  */
static	ANTLR3_BITWORD FOLLOW_UNIQUE_LITERAL_in_fixedTypeValueFieldSpec4883_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNIQUE_LITERAL_in_fixedTypeValueFieldSpec4883	= { FOLLOW_UNIQUE_LITERAL_in_fixedTypeValueFieldSpec4883_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueOptionalitySpec_in_fixedTypeValueFieldSpec4886  */
static	ANTLR3_BITWORD FOLLOW_valueOptionalitySpec_in_fixedTypeValueFieldSpec4886_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueOptionalitySpec_in_fixedTypeValueFieldSpec4886	= { FOLLOW_valueOptionalitySpec_in_fixedTypeValueFieldSpec4886_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTIONAL_LITERAL_in_valueOptionalitySpec4897  */
static	ANTLR3_BITWORD FOLLOW_OPTIONAL_LITERAL_in_valueOptionalitySpec4897_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTIONAL_LITERAL_in_valueOptionalitySpec4897	= { FOLLOW_OPTIONAL_LITERAL_in_valueOptionalitySpec4897_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_LITERAL_in_valueOptionalitySpec4902  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_LITERAL_in_valueOptionalitySpec4902_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_LITERAL_in_valueOptionalitySpec4902	= { FOLLOW_DEFAULT_LITERAL_in_valueOptionalitySpec4902_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_valueOptionalitySpec4904  */
static	ANTLR3_BITWORD FOLLOW_value_in_valueOptionalitySpec4904_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_valueOptionalitySpec4904	= { FOLLOW_value_in_valueOptionalitySpec4904_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_variableTypeValueFieldSpec4914  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_variableTypeValueFieldSpec4914_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_variableTypeValueFieldSpec4914	= { FOLLOW_AMPERSAND_in_variableTypeValueFieldSpec4914_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_variableTypeValueFieldSpec4916  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_variableTypeValueFieldSpec4916_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_variableTypeValueFieldSpec4916	= { FOLLOW_IDENTIFIER_in_variableTypeValueFieldSpec4916_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fieldName_in_variableTypeValueFieldSpec4919  */
static	ANTLR3_BITWORD FOLLOW_fieldName_in_variableTypeValueFieldSpec4919_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fieldName_in_variableTypeValueFieldSpec4919	= { FOLLOW_fieldName_in_variableTypeValueFieldSpec4919_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueOptionalitySpec_in_variableTypeValueFieldSpec4921  */
static	ANTLR3_BITWORD FOLLOW_valueOptionalitySpec_in_variableTypeValueFieldSpec4921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueOptionalitySpec_in_variableTypeValueFieldSpec4921	= { FOLLOW_valueOptionalitySpec_in_variableTypeValueFieldSpec4921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_fixedTypeValueSetFieldSpec4933  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_fixedTypeValueSetFieldSpec4933_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_fixedTypeValueSetFieldSpec4933	= { FOLLOW_AMPERSAND_in_fixedTypeValueSetFieldSpec4933_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_fixedTypeValueSetFieldSpec4935  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_fixedTypeValueSetFieldSpec4935_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_fixedTypeValueSetFieldSpec4935	= { FOLLOW_IDENTIFIER_in_fixedTypeValueSetFieldSpec4935_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_fixedTypeValueSetFieldSpec4939  */
static	ANTLR3_BITWORD FOLLOW_type_in_fixedTypeValueSetFieldSpec4939_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_fixedTypeValueSetFieldSpec4939	= { FOLLOW_type_in_fixedTypeValueSetFieldSpec4939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSetOptionalitySpec_in_fixedTypeValueSetFieldSpec4941  */
static	ANTLR3_BITWORD FOLLOW_valueSetOptionalitySpec_in_fixedTypeValueSetFieldSpec4941_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSetOptionalitySpec_in_fixedTypeValueSetFieldSpec4941	= { FOLLOW_valueSetOptionalitySpec_in_fixedTypeValueSetFieldSpec4941_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTIONAL_LITERAL_in_valueSetOptionalitySpec4953  */
static	ANTLR3_BITWORD FOLLOW_OPTIONAL_LITERAL_in_valueSetOptionalitySpec4953_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTIONAL_LITERAL_in_valueSetOptionalitySpec4953	= { FOLLOW_OPTIONAL_LITERAL_in_valueSetOptionalitySpec4953_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_LITERAL_in_valueSetOptionalitySpec4957  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_LITERAL_in_valueSetOptionalitySpec4957_bits[]	= { ANTLR3_UINT64_LIT(0x6000087230F80380), ANTLR3_UINT64_LIT(0x00B0000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_LITERAL_in_valueSetOptionalitySpec4957	= { FOLLOW_DEFAULT_LITERAL_in_valueSetOptionalitySpec4957_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSet_in_valueSetOptionalitySpec4959  */
static	ANTLR3_BITWORD FOLLOW_valueSet_in_valueSetOptionalitySpec4959_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSet_in_valueSetOptionalitySpec4959	= { FOLLOW_valueSet_in_valueSetOptionalitySpec4959_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedObject_in_object4969  */
static	ANTLR3_BITWORD FOLLOW_definedObject_in_object4969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedObject_in_object4969	= { FOLLOW_definedObject_in_object4969_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameterizedObject_in_object4975  */
static	ANTLR3_BITWORD FOLLOW_parameterizedObject_in_object4975_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_parameterizedObject_in_object4975	= { FOLLOW_parameterizedObject_in_object4975_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedObject_in_parameterizedObject4984  */
static	ANTLR3_BITWORD FOLLOW_definedObject_in_parameterizedObject4984_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_definedObject_in_parameterizedObject4984	= { FOLLOW_definedObject_in_parameterizedObject4984_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_actualParameterList_in_parameterizedObject4986  */
static	ANTLR3_BITWORD FOLLOW_actualParameterList_in_parameterizedObject4986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_actualParameterList_in_parameterizedObject4986	= { FOLLOW_actualParameterList_in_parameterizedObject4986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_definedObject4998  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_definedObject4998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_definedObject4998	= { FOLLOW_IDENTIFIER_in_definedObject4998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_definedObject5001  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_definedObject5001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_definedObject5001	= { FOLLOW_DOT_in_definedObject5001_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_objectSet5013  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_objectSet5013_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814981300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_objectSet5013	= { FOLLOW_L_BRACE_in_objectSet5013_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectSetSpec_in_objectSet5015  */
static	ANTLR3_BITWORD FOLLOW_objectSetSpec_in_objectSet5015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_objectSetSpec_in_objectSet5015	= { FOLLOW_objectSetSpec_in_objectSet5015_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_objectSet5017  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_objectSet5017_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_objectSet5017	= { FOLLOW_R_BRACE_in_objectSet5017_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rootElementSetSpec_in_objectSetSpec5029  */
static	ANTLR3_BITWORD FOLLOW_rootElementSetSpec_in_objectSetSpec5029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rootElementSetSpec_in_objectSetSpec5029	= { FOLLOW_rootElementSetSpec_in_objectSetSpec5029_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_objectSetSpec5032  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_objectSetSpec5032_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_objectSetSpec5032	= { FOLLOW_COMMA_in_objectSetSpec5032_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ELLIPSIS_in_objectSetSpec5034  */
static	ANTLR3_BITWORD FOLLOW_ELLIPSIS_in_objectSetSpec5034_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ELLIPSIS_in_objectSetSpec5034	= { FOLLOW_ELLIPSIS_in_objectSetSpec5034_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_objectSetSpec5037  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_objectSetSpec5037_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_objectSetSpec5037	= { FOLLOW_COMMA_in_objectSetSpec5037_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_additionalElementSetSpec_in_objectSetSpec5039  */
static	ANTLR3_BITWORD FOLLOW_additionalElementSetSpec_in_objectSetSpec5039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_additionalElementSetSpec_in_objectSetSpec5039	= { FOLLOW_additionalElementSetSpec_in_objectSetSpec5039_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ELLIPSIS_in_objectSetSpec5049  */
static	ANTLR3_BITWORD FOLLOW_ELLIPSIS_in_objectSetSpec5049_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ELLIPSIS_in_objectSetSpec5049	= { FOLLOW_ELLIPSIS_in_objectSetSpec5049_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_objectSetSpec5052  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_objectSetSpec5052_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_objectSetSpec5052	= { FOLLOW_COMMA_in_objectSetSpec5052_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_additionalElementSetSpec_in_objectSetSpec5054  */
static	ANTLR3_BITWORD FOLLOW_additionalElementSetSpec_in_objectSetSpec5054_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_additionalElementSetSpec_in_objectSetSpec5054	= { FOLLOW_additionalElementSetSpec_in_objectSetSpec5054_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_fieldName5067  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_fieldName5067_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_fieldName5067	= { FOLLOW_AMPERSAND_in_fieldName5067_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_fieldName5069  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_fieldName5069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_fieldName5069	= { FOLLOW_IDENTIFIER_in_fieldName5069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_fieldName5072  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_fieldName5072_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_fieldName5072	= { FOLLOW_AMPERSAND_in_fieldName5072_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_fieldName5074  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_fieldName5074_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_fieldName5074	= { FOLLOW_IDENTIFIER_in_fieldName5074_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_fieldName5076  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_fieldName5076_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_fieldName5076	= { FOLLOW_DOT_in_fieldName5076_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_valueSet5086  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_valueSet5086_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_valueSet5086	= { FOLLOW_L_BRACE_in_valueSet5086_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elementSetSpecs_in_valueSet5088  */
static	ANTLR3_BITWORD FOLLOW_elementSetSpecs_in_valueSet5088_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_elementSetSpecs_in_valueSet5088	= { FOLLOW_elementSetSpecs_in_valueSet5088_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_valueSet5090  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_valueSet5090_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_valueSet5090	= { FOLLOW_R_BRACE_in_valueSet5090_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rootElementSetSpec_in_elementSetSpecs5101  */
static	ANTLR3_BITWORD FOLLOW_rootElementSetSpec_in_elementSetSpecs5101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rootElementSetSpec_in_elementSetSpecs5101	= { FOLLOW_rootElementSetSpec_in_elementSetSpecs5101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_elementSetSpecs5104  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_elementSetSpecs5104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_elementSetSpecs5104	= { FOLLOW_COMMA_in_elementSetSpecs5104_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ELLIPSIS_in_elementSetSpecs5106  */
static	ANTLR3_BITWORD FOLLOW_ELLIPSIS_in_elementSetSpecs5106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ELLIPSIS_in_elementSetSpecs5106	= { FOLLOW_ELLIPSIS_in_elementSetSpecs5106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_elementSetSpecs5109  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_elementSetSpecs5109_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_elementSetSpecs5109	= { FOLLOW_COMMA_in_elementSetSpecs5109_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_additionalElementSetSpec_in_elementSetSpecs5111  */
static	ANTLR3_BITWORD FOLLOW_additionalElementSetSpec_in_elementSetSpecs5111_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_additionalElementSetSpec_in_elementSetSpecs5111	= { FOLLOW_additionalElementSetSpec_in_elementSetSpecs5111_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elementSetSpec_in_rootElementSetSpec5124  */
static	ANTLR3_BITWORD FOLLOW_elementSetSpec_in_rootElementSetSpec5124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_elementSetSpec_in_rootElementSetSpec5124	= { FOLLOW_elementSetSpec_in_rootElementSetSpec5124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elementSetSpec_in_additionalElementSetSpec5133  */
static	ANTLR3_BITWORD FOLLOW_elementSetSpec_in_additionalElementSetSpec5133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_elementSetSpec_in_additionalElementSetSpec5133	= { FOLLOW_elementSetSpec_in_additionalElementSetSpec5133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unions_in_elementSetSpec5142  */
static	ANTLR3_BITWORD FOLLOW_unions_in_elementSetSpec5142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unions_in_elementSetSpec5142	= { FOLLOW_unions_in_elementSetSpec5142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ALL_LITERAL_in_elementSetSpec5146  */
static	ANTLR3_BITWORD FOLLOW_ALL_LITERAL_in_elementSetSpec5146_bits[]	= { ANTLR3_UINT64_LIT(0x0000400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ALL_LITERAL_in_elementSetSpec5146	= { FOLLOW_ALL_LITERAL_in_elementSetSpec5146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exclusions_in_elementSetSpec5148  */
static	ANTLR3_BITWORD FOLLOW_exclusions_in_elementSetSpec5148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exclusions_in_elementSetSpec5148	= { FOLLOW_exclusions_in_elementSetSpec5148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_intersections_in_unions5160  */
static	ANTLR3_BITWORD FOLLOW_intersections_in_unions5160_bits[]	= { ANTLR3_UINT64_LIT(0x0003000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_intersections_in_unions5160	= { FOLLOW_intersections_in_unions5160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unionMark_in_unions5164  */
static	ANTLR3_BITWORD FOLLOW_unionMark_in_unions5164_bits[]	= { ANTLR3_UINT64_LIT(0x1050000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_unionMark_in_unions5164	= { FOLLOW_unionMark_in_unions5164_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_intersections_in_unions5166  */
static	ANTLR3_BITWORD FOLLOW_intersections_in_unions5166_bits[]	= { ANTLR3_UINT64_LIT(0x0003000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_intersections_in_unions5166	= { FOLLOW_intersections_in_unions5166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXCEPT_LITERAL_in_exclusions5176  */
static	ANTLR3_BITWORD FOLLOW_EXCEPT_LITERAL_in_exclusions5176_bits[]	= { ANTLR3_UINT64_LIT(0x1050000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EXCEPT_LITERAL_in_exclusions5176	= { FOLLOW_EXCEPT_LITERAL_in_exclusions5176_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elements_in_exclusions5178  */
static	ANTLR3_BITWORD FOLLOW_elements_in_exclusions5178_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_elements_in_exclusions5178	= { FOLLOW_elements_in_exclusions5178_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_intersectionElements_in_intersections5188  */
static	ANTLR3_BITWORD FOLLOW_intersectionElements_in_intersections5188_bits[]	= { ANTLR3_UINT64_LIT(0x0004800000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_intersectionElements_in_intersections5188	= { FOLLOW_intersectionElements_in_intersections5188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_intersectionMark_in_intersections5192  */
static	ANTLR3_BITWORD FOLLOW_intersectionMark_in_intersections5192_bits[]	= { ANTLR3_UINT64_LIT(0x1050000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_intersectionMark_in_intersections5192	= { FOLLOW_intersectionMark_in_intersections5192_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_intersectionElements_in_intersections5194  */
static	ANTLR3_BITWORD FOLLOW_intersectionElements_in_intersections5194_bits[]	= { ANTLR3_UINT64_LIT(0x0004800000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_intersectionElements_in_intersections5194	= { FOLLOW_intersectionElements_in_intersections5194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_unionMark0  */
static	ANTLR3_BITWORD FOLLOW_set_in_unionMark0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_unionMark0	= { FOLLOW_set_in_unionMark0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_intersectionMark0  */
static	ANTLR3_BITWORD FOLLOW_set_in_intersectionMark0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_intersectionMark0	= { FOLLOW_set_in_intersectionMark0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subtypeElements_in_elements5247  */
static	ANTLR3_BITWORD FOLLOW_subtypeElements_in_elements5247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subtypeElements_in_elements5247	= { FOLLOW_subtypeElements_in_elements5247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_in_objectSetElements5263  */
static	ANTLR3_BITWORD FOLLOW_object_in_objectSetElements5263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_in_objectSetElements5263	= { FOLLOW_object_in_objectSetElements5263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedObject_in_objectSetElements5267  */
static	ANTLR3_BITWORD FOLLOW_definedObject_in_objectSetElements5267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedObject_in_objectSetElements5267	= { FOLLOW_definedObject_in_objectSetElements5267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elements_in_intersectionElements5279  */
static	ANTLR3_BITWORD FOLLOW_elements_in_intersectionElements5279_bits[]	= { ANTLR3_UINT64_LIT(0x0000400000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_elements_in_intersectionElements5279	= { FOLLOW_elements_in_intersectionElements5279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exclusions_in_intersectionElements5282  */
static	ANTLR3_BITWORD FOLLOW_exclusions_in_intersectionElements5282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exclusions_in_intersectionElements5282	= { FOLLOW_exclusions_in_intersectionElements5282_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_subtypeElements5300  */
static	ANTLR3_BITWORD FOLLOW_value_in_subtypeElements5300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008800) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_subtypeElements5300	= { FOLLOW_value_in_subtypeElements5300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MIN_LITERAL_in_subtypeElements5304  */
static	ANTLR3_BITWORD FOLLOW_MIN_LITERAL_in_subtypeElements5304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008800) };
static  ANTLR3_BITSET_LIST FOLLOW_MIN_LITERAL_in_subtypeElements5304	= { FOLLOW_MIN_LITERAL_in_subtypeElements5304_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_in_subtypeElements5307  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_in_subtypeElements5307_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_in_subtypeElements5307	= { FOLLOW_LESS_THAN_in_subtypeElements5307_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOUBLE_DOT_in_subtypeElements5311  */
static	ANTLR3_BITWORD FOLLOW_DOUBLE_DOT_in_subtypeElements5311_bits[]	= { ANTLR3_UINT64_LIT(0x0020000010988300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOUBLE_DOT_in_subtypeElements5311	= { FOLLOW_DOUBLE_DOT_in_subtypeElements5311_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_in_subtypeElements5313  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_in_subtypeElements5313_bits[]	= { ANTLR3_UINT64_LIT(0x0020000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_in_subtypeElements5313	= { FOLLOW_LESS_THAN_in_subtypeElements5313_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_subtypeElements5318  */
static	ANTLR3_BITWORD FOLLOW_value_in_subtypeElements5318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_subtypeElements5318	= { FOLLOW_value_in_subtypeElements5318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MAX_LITERAL_in_subtypeElements5322  */
static	ANTLR3_BITWORD FOLLOW_MAX_LITERAL_in_subtypeElements5322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MAX_LITERAL_in_subtypeElements5322	= { FOLLOW_MAX_LITERAL_in_subtypeElements5322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sizeConstraint_in_subtypeElements5330  */
static	ANTLR3_BITWORD FOLLOW_sizeConstraint_in_subtypeElements5330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sizeConstraint_in_subtypeElements5330	= { FOLLOW_sizeConstraint_in_subtypeElements5330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PATTERN_LITERAL_in_subtypeElements5336  */
static	ANTLR3_BITWORD FOLLOW_PATTERN_LITERAL_in_subtypeElements5336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PATTERN_LITERAL_in_subtypeElements5336	= { FOLLOW_PATTERN_LITERAL_in_subtypeElements5336_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_subtypeElements5338  */
static	ANTLR3_BITWORD FOLLOW_value_in_subtypeElements5338_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_subtypeElements5338	= { FOLLOW_value_in_subtypeElements5338_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_subtypeElements5344  */
static	ANTLR3_BITWORD FOLLOW_value_in_subtypeElements5344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_subtypeElements5344	= { FOLLOW_value_in_subtypeElements5344_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_variableTypeValueSetFieldSpec5355  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_variableTypeValueSetFieldSpec5355_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_variableTypeValueSetFieldSpec5355	= { FOLLOW_AMPERSAND_in_variableTypeValueSetFieldSpec5355_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_variableTypeValueSetFieldSpec5357  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_variableTypeValueSetFieldSpec5357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_variableTypeValueSetFieldSpec5357	= { FOLLOW_IDENTIFIER_in_variableTypeValueSetFieldSpec5357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fieldName_in_variableTypeValueSetFieldSpec5362  */
static	ANTLR3_BITWORD FOLLOW_fieldName_in_variableTypeValueSetFieldSpec5362_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fieldName_in_variableTypeValueSetFieldSpec5362	= { FOLLOW_fieldName_in_variableTypeValueSetFieldSpec5362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSetOptionalitySpec_in_variableTypeValueSetFieldSpec5364  */
static	ANTLR3_BITWORD FOLLOW_valueSetOptionalitySpec_in_variableTypeValueSetFieldSpec5364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSetOptionalitySpec_in_variableTypeValueSetFieldSpec5364	= { FOLLOW_valueSetOptionalitySpec_in_variableTypeValueSetFieldSpec5364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_objectFieldSpec5374  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_objectFieldSpec5374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_objectFieldSpec5374	= { FOLLOW_AMPERSAND_in_objectFieldSpec5374_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_objectFieldSpec5376  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_objectFieldSpec5376_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_objectFieldSpec5376	= { FOLLOW_IDENTIFIER_in_objectFieldSpec5376_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedObjectClass_in_objectFieldSpec5378  */
static	ANTLR3_BITWORD FOLLOW_definedObjectClass_in_objectFieldSpec5378_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedObjectClass_in_objectFieldSpec5378	= { FOLLOW_definedObjectClass_in_objectFieldSpec5378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectOptionalitySpec_in_objectFieldSpec5380  */
static	ANTLR3_BITWORD FOLLOW_objectOptionalitySpec_in_objectFieldSpec5380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectOptionalitySpec_in_objectFieldSpec5380	= { FOLLOW_objectOptionalitySpec_in_objectFieldSpec5380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTIONAL_LITERAL_in_objectOptionalitySpec5390  */
static	ANTLR3_BITWORD FOLLOW_OPTIONAL_LITERAL_in_objectOptionalitySpec5390_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTIONAL_LITERAL_in_objectOptionalitySpec5390	= { FOLLOW_OPTIONAL_LITERAL_in_objectOptionalitySpec5390_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_LITERAL_in_objectOptionalitySpec5394  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_LITERAL_in_objectOptionalitySpec5394_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_LITERAL_in_objectOptionalitySpec5394	= { FOLLOW_DEFAULT_LITERAL_in_objectOptionalitySpec5394_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_in_objectOptionalitySpec5396  */
static	ANTLR3_BITWORD FOLLOW_object_in_objectOptionalitySpec5396_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_in_objectOptionalitySpec5396	= { FOLLOW_object_in_objectOptionalitySpec5396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AMPERSAND_in_objectSetFieldSpec5405  */
static	ANTLR3_BITWORD FOLLOW_AMPERSAND_in_objectSetFieldSpec5405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AMPERSAND_in_objectSetFieldSpec5405	= { FOLLOW_AMPERSAND_in_objectSetFieldSpec5405_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_objectSetFieldSpec5407  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_objectSetFieldSpec5407_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_objectSetFieldSpec5407	= { FOLLOW_IDENTIFIER_in_objectSetFieldSpec5407_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedObjectClass_in_objectSetFieldSpec5409  */
static	ANTLR3_BITWORD FOLLOW_definedObjectClass_in_objectSetFieldSpec5409_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedObjectClass_in_objectSetFieldSpec5409	= { FOLLOW_definedObjectClass_in_objectSetFieldSpec5409_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectSetOptionalitySpec_in_objectSetFieldSpec5411  */
static	ANTLR3_BITWORD FOLLOW_objectSetOptionalitySpec_in_objectSetFieldSpec5411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectSetOptionalitySpec_in_objectSetFieldSpec5411	= { FOLLOW_objectSetOptionalitySpec_in_objectSetFieldSpec5411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTIONAL_LITERAL_in_objectSetOptionalitySpec5422  */
static	ANTLR3_BITWORD FOLLOW_OPTIONAL_LITERAL_in_objectSetOptionalitySpec5422_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTIONAL_LITERAL_in_objectSetOptionalitySpec5422	= { FOLLOW_OPTIONAL_LITERAL_in_objectSetOptionalitySpec5422_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_LITERAL_in_objectSetOptionalitySpec5426  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_LITERAL_in_objectSetOptionalitySpec5426_bits[]	= { ANTLR3_UINT64_LIT(0xE000087230F80380), ANTLR3_UINT64_LIT(0x00B0000004100000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_LITERAL_in_objectSetOptionalitySpec5426	= { FOLLOW_DEFAULT_LITERAL_in_objectSetOptionalitySpec5426_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectSet_in_objectSetOptionalitySpec5428  */
static	ANTLR3_BITWORD FOLLOW_objectSet_in_objectSetOptionalitySpec5428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectSet_in_objectSetOptionalitySpec5428	= { FOLLOW_objectSet_in_objectSetOptionalitySpec5428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_OP_in_typeAssignment5446  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_OP_in_typeAssignment5446_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_OP_in_typeAssignment5446	= { FOLLOW_ASSIGN_OP_in_typeAssignment5446_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_typeAssignment5455  */
static	ANTLR3_BITWORD FOLLOW_type_in_typeAssignment5455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_typeAssignment5455	= { FOLLOW_type_in_typeAssignment5455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_valueAssignment5482  */
static	ANTLR3_BITWORD FOLLOW_type_in_valueAssignment5482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_valueAssignment5482	= { FOLLOW_type_in_valueAssignment5482_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSIGN_OP_in_valueAssignment5492  */
static	ANTLR3_BITWORD FOLLOW_ASSIGN_OP_in_valueAssignment5492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSIGN_OP_in_valueAssignment5492	= { FOLLOW_ASSIGN_OP_in_valueAssignment5492_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_valueAssignment5502  */
static	ANTLR3_BITWORD FOLLOW_value_in_valueAssignment5502_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_valueAssignment5502	= { FOLLOW_value_in_valueAssignment5502_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACKET_in_extraTagDescriptors5528  */
static	ANTLR3_BITWORD FOLLOW_L_BRACKET_in_extraTagDescriptors5528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0020000000E00000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACKET_in_extraTagDescriptors5528	= { FOLLOW_L_BRACKET_in_extraTagDescriptors5528_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNIVERSAL_LITERAL_in_extraTagDescriptors5533  */
static	ANTLR3_BITWORD FOLLOW_UNIVERSAL_LITERAL_in_extraTagDescriptors5533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0020000000E00000) };
static  ANTLR3_BITSET_LIST FOLLOW_UNIVERSAL_LITERAL_in_extraTagDescriptors5533	= { FOLLOW_UNIVERSAL_LITERAL_in_extraTagDescriptors5533_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_APPLICATION_LITERAL_in_extraTagDescriptors5539  */
static	ANTLR3_BITWORD FOLLOW_APPLICATION_LITERAL_in_extraTagDescriptors5539_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0020000000E00000) };
static  ANTLR3_BITSET_LIST FOLLOW_APPLICATION_LITERAL_in_extraTagDescriptors5539	= { FOLLOW_APPLICATION_LITERAL_in_extraTagDescriptors5539_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRIVATE_LITERAL_in_extraTagDescriptors5545  */
static	ANTLR3_BITWORD FOLLOW_PRIVATE_LITERAL_in_extraTagDescriptors5545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0020000000E00000) };
static  ANTLR3_BITSET_LIST FOLLOW_PRIVATE_LITERAL_in_extraTagDescriptors5545	= { FOLLOW_PRIVATE_LITERAL_in_extraTagDescriptors5545_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_extraTagDescriptors5551  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_extraTagDescriptors5551_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_extraTagDescriptors5551	= { FOLLOW_NUMBER_in_extraTagDescriptors5551_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACKET_in_extraTagDescriptors5553  */
static	ANTLR3_BITWORD FOLLOW_R_BRACKET_in_extraTagDescriptors5553_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001400) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACKET_in_extraTagDescriptors5553	= { FOLLOW_R_BRACKET_in_extraTagDescriptors5553_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPLICIT_LITERAL_in_extraTagDescriptors5558  */
static	ANTLR3_BITWORD FOLLOW_IMPLICIT_LITERAL_in_extraTagDescriptors5558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000001400) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPLICIT_LITERAL_in_extraTagDescriptors5558	= { FOLLOW_IMPLICIT_LITERAL_in_extraTagDescriptors5558_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXPLICIT_LITERAL_in_extraTagDescriptors5563  */
static	ANTLR3_BITWORD FOLLOW_EXPLICIT_LITERAL_in_extraTagDescriptors5563_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_EXPLICIT_LITERAL_in_extraTagDescriptors5563	= { FOLLOW_EXPLICIT_LITERAL_in_extraTagDescriptors5563_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extraTagDescriptors_in_type5599  */
static	ANTLR3_BITWORD FOLLOW_extraTagDescriptors_in_type5599_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_extraTagDescriptors_in_type5599	= { FOLLOW_extraTagDescriptors_in_type5599_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtinType_in_type5605  */
static	ANTLR3_BITWORD FOLLOW_builtinType_in_type5605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_builtinType_in_type5605	= { FOLLOW_builtinType_in_type5605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_referencedType_in_type5611  */
static	ANTLR3_BITWORD FOLLOW_referencedType_in_type5611_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_referencedType_in_type5611	= { FOLLOW_referencedType_in_type5611_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetStringType_in_builtinType5643  */
static	ANTLR3_BITWORD FOLLOW_octetStringType_in_builtinType5643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_octetStringType_in_builtinType5643	= { FOLLOW_octetStringType_in_builtinType5643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ia5stringType_in_builtinType5649  */
static	ANTLR3_BITWORD FOLLOW_ia5stringType_in_builtinType5649_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ia5stringType_in_builtinType5649	= { FOLLOW_ia5stringType_in_builtinType5649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_booleanType_in_builtinType5654  */
static	ANTLR3_BITWORD FOLLOW_booleanType_in_builtinType5654_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_booleanType_in_builtinType5654	= { FOLLOW_booleanType_in_builtinType5654_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nullType_in_builtinType5659  */
static	ANTLR3_BITWORD FOLLOW_nullType_in_builtinType5659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nullType_in_builtinType5659	= { FOLLOW_nullType_in_builtinType5659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitStringType_in_builtinType5664  */
static	ANTLR3_BITWORD FOLLOW_bitStringType_in_builtinType5664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitStringType_in_builtinType5664	= { FOLLOW_bitStringType_in_builtinType5664_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_choiceType_in_builtinType5669  */
static	ANTLR3_BITWORD FOLLOW_choiceType_in_builtinType5669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_choiceType_in_builtinType5669	= { FOLLOW_choiceType_in_builtinType5669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumeratedType_in_builtinType5675  */
static	ANTLR3_BITWORD FOLLOW_enumeratedType_in_builtinType5675_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumeratedType_in_builtinType5675	= { FOLLOW_enumeratedType_in_builtinType5675_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integerType_in_builtinType5681  */
static	ANTLR3_BITWORD FOLLOW_integerType_in_builtinType5681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integerType_in_builtinType5681	= { FOLLOW_integerType_in_builtinType5681_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceType_in_builtinType5687  */
static	ANTLR3_BITWORD FOLLOW_sequenceType_in_builtinType5687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceType_in_builtinType5687	= { FOLLOW_sequenceType_in_builtinType5687_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceOfType_in_builtinType5693  */
static	ANTLR3_BITWORD FOLLOW_sequenceOfType_in_builtinType5693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceOfType_in_builtinType5693	= { FOLLOW_sequenceOfType_in_builtinType5693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_setType_in_builtinType5699  */
static	ANTLR3_BITWORD FOLLOW_setType_in_builtinType5699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_setType_in_builtinType5699	= { FOLLOW_setType_in_builtinType5699_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_setOfType_in_builtinType5705  */
static	ANTLR3_BITWORD FOLLOW_setOfType_in_builtinType5705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_setOfType_in_builtinType5705	= { FOLLOW_setOfType_in_builtinType5705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectidentifiertype_in_builtinType5711  */
static	ANTLR3_BITWORD FOLLOW_objectidentifiertype_in_builtinType5711_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectidentifiertype_in_builtinType5711	= { FOLLOW_objectidentifiertype_in_builtinType5711_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectClassFieldType_in_builtinType5717  */
static	ANTLR3_BITWORD FOLLOW_objectClassFieldType_in_builtinType5717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectClassFieldType_in_builtinType5717	= { FOLLOW_objectClassFieldType_in_builtinType5717_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedObjectClass_in_objectClassFieldType5728  */
static	ANTLR3_BITWORD FOLLOW_definedObjectClass_in_objectClassFieldType5728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_definedObjectClass_in_objectClassFieldType5728	= { FOLLOW_definedObjectClass_in_objectClassFieldType5728_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_objectClassFieldType5730  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_objectClassFieldType5730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_objectClassFieldType5730	= { FOLLOW_DOT_in_objectClassFieldType5730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fieldName_in_objectClassFieldType5732  */
static	ANTLR3_BITWORD FOLLOW_fieldName_in_objectClassFieldType5732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fieldName_in_objectClassFieldType5732	= { FOLLOW_fieldName_in_objectClassFieldType5732_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_LITERAL_in_setType5745  */
static	ANTLR3_BITWORD FOLLOW_SET_LITERAL_in_setType5745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_LITERAL_in_setType5745	= { FOLLOW_SET_LITERAL_in_setType5745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_setType5748  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_setType5748_bits[]	= { ANTLR3_UINT64_LIT(0x0000020001001000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_setType5748	= { FOLLOW_L_BRACE_in_setType5748_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAndException_in_setType5752  */
static	ANTLR3_BITWORD FOLLOW_extensionAndException_in_setType5752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAndException_in_setType5752	= { FOLLOW_extensionAndException_in_setType5752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_optionalExtensionMarker_in_setType5755  */
static	ANTLR3_BITWORD FOLLOW_optionalExtensionMarker_in_setType5755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_optionalExtensionMarker_in_setType5755	= { FOLLOW_optionalExtensionMarker_in_setType5755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentTypeLists_in_setType5760  */
static	ANTLR3_BITWORD FOLLOW_componentTypeLists_in_setType5760_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_componentTypeLists_in_setType5760	= { FOLLOW_componentTypeLists_in_setType5760_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_setType5764  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_setType5764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_setType5764	= { FOLLOW_R_BRACE_in_setType5764_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SET_LITERAL_in_setOfType5779  */
static	ANTLR3_BITWORD FOLLOW_SET_LITERAL_in_setOfType5779_bits[]	= { ANTLR3_UINT64_LIT(0x1050240814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SET_LITERAL_in_setOfType5779	= { FOLLOW_SET_LITERAL_in_setOfType5779_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_setOfType5782  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_setOfType5782_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_setOfType5782	= { FOLLOW_constraint_in_setOfType5782_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sizeConstraint_in_setOfType5786  */
static	ANTLR3_BITWORD FOLLOW_sizeConstraint_in_setOfType5786_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sizeConstraint_in_setOfType5786	= { FOLLOW_sizeConstraint_in_setOfType5786_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OF_LITERAL_in_setOfType5790  */
static	ANTLR3_BITWORD FOLLOW_OF_LITERAL_in_setOfType5790_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_OF_LITERAL_in_setOfType5790	= { FOLLOW_OF_LITERAL_in_setOfType5790_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_setOfType5793  */
static	ANTLR3_BITWORD FOLLOW_type_in_setOfType5793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_setOfType5793	= { FOLLOW_type_in_setOfType5793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedType_in_setOfType5797  */
static	ANTLR3_BITWORD FOLLOW_namedType_in_setOfType5797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedType_in_setOfType5797	= { FOLLOW_namedType_in_setOfType5797_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedType_in_referencedType5811  */
static	ANTLR3_BITWORD FOLLOW_definedType_in_referencedType5811_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedType_in_referencedType5811	= { FOLLOW_definedType_in_referencedType5811_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_definedType5833  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_definedType5833_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800402) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_definedType5833	= { FOLLOW_IDENTIFIER_in_definedType5833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_definedType5836  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_definedType5836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_definedType5836	= { FOLLOW_DOT_in_definedType5836_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_definedType5838  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_definedType5838_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_definedType5838	= { FOLLOW_IDENTIFIER_in_definedType5838_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_actualParameterList_in_definedType5844  */
static	ANTLR3_BITWORD FOLLOW_actualParameterList_in_definedType5844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_actualParameterList_in_definedType5844	= { FOLLOW_actualParameterList_in_definedType5844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_constraint5867  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_constraint5867_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_constraint5867	= { FOLLOW_L_PARAN_in_constraint5867_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraintSpec_in_constraint5870  */
static	ANTLR3_BITWORD FOLLOW_constraintSpec_in_constraint5870_bits[]	= { ANTLR3_UINT64_LIT(0x0000100008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constraintSpec_in_constraint5870	= { FOLLOW_constraintSpec_in_constraint5870_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exceptionSpec_in_constraint5873  */
static	ANTLR3_BITWORD FOLLOW_exceptionSpec_in_constraint5873_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_exceptionSpec_in_constraint5873	= { FOLLOW_exceptionSpec_in_constraint5873_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_constraint5875  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_constraint5875_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_constraint5875	= { FOLLOW_R_PARAN_in_constraint5875_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraintSpec_in_constraint5884  */
static	ANTLR3_BITWORD FOLLOW_constraintSpec_in_constraint5884_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constraintSpec_in_constraint5884	= { FOLLOW_constraintSpec_in_constraint5884_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exceptionSpec_in_constraint5887  */
static	ANTLR3_BITWORD FOLLOW_exceptionSpec_in_constraint5887_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exceptionSpec_in_constraint5887	= { FOLLOW_exceptionSpec_in_constraint5887_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalConstraint_in_constraintSpec5897  */
static	ANTLR3_BITWORD FOLLOW_generalConstraint_in_constraintSpec5897_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalConstraint_in_constraintSpec5897	= { FOLLOW_generalConstraint_in_constraintSpec5897_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subtypeConstraint_in_constraintSpec5901  */
static	ANTLR3_BITWORD FOLLOW_subtypeConstraint_in_constraintSpec5901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subtypeConstraint_in_constraintSpec5901	= { FOLLOW_subtypeConstraint_in_constraintSpec5901_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONSTRAINED_LITERAL_in_userDefinedConstraint5911  */
static	ANTLR3_BITWORD FOLLOW_CONSTRAINED_LITERAL_in_userDefinedConstraint5911_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_CONSTRAINED_LITERAL_in_userDefinedConstraint5911	= { FOLLOW_CONSTRAINED_LITERAL_in_userDefinedConstraint5911_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BY_LITERAL_in_userDefinedConstraint5913  */
static	ANTLR3_BITWORD FOLLOW_BY_LITERAL_in_userDefinedConstraint5913_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_BY_LITERAL_in_userDefinedConstraint5913	= { FOLLOW_BY_LITERAL_in_userDefinedConstraint5913_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_userDefinedConstraint5915  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_userDefinedConstraint5915_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_userDefinedConstraint5915	= { FOLLOW_L_BRACE_in_userDefinedConstraint5915_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userDefinedConstraintParameter_in_userDefinedConstraint5917  */
static	ANTLR3_BITWORD FOLLOW_userDefinedConstraintParameter_in_userDefinedConstraint5917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_userDefinedConstraintParameter_in_userDefinedConstraint5917	= { FOLLOW_userDefinedConstraintParameter_in_userDefinedConstraint5917_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_userDefinedConstraint5920  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_userDefinedConstraint5920_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_userDefinedConstraint5920	= { FOLLOW_COMMA_in_userDefinedConstraint5920_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userDefinedConstraintParameter_in_userDefinedConstraint5922  */
static	ANTLR3_BITWORD FOLLOW_userDefinedConstraintParameter_in_userDefinedConstraint5922_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_userDefinedConstraintParameter_in_userDefinedConstraint5922	= { FOLLOW_userDefinedConstraintParameter_in_userDefinedConstraint5922_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_userDefinedConstraint5926  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_userDefinedConstraint5926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_userDefinedConstraint5926	= { FOLLOW_R_BRACE_in_userDefinedConstraint5926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userDefinedConstraint_in_generalConstraint5937  */
static	ANTLR3_BITWORD FOLLOW_userDefinedConstraint_in_generalConstraint5937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_userDefinedConstraint_in_generalConstraint5937	= { FOLLOW_userDefinedConstraint_in_generalConstraint5937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tableConstraint_in_generalConstraint5941  */
static	ANTLR3_BITWORD FOLLOW_tableConstraint_in_generalConstraint5941_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tableConstraint_in_generalConstraint5941	= { FOLLOW_tableConstraint_in_generalConstraint5941_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contentsConstraint_in_generalConstraint5945  */
static	ANTLR3_BITWORD FOLLOW_contentsConstraint_in_generalConstraint5945_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_contentsConstraint_in_generalConstraint5945	= { FOLLOW_contentsConstraint_in_generalConstraint5945_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_governor_in_userDefinedConstraintParameter5956  */
static	ANTLR3_BITWORD FOLLOW_governor_in_userDefinedConstraintParameter5956_bits[]	= { ANTLR3_UINT64_LIT(0xE000087230F80382), ANTLR3_UINT64_LIT(0x00B0000004180004) };
static  ANTLR3_BITSET_LIST FOLLOW_governor_in_userDefinedConstraintParameter5956	= { FOLLOW_governor_in_userDefinedConstraintParameter5956_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_userDefinedConstraintParameter5959  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_userDefinedConstraintParameter5959_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_userDefinedConstraintParameter5959	= { FOLLOW_COLON_in_userDefinedConstraintParameter5959_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_userDefinedConstraintParameter5965  */
static	ANTLR3_BITWORD FOLLOW_value_in_userDefinedConstraintParameter5965_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_userDefinedConstraintParameter5965	= { FOLLOW_value_in_userDefinedConstraintParameter5965_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSet_in_userDefinedConstraintParameter5973  */
static	ANTLR3_BITWORD FOLLOW_valueSet_in_userDefinedConstraintParameter5973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSet_in_userDefinedConstraintParameter5973	= { FOLLOW_valueSet_in_userDefinedConstraintParameter5973_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_in_userDefinedConstraintParameter5980  */
static	ANTLR3_BITWORD FOLLOW_object_in_userDefinedConstraintParameter5980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_in_userDefinedConstraintParameter5980	= { FOLLOW_object_in_userDefinedConstraintParameter5980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectSet_in_userDefinedConstraintParameter5987  */
static	ANTLR3_BITWORD FOLLOW_objectSet_in_userDefinedConstraintParameter5987_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectSet_in_userDefinedConstraintParameter5987	= { FOLLOW_objectSet_in_userDefinedConstraintParameter5987_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentRelationConstraint_in_tableConstraint6004  */
static	ANTLR3_BITWORD FOLLOW_componentRelationConstraint_in_tableConstraint6004_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_componentRelationConstraint_in_tableConstraint6004	= { FOLLOW_componentRelationConstraint_in_tableConstraint6004_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectSet_in_simpleTableConstraint6013  */
static	ANTLR3_BITWORD FOLLOW_objectSet_in_simpleTableConstraint6013_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectSet_in_simpleTableConstraint6013	= { FOLLOW_objectSet_in_simpleTableConstraint6013_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONTAINING_LITERAL_in_contentsConstraint6028  */
static	ANTLR3_BITWORD FOLLOW_CONTAINING_LITERAL_in_contentsConstraint6028_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONTAINING_LITERAL_in_contentsConstraint6028	= { FOLLOW_CONTAINING_LITERAL_in_contentsConstraint6028_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_contentsConstraint6030  */
static	ANTLR3_BITWORD FOLLOW_type_in_contentsConstraint6030_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_contentsConstraint6030	= { FOLLOW_type_in_contentsConstraint6030_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENCODED_LITERAL_in_contentsConstraint6037  */
static	ANTLR3_BITWORD FOLLOW_ENCODED_LITERAL_in_contentsConstraint6037_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ENCODED_LITERAL_in_contentsConstraint6037	= { FOLLOW_ENCODED_LITERAL_in_contentsConstraint6037_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BY_LITERAL_in_contentsConstraint6039  */
static	ANTLR3_BITWORD FOLLOW_BY_LITERAL_in_contentsConstraint6039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BY_LITERAL_in_contentsConstraint6039	= { FOLLOW_BY_LITERAL_in_contentsConstraint6039_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_contentsConstraint6041  */
static	ANTLR3_BITWORD FOLLOW_value_in_contentsConstraint6041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_contentsConstraint6041	= { FOLLOW_value_in_contentsConstraint6041_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONTAINING_LITERAL_in_contentsConstraint6048  */
static	ANTLR3_BITWORD FOLLOW_CONTAINING_LITERAL_in_contentsConstraint6048_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONTAINING_LITERAL_in_contentsConstraint6048	= { FOLLOW_CONTAINING_LITERAL_in_contentsConstraint6048_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_contentsConstraint6050  */
static	ANTLR3_BITWORD FOLLOW_type_in_contentsConstraint6050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_contentsConstraint6050	= { FOLLOW_type_in_contentsConstraint6050_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENCODED_LITERAL_in_contentsConstraint6052  */
static	ANTLR3_BITWORD FOLLOW_ENCODED_LITERAL_in_contentsConstraint6052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ENCODED_LITERAL_in_contentsConstraint6052	= { FOLLOW_ENCODED_LITERAL_in_contentsConstraint6052_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BY_LITERAL_in_contentsConstraint6054  */
static	ANTLR3_BITWORD FOLLOW_BY_LITERAL_in_contentsConstraint6054_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BY_LITERAL_in_contentsConstraint6054	= { FOLLOW_BY_LITERAL_in_contentsConstraint6054_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_contentsConstraint6056  */
static	ANTLR3_BITWORD FOLLOW_value_in_contentsConstraint6056_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_contentsConstraint6056	= { FOLLOW_value_in_contentsConstraint6056_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_elementSetSpecs_in_subtypeConstraint6068  */
static	ANTLR3_BITWORD FOLLOW_elementSetSpecs_in_subtypeConstraint6068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_elementSetSpecs_in_subtypeConstraint6068	= { FOLLOW_elementSetSpecs_in_subtypeConstraint6068_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtinValue_in_value6085  */
static	ANTLR3_BITWORD FOLLOW_builtinValue_in_value6085_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_builtinValue_in_value6085	= { FOLLOW_builtinValue_in_value6085_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumeratedValue_in_builtinValue6107  */
static	ANTLR3_BITWORD FOLLOW_enumeratedValue_in_builtinValue6107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumeratedValue_in_builtinValue6107	= { FOLLOW_enumeratedValue_in_builtinValue6107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integerValue_in_builtinValue6112  */
static	ANTLR3_BITWORD FOLLOW_integerValue_in_builtinValue6112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integerValue_in_builtinValue6112	= { FOLLOW_integerValue_in_builtinValue6112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_choiceValue_in_builtinValue6117  */
static	ANTLR3_BITWORD FOLLOW_choiceValue_in_builtinValue6117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_choiceValue_in_builtinValue6117	= { FOLLOW_choiceValue_in_builtinValue6117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectIdentifierValue_in_builtinValue6122  */
static	ANTLR3_BITWORD FOLLOW_objectIdentifierValue_in_builtinValue6122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectIdentifierValue_in_builtinValue6122	= { FOLLOW_objectIdentifierValue_in_builtinValue6122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_booleanValue_in_builtinValue6127  */
static	ANTLR3_BITWORD FOLLOW_booleanValue_in_builtinValue6127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_booleanValue_in_builtinValue6127	= { FOLLOW_booleanValue_in_builtinValue6127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitValue_in_builtinValue6132  */
static	ANTLR3_BITWORD FOLLOW_bitValue_in_builtinValue6132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitValue_in_builtinValue6132	= { FOLLOW_bitValue_in_builtinValue6132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_objectIdentifierValue6145  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_objectIdentifierValue6145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_objectIdentifierValue6145	= { FOLLOW_L_BRACE_in_objectIdentifierValue6145_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objIdComponentsList_in_objectIdentifierValue6150  */
static	ANTLR3_BITWORD FOLLOW_objIdComponentsList_in_objectIdentifierValue6150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_objIdComponentsList_in_objectIdentifierValue6150	= { FOLLOW_objIdComponentsList_in_objectIdentifierValue6150_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_objectIdentifierValue6152  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_objectIdentifierValue6152_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_objectIdentifierValue6152	= { FOLLOW_R_BRACE_in_objectIdentifierValue6152_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objIdComponents_in_objIdComponentsList6167  */
static	ANTLR3_BITWORD FOLLOW_objIdComponents_in_objIdComponentsList6167_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_objIdComponents_in_objIdComponentsList6167	= { FOLLOW_objIdComponents_in_objIdComponentsList6167_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objIdComponents_in_objIdComponentsList6171  */
static	ANTLR3_BITWORD FOLLOW_objIdComponents_in_objIdComponentsList6171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_objIdComponents_in_objIdComponentsList6171	= { FOLLOW_objIdComponents_in_objIdComponentsList6171_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_objIdComponents6189  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_objIdComponents6189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_objIdComponents6189	= { FOLLOW_NUMBER_in_objIdComponents6189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_objIdComponents6198  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_objIdComponents6198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_objIdComponents6198	= { FOLLOW_IDENTIFIER_in_objIdComponents6198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_objIdComponents6201  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_objIdComponents6201_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_objIdComponents6201	= { FOLLOW_L_PARAN_in_objIdComponents6201_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_objIdComponents6204  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_objIdComponents6204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_objIdComponents6204	= { FOLLOW_NUMBER_in_objIdComponents6204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedValue_in_objIdComponents6208  */
static	ANTLR3_BITWORD FOLLOW_definedValue_in_objIdComponents6208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_definedValue_in_objIdComponents6208	= { FOLLOW_definedValue_in_objIdComponents6208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_objIdComponents6212  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_objIdComponents6212_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_objIdComponents6212	= { FOLLOW_R_PARAN_in_objIdComponents6212_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedValue_in_objIdComponents6223  */
static	ANTLR3_BITWORD FOLLOW_definedValue_in_objIdComponents6223_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedValue_in_objIdComponents6223	= { FOLLOW_definedValue_in_objIdComponents6223_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signedNumber_in_integerValue6237  */
static	ANTLR3_BITWORD FOLLOW_signedNumber_in_integerValue6237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signedNumber_in_integerValue6237	= { FOLLOW_signedNumber_in_integerValue6237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_integerValue6241  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_integerValue6241_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_integerValue6241	= { FOLLOW_IDENTIFIER_in_integerValue6241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_choiceValue6261  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_choiceValue6261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_choiceValue6261	= { FOLLOW_IDENTIFIER_in_choiceValue6261_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_choiceValue6263  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_choiceValue6263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_choiceValue6263	= { FOLLOW_COLON_in_choiceValue6263_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_choiceValue6265  */
static	ANTLR3_BITWORD FOLLOW_value_in_choiceValue6265_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_choiceValue6265	= { FOLLOW_value_in_choiceValue6265_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enumeratedValue6275  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enumeratedValue6275_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enumeratedValue6275	= { FOLLOW_IDENTIFIER_in_enumeratedValue6275_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_in_signedNumber6287  */
static	ANTLR3_BITWORD FOLLOW_MINUS_in_signedNumber6287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_in_signedNumber6287	= { FOLLOW_MINUS_in_signedNumber6287_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_signedNumber6291  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_signedNumber6291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_signedNumber6291	= { FOLLOW_NUMBER_in_signedNumber6291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHOICE_LITERAL_in_choiceType6302  */
static	ANTLR3_BITWORD FOLLOW_CHOICE_LITERAL_in_choiceType6302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_CHOICE_LITERAL_in_choiceType6302	= { FOLLOW_CHOICE_LITERAL_in_choiceType6302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_choiceType6304  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_choiceType6304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_choiceType6304	= { FOLLOW_L_BRACE_in_choiceType6304_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alternativeTypeLists_in_choiceType6306  */
static	ANTLR3_BITWORD FOLLOW_alternativeTypeLists_in_choiceType6306_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_alternativeTypeLists_in_choiceType6306	= { FOLLOW_alternativeTypeLists_in_choiceType6306_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_choiceType6308  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_choiceType6308_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_choiceType6308	= { FOLLOW_R_BRACE_in_choiceType6308_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rootAlternativeTypeList_in_alternativeTypeLists6326  */
static	ANTLR3_BITWORD FOLLOW_rootAlternativeTypeList_in_alternativeTypeLists6326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rootAlternativeTypeList_in_alternativeTypeLists6326	= { FOLLOW_rootAlternativeTypeList_in_alternativeTypeLists6326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_alternativeTypeLists6329  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_alternativeTypeLists6329_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_alternativeTypeLists6329	= { FOLLOW_COMMA_in_alternativeTypeLists6329_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAndException_in_alternativeTypeLists6336  */
static	ANTLR3_BITWORD FOLLOW_extensionAndException_in_alternativeTypeLists6336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAndException_in_alternativeTypeLists6336	= { FOLLOW_extensionAndException_in_alternativeTypeLists6336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAdditionAlternatives_in_alternativeTypeLists6339  */
static	ANTLR3_BITWORD FOLLOW_extensionAdditionAlternatives_in_alternativeTypeLists6339_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAdditionAlternatives_in_alternativeTypeLists6339	= { FOLLOW_extensionAdditionAlternatives_in_alternativeTypeLists6339_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_optionalExtensionMarker_in_alternativeTypeLists6342  */
static	ANTLR3_BITWORD FOLLOW_optionalExtensionMarker_in_alternativeTypeLists6342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_optionalExtensionMarker_in_alternativeTypeLists6342	= { FOLLOW_optionalExtensionMarker_in_alternativeTypeLists6342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_extensionAdditionAlternatives6357  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_extensionAdditionAlternatives6357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_extensionAdditionAlternatives6357	= { FOLLOW_COMMA_in_extensionAdditionAlternatives6357_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAdditionAlternativesList_in_extensionAdditionAlternatives6361  */
static	ANTLR3_BITWORD FOLLOW_extensionAdditionAlternativesList_in_extensionAdditionAlternatives6361_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAdditionAlternativesList_in_extensionAdditionAlternatives6361	= { FOLLOW_extensionAdditionAlternativesList_in_extensionAdditionAlternatives6361_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAdditionAlternative_in_extensionAdditionAlternativesList6375  */
static	ANTLR3_BITWORD FOLLOW_extensionAdditionAlternative_in_extensionAdditionAlternativesList6375_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAdditionAlternative_in_extensionAdditionAlternativesList6375	= { FOLLOW_extensionAdditionAlternative_in_extensionAdditionAlternativesList6375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_extensionAdditionAlternativesList6379  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_extensionAdditionAlternativesList6379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_extensionAdditionAlternativesList6379	= { FOLLOW_COMMA_in_extensionAdditionAlternativesList6379_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAdditionAlternative_in_extensionAdditionAlternativesList6382  */
static	ANTLR3_BITWORD FOLLOW_extensionAdditionAlternative_in_extensionAdditionAlternativesList6382_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAdditionAlternative_in_extensionAdditionAlternativesList6382	= { FOLLOW_extensionAdditionAlternative_in_extensionAdditionAlternativesList6382_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAdditionAlternativesGroup_in_extensionAdditionAlternative6395  */
static	ANTLR3_BITWORD FOLLOW_extensionAdditionAlternativesGroup_in_extensionAdditionAlternative6395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAdditionAlternativesGroup_in_extensionAdditionAlternative6395	= { FOLLOW_extensionAdditionAlternativesGroup_in_extensionAdditionAlternative6395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedType_in_extensionAdditionAlternative6399  */
static	ANTLR3_BITWORD FOLLOW_namedType_in_extensionAdditionAlternative6399_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedType_in_extensionAdditionAlternative6399	= { FOLLOW_namedType_in_extensionAdditionAlternative6399_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOUBLE_L_BRACKET_in_extensionAdditionAlternativesGroup6410  */
static	ANTLR3_BITWORD FOLLOW_DOUBLE_L_BRACKET_in_extensionAdditionAlternativesGroup6410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOUBLE_L_BRACKET_in_extensionAdditionAlternativesGroup6410	= { FOLLOW_DOUBLE_L_BRACKET_in_extensionAdditionAlternativesGroup6410_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_versionNumber_in_extensionAdditionAlternativesGroup6413  */
static	ANTLR3_BITWORD FOLLOW_versionNumber_in_extensionAdditionAlternativesGroup6413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_versionNumber_in_extensionAdditionAlternativesGroup6413	= { FOLLOW_versionNumber_in_extensionAdditionAlternativesGroup6413_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alternativeTypeList_in_extensionAdditionAlternativesGroup6416  */
static	ANTLR3_BITWORD FOLLOW_alternativeTypeList_in_extensionAdditionAlternativesGroup6416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_alternativeTypeList_in_extensionAdditionAlternativesGroup6416	= { FOLLOW_alternativeTypeList_in_extensionAdditionAlternativesGroup6416_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOUBLE_R_BRACKET_in_extensionAdditionAlternativesGroup6419  */
static	ANTLR3_BITWORD FOLLOW_DOUBLE_R_BRACKET_in_extensionAdditionAlternativesGroup6419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOUBLE_R_BRACKET_in_extensionAdditionAlternativesGroup6419	= { FOLLOW_DOUBLE_R_BRACKET_in_extensionAdditionAlternativesGroup6419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alternativeTypeList_in_rootAlternativeTypeList6430  */
static	ANTLR3_BITWORD FOLLOW_alternativeTypeList_in_rootAlternativeTypeList6430_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alternativeTypeList_in_rootAlternativeTypeList6430	= { FOLLOW_alternativeTypeList_in_rootAlternativeTypeList6430_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedType_in_alternativeTypeList6439  */
static	ANTLR3_BITWORD FOLLOW_namedType_in_alternativeTypeList6439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedType_in_alternativeTypeList6439	= { FOLLOW_namedType_in_alternativeTypeList6439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_alternativeTypeList6443  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_alternativeTypeList6443_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_alternativeTypeList6443	= { FOLLOW_COMMA_in_alternativeTypeList6443_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedType_in_alternativeTypeList6446  */
static	ANTLR3_BITWORD FOLLOW_namedType_in_alternativeTypeList6446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedType_in_alternativeTypeList6446	= { FOLLOW_namedType_in_alternativeTypeList6446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_namedType6459  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_namedType6459_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_namedType6459	= { FOLLOW_IDENTIFIER_in_namedType6459_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_namedType6465  */
static	ANTLR3_BITWORD FOLLOW_type_in_namedType6465_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_namedType6465	= { FOLLOW_type_in_namedType6465_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENUMERATED_LITERAL_in_enumeratedType6489  */
static	ANTLR3_BITWORD FOLLOW_ENUMERATED_LITERAL_in_enumeratedType6489_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_ENUMERATED_LITERAL_in_enumeratedType6489	= { FOLLOW_ENUMERATED_LITERAL_in_enumeratedType6489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_enumeratedType6491  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_enumeratedType6491_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_enumeratedType6491	= { FOLLOW_L_BRACE_in_enumeratedType6491_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumerations_in_enumeratedType6495  */
static	ANTLR3_BITWORD FOLLOW_enumerations_in_enumeratedType6495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_enumerations_in_enumeratedType6495	= { FOLLOW_enumerations_in_enumeratedType6495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_enumeratedType6497  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_enumeratedType6497_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_enumeratedType6497	= { FOLLOW_R_BRACE_in_enumeratedType6497_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rootEnumeration_in_enumerations6513  */
static	ANTLR3_BITWORD FOLLOW_rootEnumeration_in_enumerations6513_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rootEnumeration_in_enumerations6513	= { FOLLOW_rootEnumeration_in_enumerations6513_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_enumerations6516  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_enumerations6516_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_enumerations6516	= { FOLLOW_COMMA_in_enumerations6516_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ELLIPSIS_in_enumerations6521  */
static	ANTLR3_BITWORD FOLLOW_ELLIPSIS_in_enumerations6521_bits[]	= { ANTLR3_UINT64_LIT(0x0000100002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ELLIPSIS_in_enumerations6521	= { FOLLOW_ELLIPSIS_in_enumerations6521_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exceptionSpec_in_enumerations6524  */
static	ANTLR3_BITWORD FOLLOW_exceptionSpec_in_enumerations6524_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exceptionSpec_in_enumerations6524	= { FOLLOW_exceptionSpec_in_enumerations6524_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_enumerations6527  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_enumerations6527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_enumerations6527	= { FOLLOW_COMMA_in_enumerations6527_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_additionalEnumeration_in_enumerations6532  */
static	ANTLR3_BITWORD FOLLOW_additionalEnumeration_in_enumerations6532_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_additionalEnumeration_in_enumerations6532	= { FOLLOW_additionalEnumeration_in_enumerations6532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumeration_in_rootEnumeration6546  */
static	ANTLR3_BITWORD FOLLOW_enumeration_in_rootEnumeration6546_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumeration_in_rootEnumeration6546	= { FOLLOW_enumeration_in_rootEnumeration6546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumerationItem_in_enumeration6554  */
static	ANTLR3_BITWORD FOLLOW_enumerationItem_in_enumeration6554_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumerationItem_in_enumeration6554	= { FOLLOW_enumerationItem_in_enumeration6554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_enumeration6558  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_enumeration6558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_enumeration6558	= { FOLLOW_COMMA_in_enumeration6558_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumerationItem_in_enumeration6561  */
static	ANTLR3_BITWORD FOLLOW_enumerationItem_in_enumeration6561_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumerationItem_in_enumeration6561	= { FOLLOW_enumerationItem_in_enumeration6561_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enumerationItem6571  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enumerationItem6571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enumerationItem6571	= { FOLLOW_IDENTIFIER_in_enumerationItem6571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedNumber_in_enumerationItem6575  */
static	ANTLR3_BITWORD FOLLOW_namedNumber_in_enumerationItem6575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedNumber_in_enumerationItem6575	= { FOLLOW_namedNumber_in_enumerationItem6575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_enumerationItem6579  */
static	ANTLR3_BITWORD FOLLOW_value_in_enumerationItem6579_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_enumerationItem6579	= { FOLLOW_value_in_enumerationItem6579_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_namedNumber6589  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_namedNumber6589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_namedNumber6589	= { FOLLOW_IDENTIFIER_in_namedNumber6589_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_namedNumber6591  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_namedNumber6591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_namedNumber6591	= { FOLLOW_L_PARAN_in_namedNumber6591_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signedNumber_in_namedNumber6596  */
static	ANTLR3_BITWORD FOLLOW_signedNumber_in_namedNumber6596_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_signedNumber_in_namedNumber6596	= { FOLLOW_signedNumber_in_namedNumber6596_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedValue_in_namedNumber6602  */
static	ANTLR3_BITWORD FOLLOW_definedValue_in_namedNumber6602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_definedValue_in_namedNumber6602	= { FOLLOW_definedValue_in_namedNumber6602_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_namedNumber6605  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_namedNumber6605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_namedNumber6605	= { FOLLOW_R_PARAN_in_namedNumber6605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameterizedValue_in_definedValue6634  */
static	ANTLR3_BITWORD FOLLOW_parameterizedValue_in_definedValue6634_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_parameterizedValue_in_definedValue6634	= { FOLLOW_parameterizedValue_in_definedValue6634_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleDefinedValue_in_parameterizedValue6643  */
static	ANTLR3_BITWORD FOLLOW_simpleDefinedValue_in_parameterizedValue6643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_simpleDefinedValue_in_parameterizedValue6643	= { FOLLOW_simpleDefinedValue_in_parameterizedValue6643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_actualParameterList_in_parameterizedValue6646  */
static	ANTLR3_BITWORD FOLLOW_actualParameterList_in_parameterizedValue6646_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_actualParameterList_in_parameterizedValue6646	= { FOLLOW_actualParameterList_in_parameterizedValue6646_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simpleDefinedValue6656  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simpleDefinedValue6656_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simpleDefinedValue6656	= { FOLLOW_IDENTIFIER_in_simpleDefinedValue6656_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_simpleDefinedValue6659  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_simpleDefinedValue6659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_simpleDefinedValue6659	= { FOLLOW_DOT_in_simpleDefinedValue6659_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_simpleDefinedValue6661  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_simpleDefinedValue6661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_simpleDefinedValue6661	= { FOLLOW_IDENTIFIER_in_simpleDefinedValue6661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_actualParameterList6672  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_actualParameterList6672_bits[]	= { ANTLR3_UINT64_LIT(0x6000087230F80380), ANTLR3_UINT64_LIT(0x00B0000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_actualParameterList6672	= { FOLLOW_L_BRACE_in_actualParameterList6672_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_actualParameter_in_actualParameterList6676  */
static	ANTLR3_BITWORD FOLLOW_actualParameter_in_actualParameterList6676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_actualParameter_in_actualParameterList6676	= { FOLLOW_actualParameter_in_actualParameterList6676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_actualParameterList6679  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_actualParameterList6679_bits[]	= { ANTLR3_UINT64_LIT(0x6000087230F80380), ANTLR3_UINT64_LIT(0x00B0000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_actualParameterList6679	= { FOLLOW_COMMA_in_actualParameterList6679_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_actualParameter_in_actualParameterList6683  */
static	ANTLR3_BITWORD FOLLOW_actualParameter_in_actualParameterList6683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_actualParameter_in_actualParameterList6683	= { FOLLOW_actualParameter_in_actualParameterList6683_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_actualParameterList6687  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_actualParameterList6687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_actualParameterList6687	= { FOLLOW_R_BRACE_in_actualParameterList6687_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_actualParameter6708  */
static	ANTLR3_BITWORD FOLLOW_type_in_actualParameter6708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_actualParameter6708	= { FOLLOW_type_in_actualParameter6708_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_actualParameter6714  */
static	ANTLR3_BITWORD FOLLOW_value_in_actualParameter6714_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_actualParameter6714	= { FOLLOW_value_in_actualParameter6714_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXCLAM_in_exceptionSpec6739  */
static	ANTLR3_BITWORD FOLLOW_EXCLAM_in_exceptionSpec6739_bits[]	= { ANTLR3_UINT64_LIT(0x6000087230600080), ANTLR3_UINT64_LIT(0x0030000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_EXCLAM_in_exceptionSpec6739	= { FOLLOW_EXCLAM_in_exceptionSpec6739_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exceptionIdentification_in_exceptionSpec6742  */
static	ANTLR3_BITWORD FOLLOW_exceptionIdentification_in_exceptionSpec6742_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exceptionIdentification_in_exceptionSpec6742	= { FOLLOW_exceptionIdentification_in_exceptionSpec6742_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signedNumber_in_exceptionIdentification6753  */
static	ANTLR3_BITWORD FOLLOW_signedNumber_in_exceptionIdentification6753_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signedNumber_in_exceptionIdentification6753	= { FOLLOW_signedNumber_in_exceptionIdentification6753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedValue_in_exceptionIdentification6763  */
static	ANTLR3_BITWORD FOLLOW_definedValue_in_exceptionIdentification6763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedValue_in_exceptionIdentification6763	= { FOLLOW_definedValue_in_exceptionIdentification6763_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_exceptionIdentification6773  */
static	ANTLR3_BITWORD FOLLOW_type_in_exceptionIdentification6773_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_exceptionIdentification6773	= { FOLLOW_type_in_exceptionIdentification6773_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_exceptionIdentification6775  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_exceptionIdentification6775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_exceptionIdentification6775	= { FOLLOW_COLON_in_exceptionIdentification6775_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_exceptionIdentification6777  */
static	ANTLR3_BITWORD FOLLOW_value_in_exceptionIdentification6777_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_exceptionIdentification6777	= { FOLLOW_value_in_exceptionIdentification6777_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumeration_in_additionalEnumeration6786  */
static	ANTLR3_BITWORD FOLLOW_enumeration_in_additionalEnumeration6786_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumeration_in_additionalEnumeration6786	= { FOLLOW_enumeration_in_additionalEnumeration6786_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_LITERAL_in_integerType6794  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_LITERAL_in_integerType6794_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004800002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_LITERAL_in_integerType6794	= { FOLLOW_INTEGER_LITERAL_in_integerType6794_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_integerType6798  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_integerType6798_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_integerType6798	= { FOLLOW_L_BRACE_in_integerType6798_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedNumberList_in_integerType6802  */
static	ANTLR3_BITWORD FOLLOW_namedNumberList_in_integerType6802_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_namedNumberList_in_integerType6802	= { FOLLOW_namedNumberList_in_integerType6802_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_integerType6804  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_integerType6804_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_integerType6804	= { FOLLOW_R_BRACE_in_integerType6804_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_integerType6809  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_integerType6809_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_integerType6809	= { FOLLOW_L_PARAN_in_integerType6809_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIZE_LITERAL_in_integerType6811  */
static	ANTLR3_BITWORD FOLLOW_SIZE_LITERAL_in_integerType6811_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SIZE_LITERAL_in_integerType6811	= { FOLLOW_SIZE_LITERAL_in_integerType6811_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_integerType6817  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_integerType6817_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_integerType6817	= { FOLLOW_constraint_in_integerType6817_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sizeConstraint_in_integerType6823  */
static	ANTLR3_BITWORD FOLLOW_sizeConstraint_in_integerType6823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sizeConstraint_in_integerType6823	= { FOLLOW_sizeConstraint_in_integerType6823_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_integerType6826  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_integerType6826_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_integerType6826	= { FOLLOW_R_PARAN_in_integerType6826_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedNumber_in_namedNumberList6868  */
static	ANTLR3_BITWORD FOLLOW_namedNumber_in_namedNumberList6868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedNumber_in_namedNumberList6868	= { FOLLOW_namedNumber_in_namedNumberList6868_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_namedNumberList6872  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_namedNumberList6872_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_namedNumberList6872	= { FOLLOW_COMMA_in_namedNumberList6872_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedNumber_in_namedNumberList6876  */
static	ANTLR3_BITWORD FOLLOW_namedNumber_in_namedNumberList6876_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedNumber_in_namedNumberList6876	= { FOLLOW_namedNumber_in_namedNumberList6876_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OBJECT_LITERAL_in_objectidentifiertype6901  */
static	ANTLR3_BITWORD FOLLOW_OBJECT_LITERAL_in_objectidentifiertype6901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OBJECT_LITERAL_in_objectidentifiertype6901	= { FOLLOW_OBJECT_LITERAL_in_objectidentifiertype6901_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_LITERAL_in_objectidentifiertype6903  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_LITERAL_in_objectidentifiertype6903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_LITERAL_in_objectidentifiertype6903	= { FOLLOW_IDENTIFIER_LITERAL_in_objectidentifiertype6903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_componentRelationConstraint6919  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_componentRelationConstraint6919_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_componentRelationConstraint6919	= { FOLLOW_L_BRACE_in_componentRelationConstraint6919_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_componentRelationConstraint6922  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_componentRelationConstraint6922_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000400) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_componentRelationConstraint6922	= { FOLLOW_IDENTIFIER_in_componentRelationConstraint6922_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_componentRelationConstraint6925  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_componentRelationConstraint6925_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_componentRelationConstraint6925	= { FOLLOW_DOT_in_componentRelationConstraint6925_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_componentRelationConstraint6927  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_componentRelationConstraint6927_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_componentRelationConstraint6927	= { FOLLOW_IDENTIFIER_in_componentRelationConstraint6927_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_componentRelationConstraint6932  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_componentRelationConstraint6932_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_componentRelationConstraint6932	= { FOLLOW_R_BRACE_in_componentRelationConstraint6932_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_componentRelationConstraint6945  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_componentRelationConstraint6945_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_componentRelationConstraint6945	= { FOLLOW_L_BRACE_in_componentRelationConstraint6945_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atNotation_in_componentRelationConstraint6947  */
static	ANTLR3_BITWORD FOLLOW_atNotation_in_componentRelationConstraint6947_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_atNotation_in_componentRelationConstraint6947	= { FOLLOW_atNotation_in_componentRelationConstraint6947_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_componentRelationConstraint6950  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_componentRelationConstraint6950_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_componentRelationConstraint6950	= { FOLLOW_COMMA_in_componentRelationConstraint6950_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atNotation_in_componentRelationConstraint6952  */
static	ANTLR3_BITWORD FOLLOW_atNotation_in_componentRelationConstraint6952_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003000000) };
static  ANTLR3_BITSET_LIST FOLLOW_atNotation_in_componentRelationConstraint6952	= { FOLLOW_atNotation_in_componentRelationConstraint6952_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_componentRelationConstraint6956  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_componentRelationConstraint6956_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_componentRelationConstraint6956	= { FOLLOW_R_BRACE_in_componentRelationConstraint6956_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_A_ROND_in_atNotation6968  */
static	ANTLR3_BITWORD FOLLOW_A_ROND_in_atNotation6968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_A_ROND_in_atNotation6968	= { FOLLOW_A_ROND_in_atNotation6968_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_A_ROND_DOT_in_atNotation6973  */
static	ANTLR3_BITWORD FOLLOW_A_ROND_DOT_in_atNotation6973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_A_ROND_DOT_in_atNotation6973	= { FOLLOW_A_ROND_DOT_in_atNotation6973_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_level_in_atNotation6975  */
static	ANTLR3_BITWORD FOLLOW_level_in_atNotation6975_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_level_in_atNotation6975	= { FOLLOW_level_in_atNotation6975_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentIdList_in_atNotation6979  */
static	ANTLR3_BITWORD FOLLOW_componentIdList_in_atNotation6979_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_componentIdList_in_atNotation6979	= { FOLLOW_componentIdList_in_atNotation6979_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_level6989  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_level6989_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_level6989	= { FOLLOW_DOT_in_level6989_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_level_in_level6991  */
static	ANTLR3_BITWORD FOLLOW_level_in_level6991_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_level_in_level6991	= { FOLLOW_level_in_level6991_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_componentIdList7003  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_componentIdList7003_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_componentIdList7003	= { FOLLOW_IDENTIFIER_in_componentIdList7003_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_componentIdList7006  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_componentIdList7006_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_componentIdList7006	= { FOLLOW_DOT_in_componentIdList7006_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_componentIdList7008  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_componentIdList7008_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_componentIdList7008	= { FOLLOW_IDENTIFIER_in_componentIdList7008_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OCTET_LITERAL_in_octetStringType7022  */
static	ANTLR3_BITWORD FOLLOW_OCTET_LITERAL_in_octetStringType7022_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OCTET_LITERAL_in_octetStringType7022	= { FOLLOW_OCTET_LITERAL_in_octetStringType7022_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_octetStringType7024  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_octetStringType7024_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_octetStringType7024	= { FOLLOW_STRING_LITERAL_in_octetStringType7024_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_octetStringType7027  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_octetStringType7027_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_octetStringType7027	= { FOLLOW_L_PARAN_in_octetStringType7027_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIZE_LITERAL_in_octetStringType7031  */
static	ANTLR3_BITWORD FOLLOW_SIZE_LITERAL_in_octetStringType7031_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SIZE_LITERAL_in_octetStringType7031	= { FOLLOW_SIZE_LITERAL_in_octetStringType7031_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_octetStringType7037  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_octetStringType7037_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_octetStringType7037	= { FOLLOW_constraint_in_octetStringType7037_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sizeConstraint_in_octetStringType7043  */
static	ANTLR3_BITWORD FOLLOW_sizeConstraint_in_octetStringType7043_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sizeConstraint_in_octetStringType7043	= { FOLLOW_sizeConstraint_in_octetStringType7043_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_octetStringType7046  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_octetStringType7046_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_octetStringType7046	= { FOLLOW_R_PARAN_in_octetStringType7046_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IA5_STRING_LITERAL_in_ia5stringType7085  */
static	ANTLR3_BITWORD FOLLOW_IA5_STRING_LITERAL_in_ia5stringType7085_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IA5_STRING_LITERAL_in_ia5stringType7085	= { FOLLOW_IA5_STRING_LITERAL_in_ia5stringType7085_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_ia5stringType7088  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_ia5stringType7088_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_ia5stringType7088	= { FOLLOW_L_PARAN_in_ia5stringType7088_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIZE_LITERAL_in_ia5stringType7092  */
static	ANTLR3_BITWORD FOLLOW_SIZE_LITERAL_in_ia5stringType7092_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SIZE_LITERAL_in_ia5stringType7092	= { FOLLOW_SIZE_LITERAL_in_ia5stringType7092_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_ia5stringType7098  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_ia5stringType7098_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_ia5stringType7098	= { FOLLOW_constraint_in_ia5stringType7098_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sizeConstraint_in_ia5stringType7104  */
static	ANTLR3_BITWORD FOLLOW_sizeConstraint_in_ia5stringType7104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sizeConstraint_in_ia5stringType7104	= { FOLLOW_sizeConstraint_in_ia5stringType7104_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_ia5stringType7107  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_ia5stringType7107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_ia5stringType7107	= { FOLLOW_R_PARAN_in_ia5stringType7107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NULL_LITERAL_in_nullType7147  */
static	ANTLR3_BITWORD FOLLOW_NULL_LITERAL_in_nullType7147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NULL_LITERAL_in_nullType7147	= { FOLLOW_NULL_LITERAL_in_nullType7147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BOOLEAN_LITERAL_in_booleanType7155  */
static	ANTLR3_BITWORD FOLLOW_BOOLEAN_LITERAL_in_booleanType7155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BOOLEAN_LITERAL_in_booleanType7155	= { FOLLOW_BOOLEAN_LITERAL_in_booleanType7155_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BIT_LITERAL_in_bitStringType7169  */
static	ANTLR3_BITWORD FOLLOW_BIT_LITERAL_in_bitStringType7169_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BIT_LITERAL_in_bitStringType7169	= { FOLLOW_BIT_LITERAL_in_bitStringType7169_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_bitStringType7171  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_bitStringType7171_bits[]	= { ANTLR3_UINT64_LIT(0x0000010004800002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_bitStringType7171	= { FOLLOW_STRING_LITERAL_in_bitStringType7171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_bitStringType7175  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_bitStringType7175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_bitStringType7175	= { FOLLOW_L_BRACE_in_bitStringType7175_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedBitList_in_bitStringType7179  */
static	ANTLR3_BITWORD FOLLOW_namedBitList_in_bitStringType7179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_namedBitList_in_bitStringType7179	= { FOLLOW_namedBitList_in_bitStringType7179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_bitStringType7181  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_bitStringType7181_bits[]	= { ANTLR3_UINT64_LIT(0x0000010004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_bitStringType7181	= { FOLLOW_R_BRACE_in_bitStringType7181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_LITERAL_in_bitStringType7186  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_LITERAL_in_bitStringType7186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_LITERAL_in_bitStringType7186	= { FOLLOW_DEFAULT_LITERAL_in_bitStringType7186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_bitStringType7188  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_bitStringType7188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_bitStringType7188	= { FOLLOW_L_BRACE_in_bitStringType7188_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedBitList_in_bitStringType7192  */
static	ANTLR3_BITWORD FOLLOW_namedBitList_in_bitStringType7192_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_namedBitList_in_bitStringType7192	= { FOLLOW_namedBitList_in_bitStringType7192_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_bitStringType7194  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_bitStringType7194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_bitStringType7194	= { FOLLOW_R_BRACE_in_bitStringType7194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_bitStringType7199  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_bitStringType7199_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_bitStringType7199	= { FOLLOW_L_PARAN_in_bitStringType7199_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIZE_LITERAL_in_bitStringType7203  */
static	ANTLR3_BITWORD FOLLOW_SIZE_LITERAL_in_bitStringType7203_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SIZE_LITERAL_in_bitStringType7203	= { FOLLOW_SIZE_LITERAL_in_bitStringType7203_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_bitStringType7209  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_bitStringType7209_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_bitStringType7209	= { FOLLOW_constraint_in_bitStringType7209_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sizeConstraint_in_bitStringType7215  */
static	ANTLR3_BITWORD FOLLOW_sizeConstraint_in_bitStringType7215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sizeConstraint_in_bitStringType7215	= { FOLLOW_sizeConstraint_in_bitStringType7215_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_bitStringType7218  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_bitStringType7218_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_bitStringType7218	= { FOLLOW_R_PARAN_in_bitStringType7218_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedBit_in_namedBitList7257  */
static	ANTLR3_BITWORD FOLLOW_namedBit_in_namedBitList7257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedBit_in_namedBitList7257	= { FOLLOW_namedBit_in_namedBitList7257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_namedBitList7261  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_namedBitList7261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_namedBitList7261	= { FOLLOW_COMMA_in_namedBitList7261_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedBit_in_namedBitList7264  */
static	ANTLR3_BITWORD FOLLOW_namedBit_in_namedBitList7264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_namedBit_in_namedBitList7264	= { FOLLOW_namedBit_in_namedBitList7264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_namedBit7280  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_namedBit7280_bits[]	= { ANTLR3_UINT64_LIT(0x000000000C000002), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_namedBit7280	= { FOLLOW_IDENTIFIER_in_namedBit7280_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_namedBit7282  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_namedBit7282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000002), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_namedBit7282	= { FOLLOW_L_PARAN_in_namedBit7282_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_namedBit7288  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_namedBit7288_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_namedBit7288	= { FOLLOW_NUMBER_in_namedBit7288_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedValue_in_namedBit7294  */
static	ANTLR3_BITWORD FOLLOW_definedValue_in_namedBit7294_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedValue_in_namedBit7294	= { FOLLOW_definedValue_in_namedBit7294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_namedBit7298  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_namedBit7298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_namedBit7298	= { FOLLOW_R_PARAN_in_namedBit7298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_booleanValue0  */
static	ANTLR3_BITWORD FOLLOW_set_in_booleanValue0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_booleanValue0	= { FOLLOW_set_in_booleanValue0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BSTRING_in_bitValue7344  */
static	ANTLR3_BITWORD FOLLOW_BSTRING_in_bitValue7344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BSTRING_in_bitValue7344	= { FOLLOW_BSTRING_in_bitValue7344_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueAssignment_in_synpred23_asn13783  */
static	ANTLR3_BITWORD FOLLOW_valueAssignment_in_synpred23_asn13783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueAssignment_in_synpred23_asn13783	= { FOLLOW_valueAssignment_in_synpred23_asn13783_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typeAssignment_in_synpred24_asn13792  */
static	ANTLR3_BITWORD FOLLOW_typeAssignment_in_synpred24_asn13792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typeAssignment_in_synpred24_asn13792	= { FOLLOW_typeAssignment_in_synpred24_asn13792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameterizedAssignment_in_synpred25_asn13800  */
static	ANTLR3_BITWORD FOLLOW_parameterizedAssignment_in_synpred25_asn13800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_parameterizedAssignment_in_synpred25_asn13800	= { FOLLOW_parameterizedAssignment_in_synpred25_asn13800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAndException_in_synpred26_asn13856  */
static	ANTLR3_BITWORD FOLLOW_extensionAndException_in_synpred26_asn13856_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAndException_in_synpred26_asn13856	= { FOLLOW_extensionAndException_in_synpred26_asn13856_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_optionalExtensionMarker_in_synpred26_asn13859  */
static	ANTLR3_BITWORD FOLLOW_optionalExtensionMarker_in_synpred26_asn13859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_optionalExtensionMarker_in_synpred26_asn13859	= { FOLLOW_optionalExtensionMarker_in_synpred26_asn13859_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentTypeLists_in_synpred27_asn13863  */
static	ANTLR3_BITWORD FOLLOW_componentTypeLists_in_synpred27_asn13863_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_componentTypeLists_in_synpred27_asn13863	= { FOLLOW_componentTypeLists_in_synpred27_asn13863_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exceptionSpec_in_synpred28_asn13897  */
static	ANTLR3_BITWORD FOLLOW_exceptionSpec_in_synpred28_asn13897_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exceptionSpec_in_synpred28_asn13897	= { FOLLOW_exceptionSpec_in_synpred28_asn13897_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIZE_LITERAL_in_synpred42_asn14193  */
static	ANTLR3_BITWORD FOLLOW_SIZE_LITERAL_in_synpred42_asn14193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIZE_LITERAL_in_synpred42_asn14193	= { FOLLOW_SIZE_LITERAL_in_synpred42_asn14193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_synpred43_asn14197  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_synpred43_asn14197_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_synpred43_asn14197	= { FOLLOW_L_PARAN_in_synpred43_asn14197_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_synpred44_asn14203  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_synpred44_asn14203_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_synpred44_asn14203	= { FOLLOW_constraint_in_synpred44_asn14203_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_synpred47_asn14222  */
static	ANTLR3_BITWORD FOLLOW_type_in_synpred47_asn14222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_synpred47_asn14222	= { FOLLOW_type_in_synpred47_asn14222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_synpred48_asn14296  */
static	ANTLR3_BITWORD FOLLOW_type_in_synpred48_asn14296_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_synpred48_asn14296	= { FOLLOW_type_in_synpred48_asn14296_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_synpred49_asn14303  */
static	ANTLR3_BITWORD FOLLOW_value_in_synpred49_asn14303_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_synpred49_asn14303	= { FOLLOW_value_in_synpred49_asn14303_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_in_synpred51_asn14327  */
static	ANTLR3_BITWORD FOLLOW_object_in_synpred51_asn14327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_in_synpred51_asn14327	= { FOLLOW_object_in_synpred51_asn14327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectClass_in_synpred52_asn14334  */
static	ANTLR3_BITWORD FOLLOW_objectClass_in_synpred52_asn14334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectClass_in_synpred52_asn14334	= { FOLLOW_objectClass_in_synpred52_asn14334_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_governor_in_synpred55_asn14395  */
static	ANTLR3_BITWORD FOLLOW_governor_in_synpred55_asn14395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_governor_in_synpred55_asn14395	= { FOLLOW_governor_in_synpred55_asn14395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_synpred56_asn14411  */
static	ANTLR3_BITWORD FOLLOW_type_in_synpred56_asn14411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_synpred56_asn14411	= { FOLLOW_type_in_synpred56_asn14411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedObjectClass_in_synpred57_asn14444  */
static	ANTLR3_BITWORD FOLLOW_definedObjectClass_in_synpred57_asn14444_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedObjectClass_in_synpred57_asn14444	= { FOLLOW_definedObjectClass_in_synpred57_asn14444_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_synpred62_asn14529  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_synpred62_asn14529_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_synpred62_asn14529	= { FOLLOW_constraint_in_synpred62_asn14529_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSetOptionalitySpec_in_synpred75_asn14765  */
static	ANTLR3_BITWORD FOLLOW_valueSetOptionalitySpec_in_synpred75_asn14765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSetOptionalitySpec_in_synpred75_asn14765	= { FOLLOW_valueSetOptionalitySpec_in_synpred75_asn14765_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_synpred78_asn14762  */
static	ANTLR3_BITWORD FOLLOW_type_in_synpred78_asn14762_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_synpred78_asn14762	= { FOLLOW_type_in_synpred78_asn14762_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSetOptionalitySpec_in_synpred78_asn14765  */
static	ANTLR3_BITWORD FOLLOW_valueSetOptionalitySpec_in_synpred78_asn14765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSetOptionalitySpec_in_synpred78_asn14765	= { FOLLOW_valueSetOptionalitySpec_in_synpred78_asn14765_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNIQUE_LITERAL_in_synpred78_asn14771  */
static	ANTLR3_BITWORD FOLLOW_UNIQUE_LITERAL_in_synpred78_asn14771_bits[]	= { ANTLR3_UINT64_LIT(0x0000018000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNIQUE_LITERAL_in_synpred78_asn14771	= { FOLLOW_UNIQUE_LITERAL_in_synpred78_asn14771_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueOptionalitySpec_in_synpred78_asn14774  */
static	ANTLR3_BITWORD FOLLOW_valueOptionalitySpec_in_synpred78_asn14774_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueOptionalitySpec_in_synpred78_asn14774	= { FOLLOW_valueOptionalitySpec_in_synpred78_asn14774_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSet_in_synpred80_asn14793  */
static	ANTLR3_BITWORD FOLLOW_valueSet_in_synpred80_asn14793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSet_in_synpred80_asn14793	= { FOLLOW_valueSet_in_synpred80_asn14793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_synpred102_asn15104  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_synpred102_asn15104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_synpred102_asn15104	= { FOLLOW_COMMA_in_synpred102_asn15104_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ELLIPSIS_in_synpred102_asn15106  */
static	ANTLR3_BITWORD FOLLOW_ELLIPSIS_in_synpred102_asn15106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ELLIPSIS_in_synpred102_asn15106	= { FOLLOW_ELLIPSIS_in_synpred102_asn15106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_synpred102_asn15109  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_synpred102_asn15109_bits[]	= { ANTLR3_UINT64_LIT(0x1050200814980300), ANTLR3_UINT64_LIT(0x00B0000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_synpred102_asn15109	= { FOLLOW_COMMA_in_synpred102_asn15109_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_additionalElementSetSpec_in_synpred102_asn15111  */
static	ANTLR3_BITWORD FOLLOW_additionalElementSetSpec_in_synpred102_asn15111_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_additionalElementSetSpec_in_synpred102_asn15111	= { FOLLOW_additionalElementSetSpec_in_synpred102_asn15111_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unionMark_in_synpred104_asn15164  */
static	ANTLR3_BITWORD FOLLOW_unionMark_in_synpred104_asn15164_bits[]	= { ANTLR3_UINT64_LIT(0x1050000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_unionMark_in_synpred104_asn15164	= { FOLLOW_unionMark_in_synpred104_asn15164_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_intersections_in_synpred104_asn15166  */
static	ANTLR3_BITWORD FOLLOW_intersections_in_synpred104_asn15166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_intersections_in_synpred104_asn15166	= { FOLLOW_intersections_in_synpred104_asn15166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_intersectionMark_in_synpred105_asn15192  */
static	ANTLR3_BITWORD FOLLOW_intersectionMark_in_synpred105_asn15192_bits[]	= { ANTLR3_UINT64_LIT(0x1050000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_intersectionMark_in_synpred105_asn15192	= { FOLLOW_intersectionMark_in_synpred105_asn15192_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_intersectionElements_in_synpred105_asn15194  */
static	ANTLR3_BITWORD FOLLOW_intersectionElements_in_synpred105_asn15194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_intersectionElements_in_synpred105_asn15194	= { FOLLOW_intersectionElements_in_synpred105_asn15194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_object_in_synpred108_asn15263  */
static	ANTLR3_BITWORD FOLLOW_object_in_synpred108_asn15263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_object_in_synpred108_asn15263	= { FOLLOW_object_in_synpred108_asn15263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exclusions_in_synpred109_asn15282  */
static	ANTLR3_BITWORD FOLLOW_exclusions_in_synpred109_asn15282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exclusions_in_synpred109_asn15282	= { FOLLOW_exclusions_in_synpred109_asn15282_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_synpred114_asn15300  */
static	ANTLR3_BITWORD FOLLOW_value_in_synpred114_asn15300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008800) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_synpred114_asn15300	= { FOLLOW_value_in_synpred114_asn15300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MIN_LITERAL_in_synpred114_asn15304  */
static	ANTLR3_BITWORD FOLLOW_MIN_LITERAL_in_synpred114_asn15304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008800) };
static  ANTLR3_BITSET_LIST FOLLOW_MIN_LITERAL_in_synpred114_asn15304	= { FOLLOW_MIN_LITERAL_in_synpred114_asn15304_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_in_synpred114_asn15307  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_in_synpred114_asn15307_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_in_synpred114_asn15307	= { FOLLOW_LESS_THAN_in_synpred114_asn15307_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOUBLE_DOT_in_synpred114_asn15311  */
static	ANTLR3_BITWORD FOLLOW_DOUBLE_DOT_in_synpred114_asn15311_bits[]	= { ANTLR3_UINT64_LIT(0x0020000010988300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DOUBLE_DOT_in_synpred114_asn15311	= { FOLLOW_DOUBLE_DOT_in_synpred114_asn15311_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_in_synpred114_asn15313  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_in_synpred114_asn15313_bits[]	= { ANTLR3_UINT64_LIT(0x0020000010980300), ANTLR3_UINT64_LIT(0x00B0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_in_synpred114_asn15313	= { FOLLOW_LESS_THAN_in_synpred114_asn15313_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_synpred114_asn15318  */
static	ANTLR3_BITWORD FOLLOW_value_in_synpred114_asn15318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_synpred114_asn15318	= { FOLLOW_value_in_synpred114_asn15318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MAX_LITERAL_in_synpred114_asn15322  */
static	ANTLR3_BITWORD FOLLOW_MAX_LITERAL_in_synpred114_asn15322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MAX_LITERAL_in_synpred114_asn15322	= { FOLLOW_MAX_LITERAL_in_synpred114_asn15322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceType_in_synpred137_asn15687  */
static	ANTLR3_BITWORD FOLLOW_sequenceType_in_synpred137_asn15687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceType_in_synpred137_asn15687	= { FOLLOW_sequenceType_in_synpred137_asn15687_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceOfType_in_synpred138_asn15693  */
static	ANTLR3_BITWORD FOLLOW_sequenceOfType_in_synpred138_asn15693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceOfType_in_synpred138_asn15693	= { FOLLOW_sequenceOfType_in_synpred138_asn15693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_setType_in_synpred139_asn15699  */
static	ANTLR3_BITWORD FOLLOW_setType_in_synpred139_asn15699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_setType_in_synpred139_asn15699	= { FOLLOW_setType_in_synpred139_asn15699_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_setOfType_in_synpred140_asn15705  */
static	ANTLR3_BITWORD FOLLOW_setOfType_in_synpred140_asn15705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_setOfType_in_synpred140_asn15705	= { FOLLOW_setOfType_in_synpred140_asn15705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAndException_in_synpred142_asn15752  */
static	ANTLR3_BITWORD FOLLOW_extensionAndException_in_synpred142_asn15752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAndException_in_synpred142_asn15752	= { FOLLOW_extensionAndException_in_synpred142_asn15752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_optionalExtensionMarker_in_synpred142_asn15755  */
static	ANTLR3_BITWORD FOLLOW_optionalExtensionMarker_in_synpred142_asn15755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_optionalExtensionMarker_in_synpred142_asn15755	= { FOLLOW_optionalExtensionMarker_in_synpred142_asn15755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_componentTypeLists_in_synpred143_asn15760  */
static	ANTLR3_BITWORD FOLLOW_componentTypeLists_in_synpred143_asn15760_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_componentTypeLists_in_synpred143_asn15760	= { FOLLOW_componentTypeLists_in_synpred143_asn15760_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_synpred144_asn15782  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_synpred144_asn15782_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_synpred144_asn15782	= { FOLLOW_constraint_in_synpred144_asn15782_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sizeConstraint_in_synpred145_asn15786  */
static	ANTLR3_BITWORD FOLLOW_sizeConstraint_in_synpred145_asn15786_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sizeConstraint_in_synpred145_asn15786	= { FOLLOW_sizeConstraint_in_synpred145_asn15786_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_synpred146_asn15793  */
static	ANTLR3_BITWORD FOLLOW_type_in_synpred146_asn15793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_synpred146_asn15793	= { FOLLOW_type_in_synpred146_asn15793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_actualParameterList_in_synpred148_asn15844  */
static	ANTLR3_BITWORD FOLLOW_actualParameterList_in_synpred148_asn15844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_actualParameterList_in_synpred148_asn15844	= { FOLLOW_actualParameterList_in_synpred148_asn15844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalConstraint_in_synpred150_asn15897  */
static	ANTLR3_BITWORD FOLLOW_generalConstraint_in_synpred150_asn15897_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalConstraint_in_synpred150_asn15897	= { FOLLOW_generalConstraint_in_synpred150_asn15897_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_valueSet_in_synpred155_asn15973  */
static	ANTLR3_BITWORD FOLLOW_valueSet_in_synpred155_asn15973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_valueSet_in_synpred155_asn15973	= { FOLLOW_valueSet_in_synpred155_asn15973_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectSet_in_synpred157_asn15987  */
static	ANTLR3_BITWORD FOLLOW_objectSet_in_synpred157_asn15987_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_objectSet_in_synpred157_asn15987	= { FOLLOW_objectSet_in_synpred157_asn15987_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONTAINING_LITERAL_in_synpred158_asn16028  */
static	ANTLR3_BITWORD FOLLOW_CONTAINING_LITERAL_in_synpred158_asn16028_bits[]	= { ANTLR3_UINT64_LIT(0x6000087220600080), ANTLR3_UINT64_LIT(0x0010000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONTAINING_LITERAL_in_synpred158_asn16028	= { FOLLOW_CONTAINING_LITERAL_in_synpred158_asn16028_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_synpred158_asn16030  */
static	ANTLR3_BITWORD FOLLOW_type_in_synpred158_asn16030_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_synpred158_asn16030	= { FOLLOW_type_in_synpred158_asn16030_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumeratedValue_in_synpred160_asn16107  */
static	ANTLR3_BITWORD FOLLOW_enumeratedValue_in_synpred160_asn16107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumeratedValue_in_synpred160_asn16107	= { FOLLOW_enumeratedValue_in_synpred160_asn16107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integerValue_in_synpred161_asn16112  */
static	ANTLR3_BITWORD FOLLOW_integerValue_in_synpred161_asn16112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integerValue_in_synpred161_asn16112	= { FOLLOW_integerValue_in_synpred161_asn16112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_synpred169_asn16198  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_synpred169_asn16198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_synpred169_asn16198	= { FOLLOW_IDENTIFIER_in_synpred169_asn16198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_PARAN_in_synpred169_asn16201  */
static	ANTLR3_BITWORD FOLLOW_L_PARAN_in_synpred169_asn16201_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0030000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_PARAN_in_synpred169_asn16201	= { FOLLOW_L_PARAN_in_synpred169_asn16201_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_synpred169_asn16204  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_synpred169_asn16204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_synpred169_asn16204	= { FOLLOW_NUMBER_in_synpred169_asn16204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedValue_in_synpred169_asn16208  */
static	ANTLR3_BITWORD FOLLOW_definedValue_in_synpred169_asn16208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_definedValue_in_synpred169_asn16208	= { FOLLOW_definedValue_in_synpred169_asn16208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_PARAN_in_synpred169_asn16212  */
static	ANTLR3_BITWORD FOLLOW_R_PARAN_in_synpred169_asn16212_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_PARAN_in_synpred169_asn16212	= { FOLLOW_R_PARAN_in_synpred169_asn16212_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_synpred180_asn16571  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_synpred180_asn16571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_synpred180_asn16571	= { FOLLOW_IDENTIFIER_in_synpred180_asn16571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_synpred186_asn16708  */
static	ANTLR3_BITWORD FOLLOW_type_in_synpred186_asn16708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_synpred186_asn16708	= { FOLLOW_type_in_synpred186_asn16708_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXCLAM_in_synpred187_asn16739  */
static	ANTLR3_BITWORD FOLLOW_EXCLAM_in_synpred187_asn16739_bits[]	= { ANTLR3_UINT64_LIT(0x6000087230600080), ANTLR3_UINT64_LIT(0x0030000004100004) };
static  ANTLR3_BITSET_LIST FOLLOW_EXCLAM_in_synpred187_asn16739	= { FOLLOW_EXCLAM_in_synpred187_asn16739_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exceptionIdentification_in_synpred187_asn16742  */
static	ANTLR3_BITWORD FOLLOW_exceptionIdentification_in_synpred187_asn16742_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exceptionIdentification_in_synpred187_asn16742	= { FOLLOW_exceptionIdentification_in_synpred187_asn16742_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedValue_in_synpred189_asn16763  */
static	ANTLR3_BITWORD FOLLOW_definedValue_in_synpred189_asn16763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedValue_in_synpred189_asn16763	= { FOLLOW_definedValue_in_synpred189_asn16763_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIZE_LITERAL_in_synpred191_asn16811  */
static	ANTLR3_BITWORD FOLLOW_SIZE_LITERAL_in_synpred191_asn16811_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIZE_LITERAL_in_synpred191_asn16811	= { FOLLOW_SIZE_LITERAL_in_synpred191_asn16811_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_synpred192_asn16817  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_synpred192_asn16817_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_synpred192_asn16817	= { FOLLOW_constraint_in_synpred192_asn16817_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIZE_LITERAL_in_synpred201_asn17031  */
static	ANTLR3_BITWORD FOLLOW_SIZE_LITERAL_in_synpred201_asn17031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIZE_LITERAL_in_synpred201_asn17031	= { FOLLOW_SIZE_LITERAL_in_synpred201_asn17031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_synpred202_asn17037  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_synpred202_asn17037_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_synpred202_asn17037	= { FOLLOW_constraint_in_synpred202_asn17037_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIZE_LITERAL_in_synpred204_asn17092  */
static	ANTLR3_BITWORD FOLLOW_SIZE_LITERAL_in_synpred204_asn17092_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIZE_LITERAL_in_synpred204_asn17092	= { FOLLOW_SIZE_LITERAL_in_synpred204_asn17092_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_synpred205_asn17098  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_synpred205_asn17098_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_synpred205_asn17098	= { FOLLOW_constraint_in_synpred205_asn17098_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_synpred207_asn17175  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_synpred207_asn17175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_synpred207_asn17175	= { FOLLOW_L_BRACE_in_synpred207_asn17175_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedBitList_in_synpred207_asn17179  */
static	ANTLR3_BITWORD FOLLOW_namedBitList_in_synpred207_asn17179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_namedBitList_in_synpred207_asn17179	= { FOLLOW_namedBitList_in_synpred207_asn17179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_synpred207_asn17181  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_synpred207_asn17181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_synpred207_asn17181	= { FOLLOW_R_BRACE_in_synpred207_asn17181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_LITERAL_in_synpred208_asn17186  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_LITERAL_in_synpred208_asn17186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_LITERAL_in_synpred208_asn17186	= { FOLLOW_DEFAULT_LITERAL_in_synpred208_asn17186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_L_BRACE_in_synpred208_asn17188  */
static	ANTLR3_BITWORD FOLLOW_L_BRACE_in_synpred208_asn17188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_L_BRACE_in_synpred208_asn17188	= { FOLLOW_L_BRACE_in_synpred208_asn17188_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_namedBitList_in_synpred208_asn17192  */
static	ANTLR3_BITWORD FOLLOW_namedBitList_in_synpred208_asn17192_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_namedBitList_in_synpred208_asn17192	= { FOLLOW_namedBitList_in_synpred208_asn17192_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_R_BRACE_in_synpred208_asn17194  */
static	ANTLR3_BITWORD FOLLOW_R_BRACE_in_synpred208_asn17194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_R_BRACE_in_synpred208_asn17194	= { FOLLOW_R_BRACE_in_synpred208_asn17194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIZE_LITERAL_in_synpred209_asn17203  */
static	ANTLR3_BITWORD FOLLOW_SIZE_LITERAL_in_synpred209_asn17203_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIZE_LITERAL_in_synpred209_asn17203	= { FOLLOW_SIZE_LITERAL_in_synpred209_asn17203_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraint_in_synpred210_asn17209  */
static	ANTLR3_BITWORD FOLLOW_constraint_in_synpred210_asn17209_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constraint_in_synpred210_asn17209	= { FOLLOW_constraint_in_synpred210_asn17209_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start moduleDefinition
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:134:1: moduleDefinition : id= IDENTIFIER ( L_BRACE ( (id2+= IDENTIFIER | id2+= NUMBER ) ( L_PARAN id2+= NUMBER R_PARAN )* )* R_BRACE )? DEFINITIONS_LITERAL td= tagDefault extensionDefault ASSIGN_OP BEGIN_LITERAL moduleBody END_LITERAL -> ^( MODULE_ROOT ^( MODULE_ID $id ( $id2)* ) ^( DEFINITION_NODE ( $td)? moduleBody ) ) ;
 */
static asn1Parser_moduleDefinition_return
moduleDefinition(pasn1Parser ctx)
{   
    asn1Parser_moduleDefinition_return retval;
    ANTLR3_UINT32 moduleDefinition_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    id;
    pANTLR3_COMMON_TOKEN    L_BRACE1;
    pANTLR3_COMMON_TOKEN    L_PARAN2;
    pANTLR3_COMMON_TOKEN    R_PARAN3;
    pANTLR3_COMMON_TOKEN    R_BRACE4;
    pANTLR3_COMMON_TOKEN    DEFINITIONS_LITERAL5;
    pANTLR3_COMMON_TOKEN    ASSIGN_OP7;
    pANTLR3_COMMON_TOKEN    BEGIN_LITERAL8;
    pANTLR3_COMMON_TOKEN    END_LITERAL10;
    pANTLR3_COMMON_TOKEN    id2;
    pANTLR3_VECTOR    list_id2;
    asn1Parser_tagDefault_return td;
    #undef	RETURN_TYPE_td
    #define	RETURN_TYPE_td asn1Parser_tagDefault_return

    asn1Parser_extensionDefault_return extensionDefault6;
    #undef	RETURN_TYPE_extensionDefault6
    #define	RETURN_TYPE_extensionDefault6 asn1Parser_extensionDefault_return

    asn1Parser_moduleBody_return moduleBody9;
    #undef	RETURN_TYPE_moduleBody9
    #define	RETURN_TYPE_moduleBody9 asn1Parser_moduleBody_return

    pANTLR3_BASE_TREE id_tree;
    pANTLR3_BASE_TREE L_BRACE1_tree;
    pANTLR3_BASE_TREE L_PARAN2_tree;
    pANTLR3_BASE_TREE R_PARAN3_tree;
    pANTLR3_BASE_TREE R_BRACE4_tree;
    pANTLR3_BASE_TREE DEFINITIONS_LITERAL5_tree;
    pANTLR3_BASE_TREE ASSIGN_OP7_tree;
    pANTLR3_BASE_TREE BEGIN_LITERAL8_tree;
    pANTLR3_BASE_TREE END_LITERAL10_tree;
    pANTLR3_BASE_TREE id2_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ASSIGN_OP;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_END_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_DEFINITIONS_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BEGIN_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_PARAN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_PARAN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NUMBER;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_extensionDefault;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_tagDefault;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_moduleBody;
    /* Initialize rule variables
     */
    moduleDefinition_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(1)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    id       = NULL;
    L_BRACE1       = NULL;
    L_PARAN2       = NULL;
    R_PARAN3       = NULL;
    R_BRACE4       = NULL;
    DEFINITIONS_LITERAL5       = NULL;
    ASSIGN_OP7       = NULL;
    BEGIN_LITERAL8       = NULL;
    END_LITERAL10       = NULL;
    id2       = NULL;
    list_id2     = NULL;
    td.tree = NULL;

    extensionDefault6.tree = NULL;

    moduleBody9.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    id_tree   = NULL;
    L_BRACE1_tree   = NULL;
    L_PARAN2_tree   = NULL;
    R_PARAN3_tree   = NULL;
    R_BRACE4_tree   = NULL;
    DEFINITIONS_LITERAL5_tree   = NULL;
    ASSIGN_OP7_tree   = NULL;
    BEGIN_LITERAL8_tree   = NULL;
    END_LITERAL10_tree   = NULL;
    id2_tree   = NULL;

    stream_ASSIGN_OP   = NULL;
    #define CREATE_stream_ASSIGN_OP  if (stream_ASSIGN_OP == NULL) {stream_ASSIGN_OP = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ASSIGN_OP"); } 
    stream_L_BRACE   = NULL;
    #define CREATE_stream_L_BRACE  if (stream_L_BRACE == NULL) {stream_L_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_BRACE"); } 
    stream_END_LITERAL   = NULL;
    #define CREATE_stream_END_LITERAL  if (stream_END_LITERAL == NULL) {stream_END_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token END_LITERAL"); } 
    stream_DEFINITIONS_LITERAL   = NULL;
    #define CREATE_stream_DEFINITIONS_LITERAL  if (stream_DEFINITIONS_LITERAL == NULL) {stream_DEFINITIONS_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token DEFINITIONS_LITERAL"); } 
    stream_R_BRACE   = NULL;
    #define CREATE_stream_R_BRACE  if (stream_R_BRACE == NULL) {stream_R_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_BRACE"); } 
    stream_BEGIN_LITERAL   = NULL;
    #define CREATE_stream_BEGIN_LITERAL  if (stream_BEGIN_LITERAL == NULL) {stream_BEGIN_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BEGIN_LITERAL"); } 
    stream_L_PARAN   = NULL;
    #define CREATE_stream_L_PARAN  if (stream_L_PARAN == NULL) {stream_L_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_PARAN"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_R_PARAN   = NULL;
    #define CREATE_stream_R_PARAN  if (stream_R_PARAN == NULL) {stream_R_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_PARAN"); } 
    stream_NUMBER   = NULL;
    #define CREATE_stream_NUMBER  if (stream_NUMBER == NULL) {stream_NUMBER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token NUMBER"); } 
    stream_extensionDefault   = NULL;
    #define CREATE_stream_extensionDefault  if (stream_extensionDefault == NULL) {stream_extensionDefault = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule extensionDefault"); }
    stream_tagDefault   = NULL;
    #define CREATE_stream_tagDefault  if (stream_tagDefault == NULL) {stream_tagDefault = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule tagDefault"); }
    stream_moduleBody   = NULL;
    #define CREATE_stream_moduleBody  if (stream_moduleBody == NULL) {stream_moduleBody = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule moduleBody"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:134:18: (id= IDENTIFIER ( L_BRACE ( (id2+= IDENTIFIER | id2+= NUMBER ) ( L_PARAN id2+= NUMBER R_PARAN )* )* R_BRACE )? DEFINITIONS_LITERAL td= tagDefault extensionDefault ASSIGN_OP BEGIN_LITERAL moduleBody END_LITERAL -> ^( MODULE_ROOT ^( MODULE_ID $id ( $id2)* ) ^( DEFINITION_NODE ( $td)? moduleBody ) ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:135:6: id= IDENTIFIER ( L_BRACE ( (id2+= IDENTIFIER | id2+= NUMBER ) ( L_PARAN id2+= NUMBER R_PARAN )* )* R_BRACE )? DEFINITIONS_LITERAL td= tagDefault extensionDefault ASSIGN_OP BEGIN_LITERAL moduleBody END_LITERAL
        {
            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_moduleDefinition3218); 
            if  (HASEXCEPTION())
            {
                goto rulemoduleDefinitionEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, id, NULL); }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:135:20: ( L_BRACE ( (id2+= IDENTIFIER | id2+= NUMBER ) ( L_PARAN id2+= NUMBER R_PARAN )* )* R_BRACE )?
            {
                int alt4=2;
                switch ( LA(1) ) 
                {
                    case L_BRACE:
                    	{
                    		alt4=1;
                    	}
                        break;
                }

                switch (alt4) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:135:21: L_BRACE ( (id2+= IDENTIFIER | id2+= NUMBER ) ( L_PARAN id2+= NUMBER R_PARAN )* )* R_BRACE
            	    {
            	        L_BRACE1 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_moduleDefinition3221); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemoduleDefinitionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_L_BRACE; stream_L_BRACE->add(stream_L_BRACE, L_BRACE1, NULL); }


            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:135:29: ( (id2+= IDENTIFIER | id2+= NUMBER ) ( L_PARAN id2+= NUMBER R_PARAN )* )*

            	        for (;;)
            	        {
            	            int alt3=2;
            	            switch ( LA(1) ) 
            	            {
            	            case IDENTIFIER:
            	            case NUMBER:
            	            	{
            	            		alt3=1;
            	            	}
            	                break;

            	            }

            	            switch (alt3) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:135:30: (id2+= IDENTIFIER | id2+= NUMBER ) ( L_PARAN id2+= NUMBER R_PARAN )*
            	        	    {

            	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:135:30: (id2+= IDENTIFIER | id2+= NUMBER )
            	        	        {
            	        	            int alt1=2;
            	        	            switch ( LA(1) ) 
            	        	            {
            	        	            case IDENTIFIER:
            	        	            	{
            	        	            		alt1=1;
            	        	            	}
            	        	                break;
            	        	            case NUMBER:
            	        	            	{
            	        	            		alt1=2;
            	        	            	}
            	        	                break;

            	        	            default:
            	        	                if (BACKTRACKING>0)
            	        	                {
            	        	                    FAILEDFLAG = ANTLR3_TRUE;
            	        	                    return retval;
            	        	                }
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 1;
            	        	                EXCEPTION->state        = 0;


            	        	                goto rulemoduleDefinitionEx;
            	        	            }

            	        	            switch (alt1) 
            	        	            {
            	        	        	case 1:
            	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:135:31: id2+= IDENTIFIER
            	        	        	    {
            	        	        	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_moduleDefinition3227); 
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulemoduleDefinitionEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        } 
            	        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, id2, NULL); }

            	        	        	        if (list_id2 == NULL)
            	        	        	        {
            	        	        	            list_id2=ctx->vectors->newVector(ctx->vectors);
            	        	        	        }
            	        	        	        list_id2->add(list_id2, id2, NULL);

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:135:49: id2+= NUMBER
            	        	        	    {
            	        	        	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_moduleDefinition3233); 
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulemoduleDefinitionEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        } 
            	        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_NUMBER; stream_NUMBER->add(stream_NUMBER, id2, NULL); }

            	        	        	        if (list_id2 == NULL)
            	        	        	        {
            	        	        	            list_id2=ctx->vectors->newVector(ctx->vectors);
            	        	        	        }
            	        	        	        list_id2->add(list_id2, id2, NULL);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:135:62: ( L_PARAN id2+= NUMBER R_PARAN )*

            	        	        for (;;)
            	        	        {
            	        	            int alt2=2;
            	        	            switch ( LA(1) ) 
            	        	            {
            	        	            case L_PARAN:
            	        	            	{
            	        	            		alt2=1;
            	        	            	}
            	        	                break;

            	        	            }

            	        	            switch (alt2) 
            	        	            {
            	        	        	case 1:
            	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:135:63: L_PARAN id2+= NUMBER R_PARAN
            	        	        	    {
            	        	        	        L_PARAN2 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_moduleDefinition3237); 
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulemoduleDefinitionEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        } 
            	        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_L_PARAN; stream_L_PARAN->add(stream_L_PARAN, L_PARAN2, NULL); }

            	        	        	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_moduleDefinition3241); 
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulemoduleDefinitionEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        } 
            	        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_NUMBER; stream_NUMBER->add(stream_NUMBER, id2, NULL); }

            	        	        	        if (list_id2 == NULL)
            	        	        	        {
            	        	        	            list_id2=ctx->vectors->newVector(ctx->vectors);
            	        	        	        }
            	        	        	        list_id2->add(list_id2, id2, NULL);
            	        	        	        R_PARAN3 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_moduleDefinition3243); 
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulemoduleDefinitionEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        } 
            	        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_R_PARAN; stream_R_PARAN->add(stream_R_PARAN, R_PARAN3, NULL); }


            	        	        	    }
            	        	        	    break;

            	        	        	default:
            	        	        	    goto loop2;	/* break out of the loop */
            	        	        	    break;
            	        	            }
            	        	        }
            	        	        loop2: ; /* Jump out to here if this rule does not match */


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop3;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop3: ; /* Jump out to here if this rule does not match */

            	        R_BRACE4 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_moduleDefinition3249); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemoduleDefinitionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_R_BRACE; stream_R_BRACE->add(stream_R_BRACE, R_BRACE4, NULL); }


            	    }
            	    break;

                }
            }
            DEFINITIONS_LITERAL5 = (pANTLR3_COMMON_TOKEN) MATCHT(DEFINITIONS_LITERAL, &FOLLOW_DEFINITIONS_LITERAL_in_moduleDefinition3258); 
            if  (HASEXCEPTION())
            {
                goto rulemoduleDefinitionEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_DEFINITIONS_LITERAL; stream_DEFINITIONS_LITERAL->add(stream_DEFINITIONS_LITERAL, DEFINITIONS_LITERAL5, NULL); }

            FOLLOWPUSH(FOLLOW_tagDefault_in_moduleDefinition3267);
            td=tagDefault(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemoduleDefinitionEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_tagDefault; stream_tagDefault->add(stream_tagDefault, td.tree, NULL); }
            FOLLOWPUSH(FOLLOW_extensionDefault_in_moduleDefinition3274);
            extensionDefault6=extensionDefault(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemoduleDefinitionEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_extensionDefault; stream_extensionDefault->add(stream_extensionDefault, extensionDefault6.tree, NULL); }
            ASSIGN_OP7 = (pANTLR3_COMMON_TOKEN) MATCHT(ASSIGN_OP, &FOLLOW_ASSIGN_OP_in_moduleDefinition3282); 
            if  (HASEXCEPTION())
            {
                goto rulemoduleDefinitionEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_ASSIGN_OP; stream_ASSIGN_OP->add(stream_ASSIGN_OP, ASSIGN_OP7, NULL); }

            BEGIN_LITERAL8 = (pANTLR3_COMMON_TOKEN) MATCHT(BEGIN_LITERAL, &FOLLOW_BEGIN_LITERAL_in_moduleDefinition3290); 
            if  (HASEXCEPTION())
            {
                goto rulemoduleDefinitionEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_BEGIN_LITERAL; stream_BEGIN_LITERAL->add(stream_BEGIN_LITERAL, BEGIN_LITERAL8, NULL); }

            FOLLOWPUSH(FOLLOW_moduleBody_in_moduleDefinition3297);
            moduleBody9=moduleBody(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemoduleDefinitionEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_moduleBody; stream_moduleBody->add(stream_moduleBody, moduleBody9.tree, NULL); }
            END_LITERAL10 = (pANTLR3_COMMON_TOKEN) MATCHT(END_LITERAL, &FOLLOW_END_LITERAL_in_moduleDefinition3305); 
            if  (HASEXCEPTION())
            {
                goto rulemoduleDefinitionEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_END_LITERAL; stream_END_LITERAL->add(stream_END_LITERAL, END_LITERAL10, NULL); }


             
            /* AST REWRITE
             * elements          : id, moduleBody, td, id2
             * token labels      : id
             * rule labels       : retval, td
             * token list labels : id2
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_id;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_id2;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_td;

            	stream_id=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token id", id);
            	stream_id2=antlr3RewriteRuleTOKENStreamNewAEV(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token id2", list_id2); 
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_td=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token td", td.tree != NULL ? td.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 143:6: -> ^( MODULE_ROOT ^( MODULE_ID $id ( $id2)* ) ^( DEFINITION_NODE ( $td)? moduleBody ) )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:143:9: ^( MODULE_ROOT ^( MODULE_ID $id ( $id2)* ) ^( DEFINITION_NODE ( $td)? moduleBody ) )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, MODULE_ROOT, (pANTLR3_UINT8)"MODULE_ROOT"), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:143:23: ^( MODULE_ID $id ( $id2)* )
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, MODULE_ID, (pANTLR3_UINT8)"MODULE_ID"), root_2));

            	            ADAPTOR->addChild(ADAPTOR, root_2, stream_id == NULL ? NULL : stream_id->nextNode(stream_id));
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:143:39: ( $id2)*
            	            {
            	            	while ( (stream_id2 != NULL && stream_id2->hasNext(stream_id2))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_id2 == NULL ? NULL : stream_id2->nextNode(stream_id2));

            	            	}
            	            	if (stream_id2 != NULL) stream_id2->reset(stream_id2);

            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:143:46: ^( DEFINITION_NODE ( $td)? moduleBody )
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, DEFINITION_NODE, (pANTLR3_UINT8)"DEFINITION_NODE"), root_2));

            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:143:64: ( $td)?
            	            {
            	            	if ( (stream_td != NULL && stream_td->hasNext(stream_td))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_td == NULL ? NULL : stream_td->nextTree(stream_td));

            	            	}
            	            	if ( stream_td != NULL) stream_td->reset(stream_td);

            	            }
            	            ADAPTOR->addChild(ADAPTOR, root_2, stream_moduleBody == NULL ? NULL : stream_moduleBody->nextTree(stream_moduleBody));

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_id != NULL) stream_id->free(stream_id); 
            	if (stream_id2 != NULL) stream_id2->free(stream_id2);
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_td != NULL) stream_td->free(stream_td);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemoduleDefinitionEx; /* Prevent compiler warnings */
    rulemoduleDefinitionEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_ASSIGN_OP != NULL) stream_ASSIGN_OP->free(stream_ASSIGN_OP);
        if (stream_L_BRACE != NULL) stream_L_BRACE->free(stream_L_BRACE);
        if (stream_END_LITERAL != NULL) stream_END_LITERAL->free(stream_END_LITERAL);
        if (stream_DEFINITIONS_LITERAL != NULL) stream_DEFINITIONS_LITERAL->free(stream_DEFINITIONS_LITERAL);
        if (stream_R_BRACE != NULL) stream_R_BRACE->free(stream_R_BRACE);
        if (stream_BEGIN_LITERAL != NULL) stream_BEGIN_LITERAL->free(stream_BEGIN_LITERAL);
        if (stream_L_PARAN != NULL) stream_L_PARAN->free(stream_L_PARAN);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_R_PARAN != NULL) stream_R_PARAN->free(stream_R_PARAN);
        if (stream_NUMBER != NULL) stream_NUMBER->free(stream_NUMBER);
        if (stream_extensionDefault != NULL) stream_extensionDefault->free(stream_extensionDefault);
        if (stream_tagDefault != NULL) stream_tagDefault->free(stream_tagDefault);
        if (stream_moduleBody != NULL) stream_moduleBody->free(stream_moduleBody);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(1, moduleDefinition_StartIndex); }

    return retval;
}
/* $ANTLR end moduleDefinition */

/** 
 * $ANTLR start tagDefault
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:149:1: tagDefault : ( ( EXPLICIT_LITERAL | IMPLICIT_LITERAL | AUTOMATIC_LITERAL ) TAGS_LITERAL )? ;
 */
static asn1Parser_tagDefault_return
tagDefault(pasn1Parser ctx)
{   
    asn1Parser_tagDefault_return retval;
    ANTLR3_UINT32 tagDefault_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set11;
    pANTLR3_COMMON_TOKEN    TAGS_LITERAL12;

    pANTLR3_BASE_TREE set11_tree;
    pANTLR3_BASE_TREE TAGS_LITERAL12_tree;

    /* Initialize rule variables
     */
    tagDefault_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(2)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    set11       = NULL;
    TAGS_LITERAL12       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set11_tree   = NULL;
    TAGS_LITERAL12_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:149:12: ( ( ( EXPLICIT_LITERAL | IMPLICIT_LITERAL | AUTOMATIC_LITERAL ) TAGS_LITERAL )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:149:14: ( ( EXPLICIT_LITERAL | IMPLICIT_LITERAL | AUTOMATIC_LITERAL ) TAGS_LITERAL )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:149:14: ( ( EXPLICIT_LITERAL | IMPLICIT_LITERAL | AUTOMATIC_LITERAL ) TAGS_LITERAL )?
            {
                int alt5=2;
                switch ( LA(1) ) 
                {
                    case EXPLICIT_LITERAL:
                    case IMPLICIT_LITERAL:
                    case AUTOMATIC_LITERAL:
                    	{
                    		alt5=1;
                    	}
                        break;
                }

                switch (alt5) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:149:15: ( EXPLICIT_LITERAL | IMPLICIT_LITERAL | AUTOMATIC_LITERAL ) TAGS_LITERAL
            	    {
            	        set11=(pANTLR3_COMMON_TOKEN)LT(1);
            	        if ( LA(1) == EXPLICIT_LITERAL || ((LA(1) >= IMPLICIT_LITERAL) && (LA(1) <= AUTOMATIC_LITERAL)) )
            	        {
            	            CONSUME();
            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set11)));
            	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else 
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_tagDefault3381;
            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_tagDefault3381);    goto ruletagDefaultEx;
            	        }

            	        TAGS_LITERAL12 = (pANTLR3_COMMON_TOKEN) MATCHT(TAGS_LITERAL, &FOLLOW_TAGS_LITERAL_in_tagDefault3389); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletagDefaultEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletagDefaultEx; /* Prevent compiler warnings */
    ruletagDefaultEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(2, tagDefault_StartIndex); }

    return retval;
}
/* $ANTLR end tagDefault */

/** 
 * $ANTLR start extensionDefault
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:152:1: extensionDefault : ( EXTENSIBILITY_LITERAL IMPLIED_LITERAL )? ;
 */
static asn1Parser_extensionDefault_return
extensionDefault(pasn1Parser ctx)
{   
    asn1Parser_extensionDefault_return retval;
    ANTLR3_UINT32 extensionDefault_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EXTENSIBILITY_LITERAL13;
    pANTLR3_COMMON_TOKEN    IMPLIED_LITERAL14;

    pANTLR3_BASE_TREE EXTENSIBILITY_LITERAL13_tree;
    pANTLR3_BASE_TREE IMPLIED_LITERAL14_tree;

    /* Initialize rule variables
     */
    extensionDefault_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(3)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    EXTENSIBILITY_LITERAL13       = NULL;
    IMPLIED_LITERAL14       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    EXTENSIBILITY_LITERAL13_tree   = NULL;
    IMPLIED_LITERAL14_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:152:18: ( ( EXTENSIBILITY_LITERAL IMPLIED_LITERAL )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:153:4: ( EXTENSIBILITY_LITERAL IMPLIED_LITERAL )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:153:4: ( EXTENSIBILITY_LITERAL IMPLIED_LITERAL )?
            {
                int alt6=2;
                switch ( LA(1) ) 
                {
                    case EXTENSIBILITY_LITERAL:
                    	{
                    		alt6=1;
                    	}
                        break;
                }

                switch (alt6) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:153:5: EXTENSIBILITY_LITERAL IMPLIED_LITERAL
            	    {
            	        EXTENSIBILITY_LITERAL13 = (pANTLR3_COMMON_TOKEN) MATCHT(EXTENSIBILITY_LITERAL, &FOLLOW_EXTENSIBILITY_LITERAL_in_extensionDefault3408); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionDefaultEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        EXTENSIBILITY_LITERAL13_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EXTENSIBILITY_LITERAL13));
            	        ADAPTOR->addChild(ADAPTOR, root_0, EXTENSIBILITY_LITERAL13_tree);
            	        }
            	        IMPLIED_LITERAL14 = (pANTLR3_COMMON_TOKEN) MATCHT(IMPLIED_LITERAL, &FOLLOW_IMPLIED_LITERAL_in_extensionDefault3410); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionDefaultEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        IMPLIED_LITERAL14_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IMPLIED_LITERAL14));
            	        ADAPTOR->addChild(ADAPTOR, root_0, IMPLIED_LITERAL14_tree);
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextensionDefaultEx; /* Prevent compiler warnings */
    ruleextensionDefaultEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(3, extensionDefault_StartIndex); }

    return retval;
}
/* $ANTLR end extensionDefault */

/** 
 * $ANTLR start moduleBody
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:156:1: moduleBody : (ex= exports im= imports as= assignmentList )? -> ^( BODY_NODE ^( EXPORTS_NODE ( $ex)? ) ^( IMPORTS_NODE ( $im)? ) ^( $as) ) ;
 */
static asn1Parser_moduleBody_return
moduleBody(pasn1Parser ctx)
{   
    asn1Parser_moduleBody_return retval;
    ANTLR3_UINT32 moduleBody_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_exports_return ex;
    #undef	RETURN_TYPE_ex
    #define	RETURN_TYPE_ex asn1Parser_exports_return

    asn1Parser_imports_return im;
    #undef	RETURN_TYPE_im
    #define	RETURN_TYPE_im asn1Parser_imports_return

    asn1Parser_assignmentList_return as;
    #undef	RETURN_TYPE_as
    #define	RETURN_TYPE_as asn1Parser_assignmentList_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_assignmentList;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_exports;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_imports;
    /* Initialize rule variables
     */
    moduleBody_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(4)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    ex.tree = NULL;

    im.tree = NULL;

    as.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_assignmentList   = NULL;
    #define CREATE_stream_assignmentList  if (stream_assignmentList == NULL) {stream_assignmentList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule assignmentList"); }
    stream_exports   = NULL;
    #define CREATE_stream_exports  if (stream_exports == NULL) {stream_exports = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule exports"); }
    stream_imports   = NULL;
    #define CREATE_stream_imports  if (stream_imports == NULL) {stream_imports = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule imports"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:156:12: ( (ex= exports im= imports as= assignmentList )? -> ^( BODY_NODE ^( EXPORTS_NODE ( $ex)? ) ^( IMPORTS_NODE ( $im)? ) ^( $as) ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:156:15: (ex= exports im= imports as= assignmentList )?
        {

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:156:15: (ex= exports im= imports as= assignmentList )?
            {
                int alt7=2;
                switch ( LA(1) ) 
                {
                    case IMPORTS_LITERAL:
                    case EXPORTS_LITERAL:
                    case IDENTIFIER:
                    	{
                    		alt7=1;
                    	}
                        break;
                }

                switch (alt7) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:156:16: ex= exports im= imports as= assignmentList
            	    {
            	        FOLLOWPUSH(FOLLOW_exports_in_moduleBody3425);
            	        ex=exports(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemoduleBodyEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_exports; stream_exports->add(stream_exports, ex.tree, NULL); }
            	        FOLLOWPUSH(FOLLOW_imports_in_moduleBody3429);
            	        im=imports(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemoduleBodyEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_imports; stream_imports->add(stream_imports, im.tree, NULL); }
            	        FOLLOWPUSH(FOLLOW_assignmentList_in_moduleBody3433);
            	        as=assignmentList(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemoduleBodyEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_assignmentList; stream_assignmentList->add(stream_assignmentList, as.tree, NULL); }

            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : im, ex, as
             * token labels      : 
             * rule labels       : ex, retval, as, im
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_ex;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_as;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_im;

            	stream_ex=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token ex", ex.tree != NULL ? ex.tree : NULL);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_as=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token as", as.tree != NULL ? as.tree : NULL);
            	stream_im=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token im", im.tree != NULL ? im.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 156:58: -> ^( BODY_NODE ^( EXPORTS_NODE ( $ex)? ) ^( IMPORTS_NODE ( $im)? ) ^( $as) )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:156:61: ^( BODY_NODE ^( EXPORTS_NODE ( $ex)? ) ^( IMPORTS_NODE ( $im)? ) ^( $as) )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BODY_NODE, (pANTLR3_UINT8)"BODY_NODE"), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:156:73: ^( EXPORTS_NODE ( $ex)? )
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, EXPORTS_NODE, (pANTLR3_UINT8)"EXPORTS_NODE"), root_2));

            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:156:88: ( $ex)?
            	            {
            	            	if ( (stream_ex != NULL && stream_ex->hasNext(stream_ex))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_ex == NULL ? NULL : stream_ex->nextTree(stream_ex));

            	            	}
            	            	if ( stream_ex != NULL) stream_ex->reset(stream_ex);

            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:156:94: ^( IMPORTS_NODE ( $im)? )
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IMPORTS_NODE, (pANTLR3_UINT8)"IMPORTS_NODE"), root_2));

            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:156:109: ( $im)?
            	            {
            	            	if ( (stream_im != NULL && stream_im->hasNext(stream_im))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_im == NULL ? NULL : stream_im->nextTree(stream_im));

            	            	}
            	            	if ( stream_im != NULL) stream_im->reset(stream_im);

            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:156:115: ^( $as)
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_as == NULL ? NULL : stream_as->nextNode(stream_as), root_2));

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_ex != NULL) stream_ex->free(stream_ex);
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_as != NULL) stream_as->free(stream_as);
            	if (stream_im != NULL) stream_im->free(stream_im);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemoduleBodyEx; /* Prevent compiler warnings */
    rulemoduleBodyEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_assignmentList != NULL) stream_assignmentList->free(stream_assignmentList);
        if (stream_exports != NULL) stream_exports->free(stream_exports);
        if (stream_imports != NULL) stream_imports->free(stream_imports);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(4, moduleBody_StartIndex); }

    return retval;
}
/* $ANTLR end moduleBody */

/** 
 * $ANTLR start exports
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:159:1: exports : ( EXPORTS_LITERAL se= symbolsExported SEMI_COLON -> $se | EXPORTS_LITERAL ALL_LITERAL SEMI_COLON )? ;
 */
static asn1Parser_exports_return
exports(pasn1Parser ctx)
{   
    asn1Parser_exports_return retval;
    ANTLR3_UINT32 exports_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EXPORTS_LITERAL15;
    pANTLR3_COMMON_TOKEN    SEMI_COLON16;
    pANTLR3_COMMON_TOKEN    EXPORTS_LITERAL17;
    pANTLR3_COMMON_TOKEN    ALL_LITERAL18;
    pANTLR3_COMMON_TOKEN    SEMI_COLON19;
    asn1Parser_symbolsExported_return se;
    #undef	RETURN_TYPE_se
    #define	RETURN_TYPE_se asn1Parser_symbolsExported_return

    pANTLR3_BASE_TREE EXPORTS_LITERAL15_tree;
    pANTLR3_BASE_TREE SEMI_COLON16_tree;
    pANTLR3_BASE_TREE EXPORTS_LITERAL17_tree;
    pANTLR3_BASE_TREE ALL_LITERAL18_tree;
    pANTLR3_BASE_TREE SEMI_COLON19_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_EXPORTS_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SEMI_COLON;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ALL_LITERAL;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_symbolsExported;
    /* Initialize rule variables
     */
    exports_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(5)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    EXPORTS_LITERAL15       = NULL;
    SEMI_COLON16       = NULL;
    EXPORTS_LITERAL17       = NULL;
    ALL_LITERAL18       = NULL;
    SEMI_COLON19       = NULL;
    se.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    EXPORTS_LITERAL15_tree   = NULL;
    SEMI_COLON16_tree   = NULL;
    EXPORTS_LITERAL17_tree   = NULL;
    ALL_LITERAL18_tree   = NULL;
    SEMI_COLON19_tree   = NULL;

    stream_EXPORTS_LITERAL   = NULL;
    #define CREATE_stream_EXPORTS_LITERAL  if (stream_EXPORTS_LITERAL == NULL) {stream_EXPORTS_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token EXPORTS_LITERAL"); } 
    stream_SEMI_COLON   = NULL;
    #define CREATE_stream_SEMI_COLON  if (stream_SEMI_COLON == NULL) {stream_SEMI_COLON = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SEMI_COLON"); } 
    stream_ALL_LITERAL   = NULL;
    #define CREATE_stream_ALL_LITERAL  if (stream_ALL_LITERAL == NULL) {stream_ALL_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ALL_LITERAL"); } 
    stream_symbolsExported   = NULL;
    #define CREATE_stream_symbolsExported  if (stream_symbolsExported == NULL) {stream_symbolsExported = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule symbolsExported"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:159:9: ( ( EXPORTS_LITERAL se= symbolsExported SEMI_COLON -> $se | EXPORTS_LITERAL ALL_LITERAL SEMI_COLON )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:159:13: ( EXPORTS_LITERAL se= symbolsExported SEMI_COLON -> $se | EXPORTS_LITERAL ALL_LITERAL SEMI_COLON )?
        {

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:159:13: ( EXPORTS_LITERAL se= symbolsExported SEMI_COLON -> $se | EXPORTS_LITERAL ALL_LITERAL SEMI_COLON )?
            {
                int alt8=3;
                switch ( LA(1) ) 
                {
                    case EXPORTS_LITERAL:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		    case ALL_LITERAL:
                    		    	{
                    		    		alt8=2;
                    		    	}
                    		        break;
                    		    case SEMI_COLON:
                    		    case IDENTIFIER:
                    		    	{
                    		    		alt8=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt8) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:159:14: EXPORTS_LITERAL se= symbolsExported SEMI_COLON
            	    {
            	        EXPORTS_LITERAL15 = (pANTLR3_COMMON_TOKEN) MATCHT(EXPORTS_LITERAL, &FOLLOW_EXPORTS_LITERAL_in_exports3474); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_EXPORTS_LITERAL; stream_EXPORTS_LITERAL->add(stream_EXPORTS_LITERAL, EXPORTS_LITERAL15, NULL); }

            	        FOLLOWPUSH(FOLLOW_symbolsExported_in_exports3478);
            	        se=symbolsExported(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_symbolsExported; stream_symbolsExported->add(stream_symbolsExported, se.tree, NULL); }
            	        SEMI_COLON16 = (pANTLR3_COMMON_TOKEN) MATCHT(SEMI_COLON, &FOLLOW_SEMI_COLON_in_exports3480); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_SEMI_COLON; stream_SEMI_COLON->add(stream_SEMI_COLON, SEMI_COLON16, NULL); }


            	         
            	        /* AST REWRITE
            	         * elements          : se
            	         * token labels      : 
            	         * rule labels       : retval, se
            	         * token list labels : 
            	         * rule list labels  : 
            	         */
            	        if ( BACKTRACKING==0 ) 
            	        {
            	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_se;

            	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	        	stream_se=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token se", se.tree != NULL ? se.tree : NULL);

            	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        	retval.tree    = root_0;
            	        	// 159:60: -> $se
            	        	{
            	        	    ADAPTOR->addChild(ADAPTOR, root_0, stream_se == NULL ? NULL : stream_se->nextTree(stream_se));

            	        	}

            	        	retval.tree = root_0; // set result root
            	        	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	        	if (stream_se != NULL) stream_se->free(stream_se);


            	        }
            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:160:8: EXPORTS_LITERAL ALL_LITERAL SEMI_COLON
            	    {
            	        EXPORTS_LITERAL17 = (pANTLR3_COMMON_TOKEN) MATCHT(EXPORTS_LITERAL, &FOLLOW_EXPORTS_LITERAL_in_exports3494); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_EXPORTS_LITERAL; stream_EXPORTS_LITERAL->add(stream_EXPORTS_LITERAL, EXPORTS_LITERAL17, NULL); }

            	        ALL_LITERAL18 = (pANTLR3_COMMON_TOKEN) MATCHT(ALL_LITERAL, &FOLLOW_ALL_LITERAL_in_exports3496); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_ALL_LITERAL; stream_ALL_LITERAL->add(stream_ALL_LITERAL, ALL_LITERAL18, NULL); }

            	        SEMI_COLON19 = (pANTLR3_COMMON_TOKEN) MATCHT(SEMI_COLON, &FOLLOW_SEMI_COLON_in_exports3498); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_SEMI_COLON; stream_SEMI_COLON->add(stream_SEMI_COLON, SEMI_COLON19, NULL); }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexportsEx; /* Prevent compiler warnings */
    ruleexportsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_EXPORTS_LITERAL != NULL) stream_EXPORTS_LITERAL->free(stream_EXPORTS_LITERAL);
        if (stream_SEMI_COLON != NULL) stream_SEMI_COLON->free(stream_SEMI_COLON);
        if (stream_ALL_LITERAL != NULL) stream_ALL_LITERAL->free(stream_ALL_LITERAL);
        if (stream_symbolsExported != NULL) stream_symbolsExported->free(stream_symbolsExported);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(5, exports_StartIndex); }

    return retval;
}
/* $ANTLR end exports */

/** 
 * $ANTLR start symbolsExported
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:163:1: symbolsExported : (sl= symbolList )? -> $sl;
 */
static asn1Parser_symbolsExported_return
symbolsExported(pasn1Parser ctx)
{   
    asn1Parser_symbolsExported_return retval;
    ANTLR3_UINT32 symbolsExported_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_symbolList_return sl;
    #undef	RETURN_TYPE_sl
    #define	RETURN_TYPE_sl asn1Parser_symbolList_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_symbolList;
    /* Initialize rule variables
     */
    symbolsExported_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(6)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    sl.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_symbolList   = NULL;
    #define CREATE_stream_symbolList  if (stream_symbolList == NULL) {stream_symbolList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule symbolList"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:163:17: ( (sl= symbolList )? -> $sl)
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:163:19: (sl= symbolList )?
        {

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:163:19: (sl= symbolList )?
            {
                int alt9=2;
                switch ( LA(1) ) 
                {
                    case IDENTIFIER:
                    	{
                    		alt9=1;
                    	}
                        break;
                }

                switch (alt9) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:163:21: sl= symbolList
            	    {
            	        FOLLOWPUSH(FOLLOW_symbolList_in_symbolsExported3514);
            	        sl=symbolList(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesymbolsExportedEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_symbolList; stream_symbolList->add(stream_symbolList, sl.tree, NULL); }

            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : sl
             * token labels      : 
             * rule labels       : sl, retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_sl;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_sl=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token sl", sl.tree != NULL ? sl.tree : NULL);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 164:1: -> $sl
            	{
            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_sl == NULL ? NULL : stream_sl->nextTree(stream_sl));

            	}

            	retval.tree = root_0; // set result root
            	if (stream_sl != NULL) stream_sl->free(stream_sl);
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesymbolsExportedEx; /* Prevent compiler warnings */
    rulesymbolsExportedEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_symbolList != NULL) stream_symbolList->free(stream_symbolList);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(6, symbolsExported_StartIndex); }

    return retval;
}
/* $ANTLR end symbolsExported */

/** 
 * $ANTLR start imports
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:167:1: imports : ( IMPORTS_LITERAL symbolsImported SEMI_COLON )? -> ( ^( IMPORTS_LITERAL symbolsImported ) )? ;
 */
static asn1Parser_imports_return
imports(pasn1Parser ctx)
{   
    asn1Parser_imports_return retval;
    ANTLR3_UINT32 imports_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IMPORTS_LITERAL20;
    pANTLR3_COMMON_TOKEN    SEMI_COLON22;
    asn1Parser_symbolsImported_return symbolsImported21;
    #undef	RETURN_TYPE_symbolsImported21
    #define	RETURN_TYPE_symbolsImported21 asn1Parser_symbolsImported_return

    pANTLR3_BASE_TREE IMPORTS_LITERAL20_tree;
    pANTLR3_BASE_TREE SEMI_COLON22_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SEMI_COLON;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IMPORTS_LITERAL;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_symbolsImported;
    /* Initialize rule variables
     */
    imports_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(7)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IMPORTS_LITERAL20       = NULL;
    SEMI_COLON22       = NULL;
    symbolsImported21.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    IMPORTS_LITERAL20_tree   = NULL;
    SEMI_COLON22_tree   = NULL;

    stream_SEMI_COLON   = NULL;
    #define CREATE_stream_SEMI_COLON  if (stream_SEMI_COLON == NULL) {stream_SEMI_COLON = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SEMI_COLON"); } 
    stream_IMPORTS_LITERAL   = NULL;
    #define CREATE_stream_IMPORTS_LITERAL  if (stream_IMPORTS_LITERAL == NULL) {stream_IMPORTS_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IMPORTS_LITERAL"); } 
    stream_symbolsImported   = NULL;
    #define CREATE_stream_symbolsImported  if (stream_symbolsImported == NULL) {stream_symbolsImported = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule symbolsImported"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:167:9: ( ( IMPORTS_LITERAL symbolsImported SEMI_COLON )? -> ( ^( IMPORTS_LITERAL symbolsImported ) )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:167:13: ( IMPORTS_LITERAL symbolsImported SEMI_COLON )?
        {

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:167:13: ( IMPORTS_LITERAL symbolsImported SEMI_COLON )?
            {
                int alt10=2;
                switch ( LA(1) ) 
                {
                    case IMPORTS_LITERAL:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:167:14: IMPORTS_LITERAL symbolsImported SEMI_COLON
            	    {
            	        IMPORTS_LITERAL20 = (pANTLR3_COMMON_TOKEN) MATCHT(IMPORTS_LITERAL, &FOLLOW_IMPORTS_LITERAL_in_imports3535); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleimportsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_IMPORTS_LITERAL; stream_IMPORTS_LITERAL->add(stream_IMPORTS_LITERAL, IMPORTS_LITERAL20, NULL); }

            	        FOLLOWPUSH(FOLLOW_symbolsImported_in_imports3537);
            	        symbolsImported21=symbolsImported(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleimportsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_symbolsImported; stream_symbolsImported->add(stream_symbolsImported, symbolsImported21.tree, NULL); }
            	        SEMI_COLON22 = (pANTLR3_COMMON_TOKEN) MATCHT(SEMI_COLON, &FOLLOW_SEMI_COLON_in_imports3539); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleimportsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_SEMI_COLON; stream_SEMI_COLON->add(stream_SEMI_COLON, SEMI_COLON22, NULL); }


            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : symbolsImported, IMPORTS_LITERAL
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 168:2: -> ( ^( IMPORTS_LITERAL symbolsImported ) )?
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:168:5: ( ^( IMPORTS_LITERAL symbolsImported ) )?
            	    {
            	    	if ( (stream_symbolsImported != NULL && stream_symbolsImported->hasNext(stream_symbolsImported)) || (stream_IMPORTS_LITERAL != NULL && stream_IMPORTS_LITERAL->hasNext(stream_IMPORTS_LITERAL))  )
            	    	{
            	    		// /secure/release14_git/mink/src/asn1/asn1c/asn1.g:168:5: ^( IMPORTS_LITERAL symbolsImported )
            	    		{
            	    		    pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	    		    root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_IMPORTS_LITERAL == NULL ? NULL : stream_IMPORTS_LITERAL->nextNode(stream_IMPORTS_LITERAL), root_1));

            	    		    ADAPTOR->addChild(ADAPTOR, root_1, stream_symbolsImported == NULL ? NULL : stream_symbolsImported->nextTree(stream_symbolsImported));

            	    		    ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    		}

            	    	}
            	    	if ( stream_symbolsImported != NULL) stream_symbolsImported->reset(stream_symbolsImported);
            	    	if ( stream_IMPORTS_LITERAL != NULL) stream_IMPORTS_LITERAL->reset(stream_IMPORTS_LITERAL);

            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleimportsEx; /* Prevent compiler warnings */
    ruleimportsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_SEMI_COLON != NULL) stream_SEMI_COLON->free(stream_SEMI_COLON);
        if (stream_IMPORTS_LITERAL != NULL) stream_IMPORTS_LITERAL->free(stream_IMPORTS_LITERAL);
        if (stream_symbolsImported != NULL) stream_symbolsImported->free(stream_symbolsImported);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(7, imports_StartIndex); }

    return retval;
}
/* $ANTLR end imports */

/** 
 * $ANTLR start symbolsImported
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:171:1: symbolsImported : ( symbolsFromModuleList )? ;
 */
static asn1Parser_symbolsImported_return
symbolsImported(pasn1Parser ctx)
{   
    asn1Parser_symbolsImported_return retval;
    ANTLR3_UINT32 symbolsImported_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_symbolsFromModuleList_return symbolsFromModuleList23;
    #undef	RETURN_TYPE_symbolsFromModuleList23
    #define	RETURN_TYPE_symbolsFromModuleList23 asn1Parser_symbolsFromModuleList_return


    /* Initialize rule variables
     */
    symbolsImported_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(8)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    symbolsFromModuleList23.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:171:17: ( ( symbolsFromModuleList )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:171:19: ( symbolsFromModuleList )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:171:19: ( symbolsFromModuleList )?
            {
                int alt11=2;
                switch ( LA(1) ) 
                {
                    case IDENTIFIER:
                    	{
                    		alt11=1;
                    	}
                        break;
                }

                switch (alt11) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:171:20: symbolsFromModuleList
            	    {
            	        FOLLOWPUSH(FOLLOW_symbolsFromModuleList_in_symbolsImported3562);
            	        symbolsFromModuleList23=symbolsFromModuleList(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesymbolsImportedEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, symbolsFromModuleList23.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesymbolsImportedEx; /* Prevent compiler warnings */
    rulesymbolsImportedEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(8, symbolsImported_StartIndex); }

    return retval;
}
/* $ANTLR end symbolsImported */

/** 
 * $ANTLR start symbolsFromModuleList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:174:1: symbolsFromModuleList : ( symbolsFromModule ) ( symbolsFromModule )* ;
 */
static asn1Parser_symbolsFromModuleList_return
symbolsFromModuleList(pasn1Parser ctx)
{   
    asn1Parser_symbolsFromModuleList_return retval;
    ANTLR3_UINT32 symbolsFromModuleList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_symbolsFromModule_return symbolsFromModule24;
    #undef	RETURN_TYPE_symbolsFromModule24
    #define	RETURN_TYPE_symbolsFromModule24 asn1Parser_symbolsFromModule_return

    asn1Parser_symbolsFromModule_return symbolsFromModule25;
    #undef	RETURN_TYPE_symbolsFromModule25
    #define	RETURN_TYPE_symbolsFromModule25 asn1Parser_symbolsFromModule_return


    /* Initialize rule variables
     */
    symbolsFromModuleList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(9)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    symbolsFromModule24.tree = NULL;

    symbolsFromModule25.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:174:23: ( ( symbolsFromModule ) ( symbolsFromModule )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:175:6: ( symbolsFromModule ) ( symbolsFromModule )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:175:6: ( symbolsFromModule )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:175:7: symbolsFromModule
            {
                FOLLOWPUSH(FOLLOW_symbolsFromModule_in_symbolsFromModuleList3583);
                symbolsFromModule24=symbolsFromModule(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulesymbolsFromModuleListEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, symbolsFromModule24.tree);

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:175:26: ( symbolsFromModule )*

            for (;;)
            {
                int alt12=2;
                switch ( LA(1) ) 
                {
                case IDENTIFIER:
                	{
                		alt12=1;
                	}
                    break;

                }

                switch (alt12) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:175:27: symbolsFromModule
            	    {
            	        FOLLOWPUSH(FOLLOW_symbolsFromModule_in_symbolsFromModuleList3587);
            	        symbolsFromModule25=symbolsFromModule(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesymbolsFromModuleListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, symbolsFromModule25.tree);

            	    }
            	    break;

            	default:
            	    goto loop12;	/* break out of the loop */
            	    break;
                }
            }
            loop12: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesymbolsFromModuleListEx; /* Prevent compiler warnings */
    rulesymbolsFromModuleListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(9, symbolsFromModuleList_StartIndex); }

    return retval;
}
/* $ANTLR end symbolsFromModuleList */

/** 
 * $ANTLR start symbolsFromModule
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:178:1: symbolsFromModule : symbolList FROM_LITERAL globalModuleReference -> symbolList ^( FROM_LITERAL globalModuleReference ) ;
 */
static asn1Parser_symbolsFromModule_return
symbolsFromModule(pasn1Parser ctx)
{   
    asn1Parser_symbolsFromModule_return retval;
    ANTLR3_UINT32 symbolsFromModule_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    FROM_LITERAL27;
    asn1Parser_symbolList_return symbolList26;
    #undef	RETURN_TYPE_symbolList26
    #define	RETURN_TYPE_symbolList26 asn1Parser_symbolList_return

    asn1Parser_globalModuleReference_return globalModuleReference28;
    #undef	RETURN_TYPE_globalModuleReference28
    #define	RETURN_TYPE_globalModuleReference28 asn1Parser_globalModuleReference_return

    pANTLR3_BASE_TREE FROM_LITERAL27_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_FROM_LITERAL;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_globalModuleReference;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_symbolList;
    /* Initialize rule variables
     */
    symbolsFromModule_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(10)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    FROM_LITERAL27       = NULL;
    symbolList26.tree = NULL;

    globalModuleReference28.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    FROM_LITERAL27_tree   = NULL;

    stream_FROM_LITERAL   = NULL;
    #define CREATE_stream_FROM_LITERAL  if (stream_FROM_LITERAL == NULL) {stream_FROM_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token FROM_LITERAL"); } 
    stream_globalModuleReference   = NULL;
    #define CREATE_stream_globalModuleReference  if (stream_globalModuleReference == NULL) {stream_globalModuleReference = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule globalModuleReference"); }
    stream_symbolList   = NULL;
    #define CREATE_stream_symbolList  if (stream_symbolList == NULL) {stream_symbolList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule symbolList"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:178:19: ( symbolList FROM_LITERAL globalModuleReference -> symbolList ^( FROM_LITERAL globalModuleReference ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:178:21: symbolList FROM_LITERAL globalModuleReference
        {
            FOLLOWPUSH(FOLLOW_symbolList_in_symbolsFromModule3599);
            symbolList26=symbolList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesymbolsFromModuleEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_symbolList; stream_symbolList->add(stream_symbolList, symbolList26.tree, NULL); }
            FROM_LITERAL27 = (pANTLR3_COMMON_TOKEN) MATCHT(FROM_LITERAL, &FOLLOW_FROM_LITERAL_in_symbolsFromModule3601); 
            if  (HASEXCEPTION())
            {
                goto rulesymbolsFromModuleEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_FROM_LITERAL; stream_FROM_LITERAL->add(stream_FROM_LITERAL, FROM_LITERAL27, NULL); }

            FOLLOWPUSH(FOLLOW_globalModuleReference_in_symbolsFromModule3603);
            globalModuleReference28=globalModuleReference(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesymbolsFromModuleEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_globalModuleReference; stream_globalModuleReference->add(stream_globalModuleReference, globalModuleReference28.tree, NULL); }

             
            /* AST REWRITE
             * elements          : globalModuleReference, FROM_LITERAL, symbolList
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 178:67: -> symbolList ^( FROM_LITERAL globalModuleReference )
            	{
            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_symbolList == NULL ? NULL : stream_symbolList->nextTree(stream_symbolList));
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:178:81: ^( FROM_LITERAL globalModuleReference )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_FROM_LITERAL == NULL ? NULL : stream_FROM_LITERAL->nextNode(stream_FROM_LITERAL), root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_globalModuleReference == NULL ? NULL : stream_globalModuleReference->nextTree(stream_globalModuleReference));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesymbolsFromModuleEx; /* Prevent compiler warnings */
    rulesymbolsFromModuleEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_FROM_LITERAL != NULL) stream_FROM_LITERAL->free(stream_FROM_LITERAL);
        if (stream_globalModuleReference != NULL) stream_globalModuleReference->free(stream_globalModuleReference);
        if (stream_symbolList != NULL) stream_symbolList->free(stream_symbolList);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(10, symbolsFromModule_StartIndex); }

    return retval;
}
/* $ANTLR end symbolsFromModule */

/** 
 * $ANTLR start globalModuleReference
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:181:1: globalModuleReference : IDENTIFIER assignedIdentifier ( L_BRACE ( ( IDENTIFIER | NUMBER ) ( L_PARAN NUMBER R_PARAN )? )* R_BRACE )? ;
 */
static asn1Parser_globalModuleReference_return
globalModuleReference(pasn1Parser ctx)
{   
    asn1Parser_globalModuleReference_return retval;
    ANTLR3_UINT32 globalModuleReference_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER29;
    pANTLR3_COMMON_TOKEN    L_BRACE31;
    pANTLR3_COMMON_TOKEN    set32;
    pANTLR3_COMMON_TOKEN    L_PARAN33;
    pANTLR3_COMMON_TOKEN    NUMBER34;
    pANTLR3_COMMON_TOKEN    R_PARAN35;
    pANTLR3_COMMON_TOKEN    R_BRACE36;
    asn1Parser_assignedIdentifier_return assignedIdentifier30;
    #undef	RETURN_TYPE_assignedIdentifier30
    #define	RETURN_TYPE_assignedIdentifier30 asn1Parser_assignedIdentifier_return

    pANTLR3_BASE_TREE IDENTIFIER29_tree;
    pANTLR3_BASE_TREE L_BRACE31_tree;
    pANTLR3_BASE_TREE set32_tree;
    pANTLR3_BASE_TREE L_PARAN33_tree;
    pANTLR3_BASE_TREE NUMBER34_tree;
    pANTLR3_BASE_TREE R_PARAN35_tree;
    pANTLR3_BASE_TREE R_BRACE36_tree;

    /* Initialize rule variables
     */
    globalModuleReference_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(11)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IDENTIFIER29       = NULL;
    L_BRACE31       = NULL;
    set32       = NULL;
    L_PARAN33       = NULL;
    NUMBER34       = NULL;
    R_PARAN35       = NULL;
    R_BRACE36       = NULL;
    assignedIdentifier30.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER29_tree   = NULL;
    L_BRACE31_tree   = NULL;
    set32_tree   = NULL;
    L_PARAN33_tree   = NULL;
    NUMBER34_tree   = NULL;
    R_PARAN35_tree   = NULL;
    R_BRACE36_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:181:23: ( IDENTIFIER assignedIdentifier ( L_BRACE ( ( IDENTIFIER | NUMBER ) ( L_PARAN NUMBER R_PARAN )? )* R_BRACE )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:181:25: IDENTIFIER assignedIdentifier ( L_BRACE ( ( IDENTIFIER | NUMBER ) ( L_PARAN NUMBER R_PARAN )? )* R_BRACE )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER29 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_globalModuleReference3622); 
            if  (HASEXCEPTION())
            {
                goto ruleglobalModuleReferenceEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER29_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER29));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER29_tree);
            }
            FOLLOWPUSH(FOLLOW_assignedIdentifier_in_globalModuleReference3624);
            assignedIdentifier30=assignedIdentifier(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleglobalModuleReferenceEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, assignedIdentifier30.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:181:55: ( L_BRACE ( ( IDENTIFIER | NUMBER ) ( L_PARAN NUMBER R_PARAN )? )* R_BRACE )?
            {
                int alt15=2;
                switch ( LA(1) ) 
                {
                    case L_BRACE:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:181:56: L_BRACE ( ( IDENTIFIER | NUMBER ) ( L_PARAN NUMBER R_PARAN )? )* R_BRACE
            	    {
            	        L_BRACE31 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_globalModuleReference3627); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglobalModuleReferenceEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:181:65: ( ( IDENTIFIER | NUMBER ) ( L_PARAN NUMBER R_PARAN )? )*

            	        for (;;)
            	        {
            	            int alt14=2;
            	            switch ( LA(1) ) 
            	            {
            	            case IDENTIFIER:
            	            case NUMBER:
            	            	{
            	            		alt14=1;
            	            	}
            	                break;

            	            }

            	            switch (alt14) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:181:66: ( IDENTIFIER | NUMBER ) ( L_PARAN NUMBER R_PARAN )?
            	        	    {
            	        	        set32=(pANTLR3_COMMON_TOKEN)LT(1);
            	        	        if ( ((LA(1) >= IDENTIFIER) && (LA(1) <= NUMBER)) )
            	        	        {
            	        	            CONSUME();
            	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set32)));
            	        	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            	        	        }
            	        	        else 
            	        	        {
            	        	            if (BACKTRACKING>0)
            	        	            {
            	        	                FAILEDFLAG = ANTLR3_TRUE;
            	        	                return retval;
            	        	            }
            	        	            CONSTRUCTEX();
            	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	        	            EXCEPTION->expectingSet = &FOLLOW_set_in_globalModuleReference3631;
            	        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_globalModuleReference3631);    goto ruleglobalModuleReferenceEx;
            	        	        }


            	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:181:88: ( L_PARAN NUMBER R_PARAN )?
            	        	        {
            	        	            int alt13=2;
            	        	            switch ( LA(1) ) 
            	        	            {
            	        	                case L_PARAN:
            	        	                	{
            	        	                		alt13=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt13) 
            	        	            {
            	        	        	case 1:
            	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:181:89: L_PARAN NUMBER R_PARAN
            	        	        	    {
            	        	        	        L_PARAN33 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_globalModuleReference3640); 
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleglobalModuleReferenceEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }
            	        	        	        NUMBER34 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_globalModuleReference3643); 
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleglobalModuleReferenceEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }
            	        	        	        if ( BACKTRACKING==0 ) {
            	        	        	        NUMBER34_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER34));
            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER34_tree);
            	        	        	        }
            	        	        	        R_PARAN35 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_globalModuleReference3645); 
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleglobalModuleReferenceEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop14;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop14: ; /* Jump out to here if this rule does not match */

            	        R_BRACE36 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_globalModuleReference3652); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglobalModuleReferenceEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleglobalModuleReferenceEx; /* Prevent compiler warnings */
    ruleglobalModuleReferenceEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(11, globalModuleReference_StartIndex); }

    return retval;
}
/* $ANTLR end globalModuleReference */

/** 
 * $ANTLR start assignedIdentifier
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:184:1: assignedIdentifier : ;
 */
static asn1Parser_assignedIdentifier_return
assignedIdentifier(pasn1Parser ctx)
{   
    asn1Parser_assignedIdentifier_return retval;
    ANTLR3_UINT32 assignedIdentifier_StartIndex;
    pANTLR3_BASE_TREE root_0;

    /* Initialize rule variables
     */
    assignedIdentifier_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(12)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:184:20: ()
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:185:1: 
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleassignedIdentifierEx; /* Prevent compiler warnings */
    ruleassignedIdentifierEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

    if ( BACKTRACKING>0 ) { MEMOIZE(12, assignedIdentifier_StartIndex); }

    return retval;
}
/* $ANTLR end assignedIdentifier */

/** 
 * $ANTLR start symbolList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:187:1: symbolList : (smb1= symbol ) ( COMMA smb2+= symbol )* -> $smb1 ( $smb2)* ;
 */
static asn1Parser_symbolList_return
symbolList(pasn1Parser ctx)
{   
    asn1Parser_symbolList_return retval;
    ANTLR3_UINT32 symbolList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA37;
    pANTLR3_VECTOR    list_smb2;
    asn1Parser_symbol_return smb1;
    #undef	RETURN_TYPE_smb1
    #define	RETURN_TYPE_smb1 asn1Parser_symbol_return

    asn1Parser_symbol_return smb2;
    #undef	RETURN_TYPE_smb2
    #define	RETURN_TYPE_smb2 asn1Parser_symbol_return

    pANTLR3_BASE_TREE COMMA37_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_COMMA;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_symbol;
    /* Initialize rule variables
     */
    symbolList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(13)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA37       = NULL;
    list_smb2     = NULL;
    smb1.tree = NULL;

    smb2.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA37_tree   = NULL;

    stream_COMMA   = NULL;
    #define CREATE_stream_COMMA  if (stream_COMMA == NULL) {stream_COMMA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token COMMA"); } 
    stream_symbol   = NULL;
    #define CREATE_stream_symbol  if (stream_symbol == NULL) {stream_symbol = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule symbol"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:187:14: ( (smb1= symbol ) ( COMMA smb2+= symbol )* -> $smb1 ( $smb2)* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:187:16: (smb1= symbol ) ( COMMA smb2+= symbol )*
        {
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:187:16: (smb1= symbol )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:187:17: smb1= symbol
            {
                FOLLOWPUSH(FOLLOW_symbol_in_symbolList3677);
                smb1=symbol(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulesymbolListEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) { CREATE_stream_symbol; stream_symbol->add(stream_symbol, smb1.tree, NULL); }

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:187:30: ( COMMA smb2+= symbol )*

            for (;;)
            {
                int alt16=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt16=1;
                	}
                    break;

                }

                switch (alt16) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:187:31: COMMA smb2+= symbol
            	    {
            	        COMMA37 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_symbolList3681); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesymbolListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_COMMA; stream_COMMA->add(stream_COMMA, COMMA37, NULL); }

            	        FOLLOWPUSH(FOLLOW_symbol_in_symbolList3685);
            	        smb2=symbol(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesymbolListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_symbol; stream_symbol->add(stream_symbol, smb2.tree, NULL); }
            	        /* listLabelTrack(label)
            	         */
            	        if (list_smb2 == NULL)
            	        {
            	            list_smb2=ctx->vectors->newVector(ctx->vectors);
            	        }
            	        list_smb2->add(list_smb2, smb2.tree, NULL);

            	    }
            	    break;

            	default:
            	    goto loop16;	/* break out of the loop */
            	    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


             
            /* AST REWRITE
             * elements          : smb2, smb1
             * token labels      : 
             * rule labels       : retval, smb1
             * token list labels : 
             * rule list labels  : smb2
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_smb1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_smb2;
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_smb1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token smb1", smb1.tree != NULL ? smb1.tree : NULL);
            	stream_smb2=antlr3RewriteRuleSubtreeStreamNewAEV(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token smb2", list_smb2);
            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 187:52: -> $smb1 ( $smb2)*
            	{
            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_smb1 == NULL ? NULL : stream_smb1->nextTree(stream_smb1));
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:187:61: ( $smb2)*
            	    {
            	    	while ( (stream_smb2 != NULL && stream_smb2->hasNext(stream_smb2))  )
            	    	{
            	    		ADAPTOR->addChild(ADAPTOR, root_0, stream_smb2 == NULL ? NULL : stream_smb2->nextTree(stream_smb2));

            	    	}
            	    	if (stream_smb2 != NULL) stream_smb2->reset(stream_smb2);

            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_smb1 != NULL) stream_smb1->free(stream_smb1);
            	if (stream_smb2 != NULL) stream_smb2->free(stream_smb2);

            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesymbolListEx; /* Prevent compiler warnings */
    rulesymbolListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_COMMA != NULL) stream_COMMA->free(stream_COMMA);
        if (stream_symbol != NULL) stream_symbol->free(stream_symbol);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(13, symbolList_StartIndex); }

    return retval;
}
/* $ANTLR end symbolList */

/** 
 * $ANTLR start symbol
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:190:1: symbol : id= IDENTIFIER ( ( L_BRACE R_BRACE ) )? -> $id;
 */
static asn1Parser_symbol_return
symbol(pasn1Parser ctx)
{   
    asn1Parser_symbol_return retval;
    ANTLR3_UINT32 symbol_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    id;
    pANTLR3_COMMON_TOKEN    L_BRACE38;
    pANTLR3_COMMON_TOKEN    R_BRACE39;

    pANTLR3_BASE_TREE id_tree;
    pANTLR3_BASE_TREE L_BRACE38_tree;
    pANTLR3_BASE_TREE R_BRACE39_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;

    /* Initialize rule variables
     */
    symbol_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(14)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    id       = NULL;
    L_BRACE38       = NULL;
    R_BRACE39       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    id_tree   = NULL;
    L_BRACE38_tree   = NULL;
    R_BRACE39_tree   = NULL;

    stream_L_BRACE   = NULL;
    #define CREATE_stream_L_BRACE  if (stream_L_BRACE == NULL) {stream_L_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_BRACE"); } 
    stream_R_BRACE   = NULL;
    #define CREATE_stream_R_BRACE  if (stream_R_BRACE == NULL) {stream_R_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_BRACE"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:190:9: (id= IDENTIFIER ( ( L_BRACE R_BRACE ) )? -> $id)
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:190:11: id= IDENTIFIER ( ( L_BRACE R_BRACE ) )?
        {
            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_symbol3708); 
            if  (HASEXCEPTION())
            {
                goto rulesymbolEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, id, NULL); }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:190:25: ( ( L_BRACE R_BRACE ) )?
            {
                int alt17=2;
                switch ( LA(1) ) 
                {
                    case L_BRACE:
                    	{
                    		alt17=1;
                    	}
                        break;
                }

                switch (alt17) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:190:26: ( L_BRACE R_BRACE )
            	    {
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:190:26: ( L_BRACE R_BRACE )
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:190:27: L_BRACE R_BRACE
            	        {
            	            L_BRACE38 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_symbol3712); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesymbolEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            } 
            	            if ( BACKTRACKING==0 ) { CREATE_stream_L_BRACE; stream_L_BRACE->add(stream_L_BRACE, L_BRACE38, NULL); }

            	            R_BRACE39 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_symbol3715); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesymbolEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            } 
            	            if ( BACKTRACKING==0 ) { CREATE_stream_R_BRACE; stream_R_BRACE->add(stream_R_BRACE, R_BRACE39, NULL); }


            	        }


            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : id
             * token labels      : id
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_id;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_id=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token id", id);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 191:1: -> $id
            	{
            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_id == NULL ? NULL : stream_id->nextNode(stream_id));

            	}

            	retval.tree = root_0; // set result root
            	if (stream_id != NULL) stream_id->free(stream_id); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesymbolEx; /* Prevent compiler warnings */
    rulesymbolEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_L_BRACE != NULL) stream_L_BRACE->free(stream_L_BRACE);
        if (stream_R_BRACE != NULL) stream_R_BRACE->free(stream_R_BRACE);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(14, symbol_StartIndex); }

    return retval;
}
/* $ANTLR end symbol */

/** 
 * $ANTLR start assignmentList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:195:1: assignmentList : (as1= assignment ) (as2+= assignment )* -> ^( TAG_DEFINITIONS $as1 ( $as2)* ) ;
 */
static asn1Parser_assignmentList_return
assignmentList(pasn1Parser ctx)
{   
    asn1Parser_assignmentList_return retval;
    ANTLR3_UINT32 assignmentList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_VECTOR    list_as2;
    asn1Parser_assignment_return as1;
    #undef	RETURN_TYPE_as1
    #define	RETURN_TYPE_as1 asn1Parser_assignment_return

    asn1Parser_assignment_return as2;
    #undef	RETURN_TYPE_as2
    #define	RETURN_TYPE_as2 asn1Parser_assignment_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_assignment;
    /* Initialize rule variables
     */
    assignmentList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(15)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    list_as2     = NULL;
    as1.tree = NULL;

    as2.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_assignment   = NULL;
    #define CREATE_stream_assignment  if (stream_assignment == NULL) {stream_assignment = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule assignment"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:195:16: ( (as1= assignment ) (as2+= assignment )* -> ^( TAG_DEFINITIONS $as1 ( $as2)* ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:195:19: (as1= assignment ) (as2+= assignment )*
        {
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:195:19: (as1= assignment )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:195:20: as1= assignment
            {
                FOLLOWPUSH(FOLLOW_assignment_in_assignmentList3738);
                as1=assignment(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleassignmentListEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) { CREATE_stream_assignment; stream_assignment->add(stream_assignment, as1.tree, NULL); }

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:195:36: (as2+= assignment )*

            for (;;)
            {
                int alt18=2;
                switch ( LA(1) ) 
                {
                case IDENTIFIER:
                	{
                		alt18=1;
                	}
                    break;

                }

                switch (alt18) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:195:37: as2+= assignment
            	    {
            	        FOLLOWPUSH(FOLLOW_assignment_in_assignmentList3744);
            	        as2=assignment(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleassignmentListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_assignment; stream_assignment->add(stream_assignment, as2.tree, NULL); }
            	        /* listLabelTrack(label)
            	         */
            	        if (list_as2 == NULL)
            	        {
            	            list_as2=ctx->vectors->newVector(ctx->vectors);
            	        }
            	        list_as2->add(list_as2, as2.tree, NULL);

            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */


             
            /* AST REWRITE
             * elements          : as2, as1
             * token labels      : 
             * rule labels       : retval, as1
             * token list labels : 
             * rule list labels  : as2
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_as1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_as2;
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_as1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token as1", as1.tree != NULL ? as1.tree : NULL);
            	stream_as2=antlr3RewriteRuleSubtreeStreamNewAEV(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token as2", list_as2);
            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 196:1: -> ^( TAG_DEFINITIONS $as1 ( $as2)* )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:196:4: ^( TAG_DEFINITIONS $as1 ( $as2)* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TAG_DEFINITIONS, (pANTLR3_UINT8)"TAG_DEFINITIONS"), root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_as1 == NULL ? NULL : stream_as1->nextTree(stream_as1));
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:196:27: ( $as2)*
            	        {
            	        	while ( (stream_as2 != NULL && stream_as2->hasNext(stream_as2))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_as2 == NULL ? NULL : stream_as2->nextTree(stream_as2));

            	        	}
            	        	if (stream_as2 != NULL) stream_as2->reset(stream_as2);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_as1 != NULL) stream_as1->free(stream_as1);
            	if (stream_as2 != NULL) stream_as2->free(stream_as2);

            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleassignmentListEx; /* Prevent compiler warnings */
    ruleassignmentListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_assignment != NULL) stream_assignment->free(stream_assignment);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(15, assignmentList_StartIndex); }

    return retval;
}
/* $ANTLR end assignmentList */

/** 
 * $ANTLR start assignment
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:200:1: assignment : (id= IDENTIFIER (as1= valueAssignment | as2= typeAssignment | as3= parameterizedAssignment | as4= objectClassAssignment ) ) -> ^( $id ( $as1)? ( $as2)? ( $as3)? ( $as4)? ) ;
 */
static asn1Parser_assignment_return
assignment(pasn1Parser ctx)
{   
    asn1Parser_assignment_return retval;
    ANTLR3_UINT32 assignment_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    id;
    asn1Parser_valueAssignment_return as1;
    #undef	RETURN_TYPE_as1
    #define	RETURN_TYPE_as1 asn1Parser_valueAssignment_return

    asn1Parser_typeAssignment_return as2;
    #undef	RETURN_TYPE_as2
    #define	RETURN_TYPE_as2 asn1Parser_typeAssignment_return

    asn1Parser_parameterizedAssignment_return as3;
    #undef	RETURN_TYPE_as3
    #define	RETURN_TYPE_as3 asn1Parser_parameterizedAssignment_return

    asn1Parser_objectClassAssignment_return as4;
    #undef	RETURN_TYPE_as4
    #define	RETURN_TYPE_as4 asn1Parser_objectClassAssignment_return

    pANTLR3_BASE_TREE id_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_valueAssignment;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_objectClassAssignment;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typeAssignment;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_parameterizedAssignment;
    /* Initialize rule variables
     */
    assignment_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(16)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    id       = NULL;
    as1.tree = NULL;

    as2.tree = NULL;

    as3.tree = NULL;

    as4.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    id_tree   = NULL;

    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_valueAssignment   = NULL;
    #define CREATE_stream_valueAssignment  if (stream_valueAssignment == NULL) {stream_valueAssignment = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule valueAssignment"); }
    stream_objectClassAssignment   = NULL;
    #define CREATE_stream_objectClassAssignment  if (stream_objectClassAssignment == NULL) {stream_objectClassAssignment = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule objectClassAssignment"); }
    stream_typeAssignment   = NULL;
    #define CREATE_stream_typeAssignment  if (stream_typeAssignment == NULL) {stream_typeAssignment = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule typeAssignment"); }
    stream_parameterizedAssignment   = NULL;
    #define CREATE_stream_parameterizedAssignment  if (stream_parameterizedAssignment == NULL) {stream_parameterizedAssignment = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule parameterizedAssignment"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:200:12: ( (id= IDENTIFIER (as1= valueAssignment | as2= typeAssignment | as3= parameterizedAssignment | as4= objectClassAssignment ) ) -> ^( $id ( $as1)? ( $as2)? ( $as3)? ( $as4)? ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:201:2: (id= IDENTIFIER (as1= valueAssignment | as2= typeAssignment | as3= parameterizedAssignment | as4= objectClassAssignment ) )
        {
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:201:2: (id= IDENTIFIER (as1= valueAssignment | as2= typeAssignment | as3= parameterizedAssignment | as4= objectClassAssignment ) )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:201:3: id= IDENTIFIER (as1= valueAssignment | as2= typeAssignment | as3= parameterizedAssignment | as4= objectClassAssignment )
            {
                id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_assignment3774); 
                if  (HASEXCEPTION())
                {
                    goto ruleassignmentEx;
                }
                if (HASFAILED())
                {
                    return retval;
                } 
                if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, id, NULL); }


                // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:202:3: (as1= valueAssignment | as2= typeAssignment | as3= parameterizedAssignment | as4= objectClassAssignment )
                {
                    int alt19=4;
                    switch ( LA(1) ) 
                    {
                    case BOOLEAN_LITERAL:
                    case INTEGER_LITERAL:
                    case IA5_STRING_LITERAL:
                    case ENUMERATED_LITERAL:
                    case BIT_LITERAL:
                    case OCTET_LITERAL:
                    case NULL_LITERAL:
                    case SEQUENCE_LITERAL:
                    case SET_LITERAL:
                    case L_BRACKET:
                    case CHOICE_LITERAL:
                    case OBJECT_LITERAL:
                    	{
                    		alt19=1;
                    	}
                        break;
                    case IDENTIFIER:
                    	{

                    		{
                    		    int LA19_13 = LA(2);
                    		    if ( (synpred23_asn1(ctx)) ) 
                    		    {
                    		        alt19=1;
                    		    }
                    		    else if ( (synpred25_asn1(ctx)) ) 
                    		    {
                    		        alt19=3;
                    		    }
                    		    else 
                    		    {
                    		        if (BACKTRACKING>0)
                    		        {
                    		            FAILEDFLAG = ANTLR3_TRUE;
                    		            return retval;
                    		        }
                    		    
                    		        CONSTRUCTEX();
                    		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    		        EXCEPTION->message      = (void *)"";
                    		        EXCEPTION->decisionNum  = 19;
                    		        EXCEPTION->state        = 13;


                    		        goto ruleassignmentEx;
                    		    }
                    		}
                    	}
                        break;
                    case TYPE_IDENTIFIER_LITERAL:
                    	{

                    		{
                    		    int LA19_14 = LA(2);
                    		    if ( (synpred23_asn1(ctx)) ) 
                    		    {
                    		        alt19=1;
                    		    }
                    		    else if ( (synpred25_asn1(ctx)) ) 
                    		    {
                    		        alt19=3;
                    		    }
                    		    else 
                    		    {
                    		        if (BACKTRACKING>0)
                    		        {
                    		            FAILEDFLAG = ANTLR3_TRUE;
                    		            return retval;
                    		        }
                    		    
                    		        CONSTRUCTEX();
                    		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    		        EXCEPTION->message      = (void *)"";
                    		        EXCEPTION->decisionNum  = 19;
                    		        EXCEPTION->state        = 14;


                    		        goto ruleassignmentEx;
                    		    }
                    		}
                    	}
                        break;
                    case ABSTRACT_SYNTAX_LITERAL:
                    	{

                    		{
                    		    int LA19_15 = LA(2);
                    		    if ( (synpred23_asn1(ctx)) ) 
                    		    {
                    		        alt19=1;
                    		    }
                    		    else if ( (synpred25_asn1(ctx)) ) 
                    		    {
                    		        alt19=3;
                    		    }
                    		    else 
                    		    {
                    		        if (BACKTRACKING>0)
                    		        {
                    		            FAILEDFLAG = ANTLR3_TRUE;
                    		            return retval;
                    		        }
                    		    
                    		        CONSTRUCTEX();
                    		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    		        EXCEPTION->message      = (void *)"";
                    		        EXCEPTION->decisionNum  = 19;
                    		        EXCEPTION->state        = 15;


                    		        goto ruleassignmentEx;
                    		    }
                    		}
                    	}
                        break;
                    case ASSIGN_OP:
                    	{

                    		{
                    		    int LA19_16 = LA(2);
                    		    if ( (synpred24_asn1(ctx)) ) 
                    		    {
                    		        alt19=2;
                    		    }
                    		    else if ( (ANTLR3_TRUE) ) 
                    		    {
                    		        alt19=4;
                    		    }
                    		    else 
                    		    {
                    		        if (BACKTRACKING>0)
                    		        {
                    		            FAILEDFLAG = ANTLR3_TRUE;
                    		            return retval;
                    		        }
                    		    
                    		        CONSTRUCTEX();
                    		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    		        EXCEPTION->message      = (void *)"";
                    		        EXCEPTION->decisionNum  = 19;
                    		        EXCEPTION->state        = 16;


                    		        goto ruleassignmentEx;
                    		    }
                    		}
                    	}
                        break;
                    case L_BRACE:
                    	{
                    		alt19=3;
                    	}
                        break;

                    default:
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE;
                            return retval;
                        }
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 19;
                        EXCEPTION->state        = 0;


                        goto ruleassignmentEx;
                    }

                    switch (alt19) 
                    {
                	case 1:
                	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:202:6: as1= valueAssignment
                	    {
                	        FOLLOWPUSH(FOLLOW_valueAssignment_in_assignment3783);
                	        as1=valueAssignment(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleassignmentEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }
                	        if ( BACKTRACKING==0 ) { CREATE_stream_valueAssignment; stream_valueAssignment->add(stream_valueAssignment, as1.tree, NULL); }

                	    }
                	    break;
                	case 2:
                	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:203:5: as2= typeAssignment
                	    {
                	        FOLLOWPUSH(FOLLOW_typeAssignment_in_assignment3792);
                	        as2=typeAssignment(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleassignmentEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }
                	        if ( BACKTRACKING==0 ) { CREATE_stream_typeAssignment; stream_typeAssignment->add(stream_typeAssignment, as2.tree, NULL); }

                	    }
                	    break;
                	case 3:
                	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:204:5: as3= parameterizedAssignment
                	    {
                	        FOLLOWPUSH(FOLLOW_parameterizedAssignment_in_assignment3800);
                	        as3=parameterizedAssignment(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleassignmentEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }
                	        if ( BACKTRACKING==0 ) { CREATE_stream_parameterizedAssignment; stream_parameterizedAssignment->add(stream_parameterizedAssignment, as3.tree, NULL); }

                	    }
                	    break;
                	case 4:
                	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:205:5: as4= objectClassAssignment
                	    {
                	        FOLLOWPUSH(FOLLOW_objectClassAssignment_in_assignment3809);
                	        as4=objectClassAssignment(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleassignmentEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }
                	        if ( BACKTRACKING==0 ) { CREATE_stream_objectClassAssignment; stream_objectClassAssignment->add(stream_objectClassAssignment, as4.tree, NULL); }

                	    }
                	    break;

                    }
                }

            }


             
            /* AST REWRITE
             * elements          : id, as2, as1, as3, as4
             * token labels      : id
             * rule labels       : retval, as4, as2, as3, as1
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_id;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_as4;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_as2;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_as3;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_as1;

            	stream_id=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token id", id);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_as4=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token as4", as4.tree != NULL ? as4.tree : NULL);
            	stream_as2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token as2", as2.tree != NULL ? as2.tree : NULL);
            	stream_as3=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token as3", as3.tree != NULL ? as3.tree : NULL);
            	stream_as1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token as1", as1.tree != NULL ? as1.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 209:2: -> ^( $id ( $as1)? ( $as2)? ( $as3)? ( $as4)? )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:209:5: ^( $id ( $as1)? ( $as2)? ( $as3)? ( $as4)? )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRootToken(ADAPTOR, stream_id == NULL ? NULL : stream_id->nextToken(stream_id), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:209:11: ( $as1)?
            	        {
            	        	if ( (stream_as1 != NULL && stream_as1->hasNext(stream_as1))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_as1 == NULL ? NULL : stream_as1->nextTree(stream_as1));

            	        	}
            	        	if ( stream_as1 != NULL) stream_as1->reset(stream_as1);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:209:17: ( $as2)?
            	        {
            	        	if ( (stream_as2 != NULL && stream_as2->hasNext(stream_as2))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_as2 == NULL ? NULL : stream_as2->nextTree(stream_as2));

            	        	}
            	        	if ( stream_as2 != NULL) stream_as2->reset(stream_as2);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:209:23: ( $as3)?
            	        {
            	        	if ( (stream_as3 != NULL && stream_as3->hasNext(stream_as3))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_as3 == NULL ? NULL : stream_as3->nextTree(stream_as3));

            	        	}
            	        	if ( stream_as3 != NULL) stream_as3->reset(stream_as3);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:209:29: ( $as4)?
            	        {
            	        	if ( (stream_as4 != NULL && stream_as4->hasNext(stream_as4))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_as4 == NULL ? NULL : stream_as4->nextTree(stream_as4));

            	        	}
            	        	if ( stream_as4 != NULL) stream_as4->reset(stream_as4);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_id != NULL) stream_id->free(stream_id); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_as4 != NULL) stream_as4->free(stream_as4);
            	if (stream_as2 != NULL) stream_as2->free(stream_as2);
            	if (stream_as3 != NULL) stream_as3->free(stream_as3);
            	if (stream_as1 != NULL) stream_as1->free(stream_as1);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleassignmentEx; /* Prevent compiler warnings */
    ruleassignmentEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_valueAssignment != NULL) stream_valueAssignment->free(stream_valueAssignment);
        if (stream_objectClassAssignment != NULL) stream_objectClassAssignment->free(stream_objectClassAssignment);
        if (stream_typeAssignment != NULL) stream_typeAssignment->free(stream_typeAssignment);
        if (stream_parameterizedAssignment != NULL) stream_parameterizedAssignment->free(stream_parameterizedAssignment);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(16, assignment_StartIndex); }

    return retval;
}
/* $ANTLR end assignment */

/** 
 * $ANTLR start sequenceType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:212:1: sequenceType : SEQUENCE_LITERAL L_BRACE ( extensionAndException optionalExtensionMarker | componentTypeLists )? R_BRACE -> ^( SEQUENCE_LITERAL ( extensionAndException )? ( optionalExtensionMarker )? ( componentTypeLists )? ) ;
 */
static asn1Parser_sequenceType_return
sequenceType(pasn1Parser ctx)
{   
    asn1Parser_sequenceType_return retval;
    ANTLR3_UINT32 sequenceType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SEQUENCE_LITERAL40;
    pANTLR3_COMMON_TOKEN    L_BRACE41;
    pANTLR3_COMMON_TOKEN    R_BRACE45;
    asn1Parser_extensionAndException_return extensionAndException42;
    #undef	RETURN_TYPE_extensionAndException42
    #define	RETURN_TYPE_extensionAndException42 asn1Parser_extensionAndException_return

    asn1Parser_optionalExtensionMarker_return optionalExtensionMarker43;
    #undef	RETURN_TYPE_optionalExtensionMarker43
    #define	RETURN_TYPE_optionalExtensionMarker43 asn1Parser_optionalExtensionMarker_return

    asn1Parser_componentTypeLists_return componentTypeLists44;
    #undef	RETURN_TYPE_componentTypeLists44
    #define	RETURN_TYPE_componentTypeLists44 asn1Parser_componentTypeLists_return

    pANTLR3_BASE_TREE SEQUENCE_LITERAL40_tree;
    pANTLR3_BASE_TREE L_BRACE41_tree;
    pANTLR3_BASE_TREE R_BRACE45_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SEQUENCE_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_BRACE;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_extensionAndException;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_optionalExtensionMarker;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_componentTypeLists;
    /* Initialize rule variables
     */
    sequenceType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(17)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    SEQUENCE_LITERAL40       = NULL;
    L_BRACE41       = NULL;
    R_BRACE45       = NULL;
    extensionAndException42.tree = NULL;

    optionalExtensionMarker43.tree = NULL;

    componentTypeLists44.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    SEQUENCE_LITERAL40_tree   = NULL;
    L_BRACE41_tree   = NULL;
    R_BRACE45_tree   = NULL;

    stream_L_BRACE   = NULL;
    #define CREATE_stream_L_BRACE  if (stream_L_BRACE == NULL) {stream_L_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_BRACE"); } 
    stream_SEQUENCE_LITERAL   = NULL;
    #define CREATE_stream_SEQUENCE_LITERAL  if (stream_SEQUENCE_LITERAL == NULL) {stream_SEQUENCE_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SEQUENCE_LITERAL"); } 
    stream_R_BRACE   = NULL;
    #define CREATE_stream_R_BRACE  if (stream_R_BRACE == NULL) {stream_R_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_BRACE"); } 
    stream_extensionAndException   = NULL;
    #define CREATE_stream_extensionAndException  if (stream_extensionAndException == NULL) {stream_extensionAndException = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule extensionAndException"); }
    stream_optionalExtensionMarker   = NULL;
    #define CREATE_stream_optionalExtensionMarker  if (stream_optionalExtensionMarker == NULL) {stream_optionalExtensionMarker = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule optionalExtensionMarker"); }
    stream_componentTypeLists   = NULL;
    #define CREATE_stream_componentTypeLists  if (stream_componentTypeLists == NULL) {stream_componentTypeLists = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule componentTypeLists"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:212:14: ( SEQUENCE_LITERAL L_BRACE ( extensionAndException optionalExtensionMarker | componentTypeLists )? R_BRACE -> ^( SEQUENCE_LITERAL ( extensionAndException )? ( optionalExtensionMarker )? ( componentTypeLists )? ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:212:15: SEQUENCE_LITERAL L_BRACE ( extensionAndException optionalExtensionMarker | componentTypeLists )? R_BRACE
        {
            SEQUENCE_LITERAL40 = (pANTLR3_COMMON_TOKEN) MATCHT(SEQUENCE_LITERAL, &FOLLOW_SEQUENCE_LITERAL_in_sequenceType3851); 
            if  (HASEXCEPTION())
            {
                goto rulesequenceTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_SEQUENCE_LITERAL; stream_SEQUENCE_LITERAL->add(stream_SEQUENCE_LITERAL, SEQUENCE_LITERAL40, NULL); }

            L_BRACE41 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_sequenceType3853); 
            if  (HASEXCEPTION())
            {
                goto rulesequenceTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_L_BRACE; stream_L_BRACE->add(stream_L_BRACE, L_BRACE41, NULL); }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:212:40: ( extensionAndException optionalExtensionMarker | componentTypeLists )?
            {
                int alt20=3;
                switch ( LA(1) ) 
                {
                    case ELLIPSIS:
                    	{
                    		{
                    		    int LA20_1 = LA(2);
                    		    if ( (synpred26_asn1(ctx)) ) 
                    		    {
                    		        alt20=1;
                    		    }
                    		    else if ( (synpred27_asn1(ctx)) ) 
                    		    {
                    		        alt20=2;
                    		    }
                    		}
                    	}
                        break;
                    case COMPONENTS_LITERAL:
                    case IDENTIFIER:
                    	{
                    		alt20=2;
                    	}
                        break;
                }

                switch (alt20) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:212:41: extensionAndException optionalExtensionMarker
            	    {
            	        FOLLOWPUSH(FOLLOW_extensionAndException_in_sequenceType3856);
            	        extensionAndException42=extensionAndException(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_extensionAndException; stream_extensionAndException->add(stream_extensionAndException, extensionAndException42.tree, NULL); }
            	        FOLLOWPUSH(FOLLOW_optionalExtensionMarker_in_sequenceType3859);
            	        optionalExtensionMarker43=optionalExtensionMarker(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_optionalExtensionMarker; stream_optionalExtensionMarker->add(stream_optionalExtensionMarker, optionalExtensionMarker43.tree, NULL); }

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:212:90: componentTypeLists
            	    {
            	        FOLLOWPUSH(FOLLOW_componentTypeLists_in_sequenceType3863);
            	        componentTypeLists44=componentTypeLists(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_componentTypeLists; stream_componentTypeLists->add(stream_componentTypeLists, componentTypeLists44.tree, NULL); }

            	    }
            	    break;

                }
            }
            R_BRACE45 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_sequenceType3868); 
            if  (HASEXCEPTION())
            {
                goto rulesequenceTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_R_BRACE; stream_R_BRACE->add(stream_R_BRACE, R_BRACE45, NULL); }


             
            /* AST REWRITE
             * elements          : extensionAndException, SEQUENCE_LITERAL, optionalExtensionMarker, componentTypeLists
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 213:1: -> ^( SEQUENCE_LITERAL ( extensionAndException )? ( optionalExtensionMarker )? ( componentTypeLists )? )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:213:4: ^( SEQUENCE_LITERAL ( extensionAndException )? ( optionalExtensionMarker )? ( componentTypeLists )? )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_SEQUENCE_LITERAL == NULL ? NULL : stream_SEQUENCE_LITERAL->nextNode(stream_SEQUENCE_LITERAL), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:213:23: ( extensionAndException )?
            	        {
            	        	if ( (stream_extensionAndException != NULL && stream_extensionAndException->hasNext(stream_extensionAndException))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_extensionAndException == NULL ? NULL : stream_extensionAndException->nextTree(stream_extensionAndException));

            	        	}
            	        	if ( stream_extensionAndException != NULL) stream_extensionAndException->reset(stream_extensionAndException);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:213:46: ( optionalExtensionMarker )?
            	        {
            	        	if ( (stream_optionalExtensionMarker != NULL && stream_optionalExtensionMarker->hasNext(stream_optionalExtensionMarker))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_optionalExtensionMarker == NULL ? NULL : stream_optionalExtensionMarker->nextTree(stream_optionalExtensionMarker));

            	        	}
            	        	if ( stream_optionalExtensionMarker != NULL) stream_optionalExtensionMarker->reset(stream_optionalExtensionMarker);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:213:71: ( componentTypeLists )?
            	        {
            	        	if ( (stream_componentTypeLists != NULL && stream_componentTypeLists->hasNext(stream_componentTypeLists))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_componentTypeLists == NULL ? NULL : stream_componentTypeLists->nextTree(stream_componentTypeLists));

            	        	}
            	        	if ( stream_componentTypeLists != NULL) stream_componentTypeLists->reset(stream_componentTypeLists);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesequenceTypeEx; /* Prevent compiler warnings */
    rulesequenceTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_L_BRACE != NULL) stream_L_BRACE->free(stream_L_BRACE);
        if (stream_SEQUENCE_LITERAL != NULL) stream_SEQUENCE_LITERAL->free(stream_SEQUENCE_LITERAL);
        if (stream_R_BRACE != NULL) stream_R_BRACE->free(stream_R_BRACE);
        if (stream_extensionAndException != NULL) stream_extensionAndException->free(stream_extensionAndException);
        if (stream_optionalExtensionMarker != NULL) stream_optionalExtensionMarker->free(stream_optionalExtensionMarker);
        if (stream_componentTypeLists != NULL) stream_componentTypeLists->free(stream_componentTypeLists);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(17, sequenceType_StartIndex); }

    return retval;
}
/* $ANTLR end sequenceType */

/** 
 * $ANTLR start extensionAndException
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:215:1: extensionAndException : ELLIPSIS ( exceptionSpec )? ;
 */
static asn1Parser_extensionAndException_return
extensionAndException(pasn1Parser ctx)
{   
    asn1Parser_extensionAndException_return retval;
    ANTLR3_UINT32 extensionAndException_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ELLIPSIS46;
    asn1Parser_exceptionSpec_return exceptionSpec47;
    #undef	RETURN_TYPE_exceptionSpec47
    #define	RETURN_TYPE_exceptionSpec47 asn1Parser_exceptionSpec_return

    pANTLR3_BASE_TREE ELLIPSIS46_tree;

    /* Initialize rule variables
     */
    extensionAndException_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(18)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    ELLIPSIS46       = NULL;
    exceptionSpec47.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    ELLIPSIS46_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:215:23: ( ELLIPSIS ( exceptionSpec )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:215:26: ELLIPSIS ( exceptionSpec )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            ELLIPSIS46 = (pANTLR3_COMMON_TOKEN) MATCHT(ELLIPSIS, &FOLLOW_ELLIPSIS_in_extensionAndException3893); 
            if  (HASEXCEPTION())
            {
                goto ruleextensionAndExceptionEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:215:37: ( exceptionSpec )?
            {
                int alt21=2;
                switch ( LA(1) ) 
                {
                    case EXCLAM:
                    	{
                    		alt21=1;
                    	}
                        break;
                    case COMMA:
                    	{
                    		{
                    		    int LA21_2 = LA(2);
                    		    if ( (synpred28_asn1(ctx)) ) 
                    		    {
                    		        alt21=1;
                    		    }
                    		}
                    	}
                        break;
                    case R_BRACE:
                    	{
                    		{
                    		    int LA21_3 = LA(2);
                    		    if ( (synpred28_asn1(ctx)) ) 
                    		    {
                    		        alt21=1;
                    		    }
                    		}
                    	}
                        break;
                    case EOF:
                    	{
                    		{
                    		    int LA21_4 = LA(2);
                    		    if ( (synpred28_asn1(ctx)) ) 
                    		    {
                    		        alt21=1;
                    		    }
                    		}
                    	}
                        break;
                    case EXTENSTIONENDMARKER:
                    	{
                    		{
                    		    int LA21_5 = LA(2);
                    		    if ( (synpred28_asn1(ctx)) ) 
                    		    {
                    		        alt21=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt21) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: exceptionSpec
            	    {
            	        FOLLOWPUSH(FOLLOW_exceptionSpec_in_extensionAndException3897);
            	        exceptionSpec47=exceptionSpec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAndExceptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, exceptionSpec47.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextensionAndExceptionEx; /* Prevent compiler warnings */
    ruleextensionAndExceptionEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(18, extensionAndException_StartIndex); }

    return retval;
}
/* $ANTLR end extensionAndException */

/** 
 * $ANTLR start optionalExtensionMarker
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:217:1: optionalExtensionMarker : ( COMMA ELLIPSIS )? ;
 */
static asn1Parser_optionalExtensionMarker_return
optionalExtensionMarker(pasn1Parser ctx)
{   
    asn1Parser_optionalExtensionMarker_return retval;
    ANTLR3_UINT32 optionalExtensionMarker_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA48;
    pANTLR3_COMMON_TOKEN    ELLIPSIS49;

    pANTLR3_BASE_TREE COMMA48_tree;
    pANTLR3_BASE_TREE ELLIPSIS49_tree;

    /* Initialize rule variables
     */
    optionalExtensionMarker_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(19)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA48       = NULL;
    ELLIPSIS49       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    COMMA48_tree   = NULL;
    ELLIPSIS49_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:217:25: ( ( COMMA ELLIPSIS )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:217:28: ( COMMA ELLIPSIS )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:217:28: ( COMMA ELLIPSIS )?
            {
                int alt22=2;
                switch ( LA(1) ) 
                {
                    case COMMA:
                    	{
                    		alt22=1;
                    	}
                        break;
                }

                switch (alt22) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:217:30: COMMA ELLIPSIS
            	    {
            	        COMMA48 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_optionalExtensionMarker3909); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoptionalExtensionMarkerEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        COMMA48_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA48));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA48_tree);
            	        }
            	        ELLIPSIS49 = (pANTLR3_COMMON_TOKEN) MATCHT(ELLIPSIS, &FOLLOW_ELLIPSIS_in_optionalExtensionMarker3912); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoptionalExtensionMarkerEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        ELLIPSIS49_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ELLIPSIS49));
            	        ADAPTOR->addChild(ADAPTOR, root_0, ELLIPSIS49_tree);
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleoptionalExtensionMarkerEx; /* Prevent compiler warnings */
    ruleoptionalExtensionMarkerEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(19, optionalExtensionMarker_StartIndex); }

    return retval;
}
/* $ANTLR end optionalExtensionMarker */

/** 
 * $ANTLR start componentTypeLists
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:220:1: componentTypeLists : ( rootComponentTypeList ( COMMA extensionAndException extensionAdditions ( optionalExtensionMarker | ( EXTENSTIONENDMARKER COMMA rootComponentTypeList ) ) )? | extensionAndException extensionAdditions ( optionalExtensionMarker | ( EXTENSTIONENDMARKER COMMA rootComponentTypeList ) ) );
 */
static asn1Parser_componentTypeLists_return
componentTypeLists(pasn1Parser ctx)
{   
    asn1Parser_componentTypeLists_return retval;
    ANTLR3_UINT32 componentTypeLists_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA51;
    pANTLR3_COMMON_TOKEN    EXTENSTIONENDMARKER55;
    pANTLR3_COMMON_TOKEN    COMMA56;
    pANTLR3_COMMON_TOKEN    EXTENSTIONENDMARKER61;
    pANTLR3_COMMON_TOKEN    COMMA62;
    asn1Parser_rootComponentTypeList_return rootComponentTypeList50;
    #undef	RETURN_TYPE_rootComponentTypeList50
    #define	RETURN_TYPE_rootComponentTypeList50 asn1Parser_rootComponentTypeList_return

    asn1Parser_extensionAndException_return extensionAndException52;
    #undef	RETURN_TYPE_extensionAndException52
    #define	RETURN_TYPE_extensionAndException52 asn1Parser_extensionAndException_return

    asn1Parser_extensionAdditions_return extensionAdditions53;
    #undef	RETURN_TYPE_extensionAdditions53
    #define	RETURN_TYPE_extensionAdditions53 asn1Parser_extensionAdditions_return

    asn1Parser_optionalExtensionMarker_return optionalExtensionMarker54;
    #undef	RETURN_TYPE_optionalExtensionMarker54
    #define	RETURN_TYPE_optionalExtensionMarker54 asn1Parser_optionalExtensionMarker_return

    asn1Parser_rootComponentTypeList_return rootComponentTypeList57;
    #undef	RETURN_TYPE_rootComponentTypeList57
    #define	RETURN_TYPE_rootComponentTypeList57 asn1Parser_rootComponentTypeList_return

    asn1Parser_extensionAndException_return extensionAndException58;
    #undef	RETURN_TYPE_extensionAndException58
    #define	RETURN_TYPE_extensionAndException58 asn1Parser_extensionAndException_return

    asn1Parser_extensionAdditions_return extensionAdditions59;
    #undef	RETURN_TYPE_extensionAdditions59
    #define	RETURN_TYPE_extensionAdditions59 asn1Parser_extensionAdditions_return

    asn1Parser_optionalExtensionMarker_return optionalExtensionMarker60;
    #undef	RETURN_TYPE_optionalExtensionMarker60
    #define	RETURN_TYPE_optionalExtensionMarker60 asn1Parser_optionalExtensionMarker_return

    asn1Parser_rootComponentTypeList_return rootComponentTypeList63;
    #undef	RETURN_TYPE_rootComponentTypeList63
    #define	RETURN_TYPE_rootComponentTypeList63 asn1Parser_rootComponentTypeList_return

    pANTLR3_BASE_TREE COMMA51_tree;
    pANTLR3_BASE_TREE EXTENSTIONENDMARKER55_tree;
    pANTLR3_BASE_TREE COMMA56_tree;
    pANTLR3_BASE_TREE EXTENSTIONENDMARKER61_tree;
    pANTLR3_BASE_TREE COMMA62_tree;

    /* Initialize rule variables
     */
    componentTypeLists_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(20)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA51       = NULL;
    EXTENSTIONENDMARKER55       = NULL;
    COMMA56       = NULL;
    EXTENSTIONENDMARKER61       = NULL;
    COMMA62       = NULL;
    rootComponentTypeList50.tree = NULL;

    extensionAndException52.tree = NULL;

    extensionAdditions53.tree = NULL;

    optionalExtensionMarker54.tree = NULL;

    rootComponentTypeList57.tree = NULL;

    extensionAndException58.tree = NULL;

    extensionAdditions59.tree = NULL;

    optionalExtensionMarker60.tree = NULL;

    rootComponentTypeList63.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA51_tree   = NULL;
    EXTENSTIONENDMARKER55_tree   = NULL;
    COMMA56_tree   = NULL;
    EXTENSTIONENDMARKER61_tree   = NULL;
    COMMA62_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:220:20: ( rootComponentTypeList ( COMMA extensionAndException extensionAdditions ( optionalExtensionMarker | ( EXTENSTIONENDMARKER COMMA rootComponentTypeList ) ) )? | extensionAndException extensionAdditions ( optionalExtensionMarker | ( EXTENSTIONENDMARKER COMMA rootComponentTypeList ) ) )
            
            ANTLR3_UINT32 alt26;

            alt26=2;

            switch ( LA(1) ) 
            {
            case COMPONENTS_LITERAL:
            case IDENTIFIER:
            	{
            		alt26=1;
            	}
                break;
            case ELLIPSIS:
            	{
            		alt26=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 26;
                EXCEPTION->state        = 0;


                goto rulecomponentTypeListsEx;
            }

            switch (alt26) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:221:4: rootComponentTypeList ( COMMA extensionAndException extensionAdditions ( optionalExtensionMarker | ( EXTENSTIONENDMARKER COMMA rootComponentTypeList ) ) )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_rootComponentTypeList_in_componentTypeLists3931);
        	        rootComponentTypeList50=rootComponentTypeList(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeListsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rootComponentTypeList50.tree);

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:221:26: ( COMMA extensionAndException extensionAdditions ( optionalExtensionMarker | ( EXTENSTIONENDMARKER COMMA rootComponentTypeList ) ) )?
        	        {
        	            int alt24=2;
        	            switch ( LA(1) ) 
        	            {
        	                case COMMA:
        	                	{
        	                		alt24=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt24) 
        	            {
        	        	case 1:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:221:27: COMMA extensionAndException extensionAdditions ( optionalExtensionMarker | ( EXTENSTIONENDMARKER COMMA rootComponentTypeList ) )
        	        	    {
        	        	        COMMA51 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_componentTypeLists3934); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecomponentTypeListsEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        FOLLOWPUSH(FOLLOW_extensionAndException_in_componentTypeLists3938);
        	        	        extensionAndException52=extensionAndException(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecomponentTypeListsEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAndException52.tree);
        	        	        FOLLOWPUSH(FOLLOW_extensionAdditions_in_componentTypeLists3941);
        	        	        extensionAdditions53=extensionAdditions(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecomponentTypeListsEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAdditions53.tree);

        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:221:79: ( optionalExtensionMarker | ( EXTENSTIONENDMARKER COMMA rootComponentTypeList ) )
        	        	        {
        	        	            int alt23=2;
        	        	            switch ( LA(1) ) 
        	        	            {
        	        	            case EOF:
        	        	            case R_BRACE:
        	        	            case COMMA:
        	        	            	{
        	        	            		alt23=1;
        	        	            	}
        	        	                break;
        	        	            case EXTENSTIONENDMARKER:
        	        	            	{
        	        	            		alt23=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (BACKTRACKING>0)
        	        	                {
        	        	                    FAILEDFLAG = ANTLR3_TRUE;
        	        	                    return retval;
        	        	                }
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 23;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulecomponentTypeListsEx;
        	        	            }

        	        	            switch (alt23) 
        	        	            {
        	        	        	case 1:
        	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:221:80: optionalExtensionMarker
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_optionalExtensionMarker_in_componentTypeLists3946);
        	        	        	        optionalExtensionMarker54=optionalExtensionMarker(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulecomponentTypeListsEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }
        	        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, optionalExtensionMarker54.tree);

        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:221:104: ( EXTENSTIONENDMARKER COMMA rootComponentTypeList )
        	        	        	    {
        	        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:221:104: ( EXTENSTIONENDMARKER COMMA rootComponentTypeList )
        	        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:221:105: EXTENSTIONENDMARKER COMMA rootComponentTypeList
        	        	        	        {
        	        	        	            EXTENSTIONENDMARKER55 = (pANTLR3_COMMON_TOKEN) MATCHT(EXTENSTIONENDMARKER, &FOLLOW_EXTENSTIONENDMARKER_in_componentTypeLists3949); 
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulecomponentTypeListsEx;
        	        	        	            }
        	        	        	            if (HASFAILED())
        	        	        	            {
        	        	        	                return retval;
        	        	        	            }
        	        	        	            if ( BACKTRACKING==0 ) {
        	        	        	            EXTENSTIONENDMARKER55_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EXTENSTIONENDMARKER55));
        	        	        	            ADAPTOR->addChild(ADAPTOR, root_0, EXTENSTIONENDMARKER55_tree);
        	        	        	            }
        	        	        	            COMMA56 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_componentTypeLists3952); 
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulecomponentTypeListsEx;
        	        	        	            }
        	        	        	            if (HASFAILED())
        	        	        	            {
        	        	        	                return retval;
        	        	        	            }
        	        	        	            if ( BACKTRACKING==0 ) {
        	        	        	            COMMA56_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA56));
        	        	        	            ADAPTOR->addChild(ADAPTOR, root_0, COMMA56_tree);
        	        	        	            }
        	        	        	            FOLLOWPUSH(FOLLOW_rootComponentTypeList_in_componentTypeLists3955);
        	        	        	            rootComponentTypeList57=rootComponentTypeList(ctx);

        	        	        	            FOLLOWPOP();
        	        	        	            if  (HASEXCEPTION())
        	        	        	            {
        	        	        	                goto rulecomponentTypeListsEx;
        	        	        	            }
        	        	        	            if (HASFAILED())
        	        	        	            {
        	        	        	                return retval;
        	        	        	            }
        	        	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rootComponentTypeList57.tree);

        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:222:6: extensionAndException extensionAdditions ( optionalExtensionMarker | ( EXTENSTIONENDMARKER COMMA rootComponentTypeList ) )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_extensionAndException_in_componentTypeLists3966);
        	        extensionAndException58=extensionAndException(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeListsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAndException58.tree);
        	        FOLLOWPUSH(FOLLOW_extensionAdditions_in_componentTypeLists3969);
        	        extensionAdditions59=extensionAdditions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeListsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAdditions59.tree);

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:222:49: ( optionalExtensionMarker | ( EXTENSTIONENDMARKER COMMA rootComponentTypeList ) )
        	        {
        	            int alt25=2;
        	            switch ( LA(1) ) 
        	            {
        	            case EOF:
        	            case R_BRACE:
        	            case COMMA:
        	            	{
        	            		alt25=1;
        	            	}
        	                break;
        	            case EXTENSTIONENDMARKER:
        	            	{
        	            		alt25=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return retval;
        	                }
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 25;
        	                EXCEPTION->state        = 0;


        	                goto rulecomponentTypeListsEx;
        	            }

        	            switch (alt25) 
        	            {
        	        	case 1:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:222:50: optionalExtensionMarker
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_optionalExtensionMarker_in_componentTypeLists3973);
        	        	        optionalExtensionMarker60=optionalExtensionMarker(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecomponentTypeListsEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, optionalExtensionMarker60.tree);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:222:76: ( EXTENSTIONENDMARKER COMMA rootComponentTypeList )
        	        	    {
        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:222:76: ( EXTENSTIONENDMARKER COMMA rootComponentTypeList )
        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:222:77: EXTENSTIONENDMARKER COMMA rootComponentTypeList
        	        	        {
        	        	            EXTENSTIONENDMARKER61 = (pANTLR3_COMMON_TOKEN) MATCHT(EXTENSTIONENDMARKER, &FOLLOW_EXTENSTIONENDMARKER_in_componentTypeLists3978); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulecomponentTypeListsEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return retval;
        	        	            }
        	        	            if ( BACKTRACKING==0 ) {
        	        	            EXTENSTIONENDMARKER61_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EXTENSTIONENDMARKER61));
        	        	            ADAPTOR->addChild(ADAPTOR, root_0, EXTENSTIONENDMARKER61_tree);
        	        	            }
        	        	            COMMA62 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_componentTypeLists3981); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulecomponentTypeListsEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return retval;
        	        	            }
        	        	            if ( BACKTRACKING==0 ) {
        	        	            COMMA62_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA62));
        	        	            ADAPTOR->addChild(ADAPTOR, root_0, COMMA62_tree);
        	        	            }
        	        	            FOLLOWPUSH(FOLLOW_rootComponentTypeList_in_componentTypeLists3986);
        	        	            rootComponentTypeList63=rootComponentTypeList(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulecomponentTypeListsEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return retval;
        	        	            }
        	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rootComponentTypeList63.tree);

        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecomponentTypeListsEx; /* Prevent compiler warnings */
    rulecomponentTypeListsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(20, componentTypeLists_StartIndex); }

    return retval;
}
/* $ANTLR end componentTypeLists */

/** 
 * $ANTLR start rootComponentTypeList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:224:1: rootComponentTypeList : componentTypeList ;
 */
static asn1Parser_rootComponentTypeList_return
rootComponentTypeList(pasn1Parser ctx)
{   
    asn1Parser_rootComponentTypeList_return retval;
    ANTLR3_UINT32 rootComponentTypeList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_componentTypeList_return componentTypeList64;
    #undef	RETURN_TYPE_componentTypeList64
    #define	RETURN_TYPE_componentTypeList64 asn1Parser_componentTypeList_return


    /* Initialize rule variables
     */
    rootComponentTypeList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(21)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    componentTypeList64.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:224:24: ( componentTypeList )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:224:26: componentTypeList
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_componentTypeList_in_rootComponentTypeList3997);
            componentTypeList64=componentTypeList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerootComponentTypeListEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, componentTypeList64.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerootComponentTypeListEx; /* Prevent compiler warnings */
    rulerootComponentTypeListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(21, rootComponentTypeList_StartIndex); }

    return retval;
}
/* $ANTLR end rootComponentTypeList */

/** 
 * $ANTLR start componentTypeList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:226:1: componentTypeList : ( componentType ) ( COMMA componentType )* ;
 */
static asn1Parser_componentTypeList_return
componentTypeList(pasn1Parser ctx)
{   
    asn1Parser_componentTypeList_return retval;
    ANTLR3_UINT32 componentTypeList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA66;
    asn1Parser_componentType_return componentType65;
    #undef	RETURN_TYPE_componentType65
    #define	RETURN_TYPE_componentType65 asn1Parser_componentType_return

    asn1Parser_componentType_return componentType67;
    #undef	RETURN_TYPE_componentType67
    #define	RETURN_TYPE_componentType67 asn1Parser_componentType_return

    pANTLR3_BASE_TREE COMMA66_tree;

    /* Initialize rule variables
     */
    componentTypeList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(22)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA66       = NULL;
    componentType65.tree = NULL;

    componentType67.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA66_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:226:20: ( ( componentType ) ( COMMA componentType )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:226:22: ( componentType ) ( COMMA componentType )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:226:22: ( componentType )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:226:23: componentType
            {
                FOLLOWPUSH(FOLLOW_componentType_in_componentTypeList4007);
                componentType65=componentType(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulecomponentTypeListEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, componentType65.tree);

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:226:38: ( COMMA componentType )*

            for (;;)
            {
                int alt27=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		switch ( LA(2) ) 
                		{
                		case COMPONENTS_LITERAL:
                		case IDENTIFIER:
                			{
                				alt27=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt27) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:226:39: COMMA componentType
            	    {
            	        COMMA66 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_componentTypeList4011); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomponentTypeListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_componentType_in_componentTypeList4014);
            	        componentType67=componentType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomponentTypeListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, componentType67.tree);

            	    }
            	    break;

            	default:
            	    goto loop27;	/* break out of the loop */
            	    break;
                }
            }
            loop27: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecomponentTypeListEx; /* Prevent compiler warnings */
    rulecomponentTypeListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(22, componentTypeList_StartIndex); }

    return retval;
}
/* $ANTLR end componentTypeList */

/** 
 * $ANTLR start componentType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:228:1: componentType : (nt1= namedType (ol= OPTIONAL_LITERAL | dl= DEFAULT_LITERAL nt2= namedType )? -> ^( $nt1 ( $nt2)? ^( TAG_DESCRIPTOR ( $ol)? ( $dl)? ) ) | COMPONENTS_LITERAL OF_LITERAL type );
 */
static asn1Parser_componentType_return
componentType(pasn1Parser ctx)
{   
    asn1Parser_componentType_return retval;
    ANTLR3_UINT32 componentType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ol;
    pANTLR3_COMMON_TOKEN    dl;
    pANTLR3_COMMON_TOKEN    COMPONENTS_LITERAL68;
    pANTLR3_COMMON_TOKEN    OF_LITERAL69;
    asn1Parser_namedType_return nt1;
    #undef	RETURN_TYPE_nt1
    #define	RETURN_TYPE_nt1 asn1Parser_namedType_return

    asn1Parser_namedType_return nt2;
    #undef	RETURN_TYPE_nt2
    #define	RETURN_TYPE_nt2 asn1Parser_namedType_return

    asn1Parser_type_return type70;
    #undef	RETURN_TYPE_type70
    #define	RETURN_TYPE_type70 asn1Parser_type_return

    pANTLR3_BASE_TREE ol_tree;
    pANTLR3_BASE_TREE dl_tree;
    pANTLR3_BASE_TREE COMPONENTS_LITERAL68_tree;
    pANTLR3_BASE_TREE OF_LITERAL69_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_OPTIONAL_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_DEFAULT_LITERAL;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_namedType;
    /* Initialize rule variables
     */
    componentType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(23)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    ol       = NULL;
    dl       = NULL;
    COMPONENTS_LITERAL68       = NULL;
    OF_LITERAL69       = NULL;
    nt1.tree = NULL;

    nt2.tree = NULL;

    type70.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    ol_tree   = NULL;
    dl_tree   = NULL;
    COMPONENTS_LITERAL68_tree   = NULL;
    OF_LITERAL69_tree   = NULL;

    stream_OPTIONAL_LITERAL   = NULL;
    #define CREATE_stream_OPTIONAL_LITERAL  if (stream_OPTIONAL_LITERAL == NULL) {stream_OPTIONAL_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token OPTIONAL_LITERAL"); } 
    stream_DEFAULT_LITERAL   = NULL;
    #define CREATE_stream_DEFAULT_LITERAL  if (stream_DEFAULT_LITERAL == NULL) {stream_DEFAULT_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token DEFAULT_LITERAL"); } 
    stream_namedType   = NULL;
    #define CREATE_stream_namedType  if (stream_namedType == NULL) {stream_namedType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule namedType"); }

    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:228:17: (nt1= namedType (ol= OPTIONAL_LITERAL | dl= DEFAULT_LITERAL nt2= namedType )? -> ^( $nt1 ( $nt2)? ^( TAG_DESCRIPTOR ( $ol)? ( $dl)? ) ) | COMPONENTS_LITERAL OF_LITERAL type )
            
            ANTLR3_UINT32 alt29;

            alt29=2;

            switch ( LA(1) ) 
            {
            case IDENTIFIER:
            	{
            		alt29=1;
            	}
                break;
            case COMPONENTS_LITERAL:
            	{
            		alt29=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 29;
                EXCEPTION->state        = 0;


                goto rulecomponentTypeEx;
            }

            switch (alt29) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:228:19: nt1= namedType (ol= OPTIONAL_LITERAL | dl= DEFAULT_LITERAL nt2= namedType )?
        	    {
        	        FOLLOWPUSH(FOLLOW_namedType_in_componentType4029);
        	        nt1=namedType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) { CREATE_stream_namedType; stream_namedType->add(stream_namedType, nt1.tree, NULL); }

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:228:33: (ol= OPTIONAL_LITERAL | dl= DEFAULT_LITERAL nt2= namedType )?
        	        {
        	            int alt28=3;
        	            switch ( LA(1) ) 
        	            {
        	                case OPTIONAL_LITERAL:
        	                	{
        	                		alt28=1;
        	                	}
        	                    break;
        	                case DEFAULT_LITERAL:
        	                	{
        	                		alt28=2;
        	                	}
        	                    break;
        	            }

        	            switch (alt28) 
        	            {
        	        	case 1:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:228:34: ol= OPTIONAL_LITERAL
        	        	    {
        	        	        ol = (pANTLR3_COMMON_TOKEN) MATCHT(OPTIONAL_LITERAL, &FOLLOW_OPTIONAL_LITERAL_in_componentType4034); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecomponentTypeEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        } 
        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_OPTIONAL_LITERAL; stream_OPTIONAL_LITERAL->add(stream_OPTIONAL_LITERAL, ol, NULL); }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:228:56: dl= DEFAULT_LITERAL nt2= namedType
        	        	    {
        	        	        dl = (pANTLR3_COMMON_TOKEN) MATCHT(DEFAULT_LITERAL, &FOLLOW_DEFAULT_LITERAL_in_componentType4040); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecomponentTypeEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        } 
        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_DEFAULT_LITERAL; stream_DEFAULT_LITERAL->add(stream_DEFAULT_LITERAL, dl, NULL); }

        	        	        FOLLOWPUSH(FOLLOW_namedType_in_componentType4044);
        	        	        nt2=namedType(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecomponentTypeEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_namedType; stream_namedType->add(stream_namedType, nt2.tree, NULL); }

        	        	    }
        	        	    break;

        	            }
        	        }

        	         
        	        /* AST REWRITE
        	         * elements          : dl, ol, nt1, nt2
        	         * token labels      : dl, ol
        	         * rule labels       : retval, nt2, nt1
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        if ( BACKTRACKING==0 ) 
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_dl;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ol;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_nt2;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_nt1;

        	        	stream_dl=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token dl", dl);
        	        	stream_ol=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token ol", ol);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
        	        	stream_nt2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token nt2", nt2.tree != NULL ? nt2.tree : NULL);
        	        	stream_nt1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token nt1", nt1.tree != NULL ? nt1.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 228:92: -> ^( $nt1 ( $nt2)? ^( TAG_DESCRIPTOR ( $ol)? ( $dl)? ) )
        	        	{
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:228:95: ^( $nt1 ( $nt2)? ^( TAG_DESCRIPTOR ( $ol)? ( $dl)? ) )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_nt1 == NULL ? NULL : stream_nt1->nextNode(stream_nt1), root_1));

        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:228:102: ( $nt2)?
        	        	        {
        	        	        	if ( (stream_nt2 != NULL && stream_nt2->hasNext(stream_nt2))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_nt2 == NULL ? NULL : stream_nt2->nextTree(stream_nt2));

        	        	        	}
        	        	        	if ( stream_nt2 != NULL) stream_nt2->reset(stream_nt2);

        	        	        }
        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:228:108: ^( TAG_DESCRIPTOR ( $ol)? ( $dl)? )
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TAG_DESCRIPTOR, (pANTLR3_UINT8)"TAG_DESCRIPTOR"), root_2));

        	        	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:228:125: ( $ol)?
        	        	            {
        	        	            	if ( (stream_ol != NULL && stream_ol->hasNext(stream_ol))  )
        	        	            	{
        	        	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_ol == NULL ? NULL : stream_ol->nextNode(stream_ol));

        	        	            	}
        	        	            	if ( stream_ol != NULL) stream_ol->reset(stream_ol);

        	        	            }
        	        	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:228:130: ( $dl)?
        	        	            {
        	        	            	if ( (stream_dl != NULL && stream_dl->hasNext(stream_dl))  )
        	        	            	{
        	        	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_dl == NULL ? NULL : stream_dl->nextNode(stream_dl));

        	        	            	}
        	        	            	if ( stream_dl != NULL) stream_dl->reset(stream_dl);

        	        	            }

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_dl != NULL) stream_dl->free(stream_dl); 
        	        	if (stream_ol != NULL) stream_ol->free(stream_ol); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);
        	        	if (stream_nt2 != NULL) stream_nt2->free(stream_nt2);
        	        	if (stream_nt1 != NULL) stream_nt1->free(stream_nt1);


        	        }
        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:229:6: COMPONENTS_LITERAL OF_LITERAL type
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        COMPONENTS_LITERAL68 = (pANTLR3_COMMON_TOKEN) MATCHT(COMPONENTS_LITERAL, &FOLLOW_COMPONENTS_LITERAL_in_componentType4077); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        COMPONENTS_LITERAL68_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMPONENTS_LITERAL68));
        	        ADAPTOR->addChild(ADAPTOR, root_0, COMPONENTS_LITERAL68_tree);
        	        }
        	        OF_LITERAL69 = (pANTLR3_COMMON_TOKEN) MATCHT(OF_LITERAL, &FOLLOW_OF_LITERAL_in_componentType4079); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        OF_LITERAL69_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OF_LITERAL69));
        	        ADAPTOR->addChild(ADAPTOR, root_0, OF_LITERAL69_tree);
        	        }
        	        FOLLOWPUSH(FOLLOW_type_in_componentType4082);
        	        type70=type(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecomponentTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type70.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecomponentTypeEx; /* Prevent compiler warnings */
    rulecomponentTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_OPTIONAL_LITERAL != NULL) stream_OPTIONAL_LITERAL->free(stream_OPTIONAL_LITERAL);
        if (stream_DEFAULT_LITERAL != NULL) stream_DEFAULT_LITERAL->free(stream_DEFAULT_LITERAL);
        if (stream_namedType != NULL) stream_namedType->free(stream_namedType);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(23, componentType_StartIndex); }

    return retval;
}
/* $ANTLR end componentType */

/** 
 * $ANTLR start extensionAdditions
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:232:1: extensionAdditions : ( COMMA extensionAdditionList )? ;
 */
static asn1Parser_extensionAdditions_return
extensionAdditions(pasn1Parser ctx)
{   
    asn1Parser_extensionAdditions_return retval;
    ANTLR3_UINT32 extensionAdditions_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA71;
    asn1Parser_extensionAdditionList_return extensionAdditionList72;
    #undef	RETURN_TYPE_extensionAdditionList72
    #define	RETURN_TYPE_extensionAdditionList72 asn1Parser_extensionAdditionList_return

    pANTLR3_BASE_TREE COMMA71_tree;

    /* Initialize rule variables
     */
    extensionAdditions_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(24)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA71       = NULL;
    extensionAdditionList72.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA71_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:232:21: ( ( COMMA extensionAdditionList )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:232:24: ( COMMA extensionAdditionList )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:232:24: ( COMMA extensionAdditionList )?
            {
                int alt30=2;
                switch ( LA(1) ) 
                {
                    case COMMA:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		    case COMPONENTS_LITERAL:
                    		    case DOUBLE_L_BRACKET:
                    		    case IDENTIFIER:
                    		    	{
                    		    		alt30=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt30) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:232:25: COMMA extensionAdditionList
            	    {
            	        COMMA71 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_extensionAdditions4094); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAdditionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_extensionAdditionList_in_extensionAdditions4098);
            	        extensionAdditionList72=extensionAdditionList(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAdditionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAdditionList72.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextensionAdditionsEx; /* Prevent compiler warnings */
    ruleextensionAdditionsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(24, extensionAdditions_StartIndex); }

    return retval;
}
/* $ANTLR end extensionAdditions */

/** 
 * $ANTLR start extensionAdditionList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:235:1: extensionAdditionList : ( extensionAddition ) ( COMMA extensionAddition )* ;
 */
static asn1Parser_extensionAdditionList_return
extensionAdditionList(pasn1Parser ctx)
{   
    asn1Parser_extensionAdditionList_return retval;
    ANTLR3_UINT32 extensionAdditionList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA74;
    asn1Parser_extensionAddition_return extensionAddition73;
    #undef	RETURN_TYPE_extensionAddition73
    #define	RETURN_TYPE_extensionAddition73 asn1Parser_extensionAddition_return

    asn1Parser_extensionAddition_return extensionAddition75;
    #undef	RETURN_TYPE_extensionAddition75
    #define	RETURN_TYPE_extensionAddition75 asn1Parser_extensionAddition_return

    pANTLR3_BASE_TREE COMMA74_tree;

    /* Initialize rule variables
     */
    extensionAdditionList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(25)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA74       = NULL;
    extensionAddition73.tree = NULL;

    extensionAddition75.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA74_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:235:24: ( ( extensionAddition ) ( COMMA extensionAddition )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:235:27: ( extensionAddition ) ( COMMA extensionAddition )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:235:27: ( extensionAddition )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:235:28: extensionAddition
            {
                FOLLOWPUSH(FOLLOW_extensionAddition_in_extensionAdditionList4112);
                extensionAddition73=extensionAddition(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleextensionAdditionListEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAddition73.tree);

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:235:47: ( COMMA extensionAddition )*

            for (;;)
            {
                int alt31=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		switch ( LA(2) ) 
                		{
                		case COMPONENTS_LITERAL:
                		case DOUBLE_L_BRACKET:
                		case IDENTIFIER:
                			{
                				alt31=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt31) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:235:48: COMMA extensionAddition
            	    {
            	        COMMA74 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_extensionAdditionList4116); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAdditionListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_extensionAddition_in_extensionAdditionList4120);
            	        extensionAddition75=extensionAddition(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAdditionListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAddition75.tree);

            	    }
            	    break;

            	default:
            	    goto loop31;	/* break out of the loop */
            	    break;
                }
            }
            loop31: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextensionAdditionListEx; /* Prevent compiler warnings */
    ruleextensionAdditionListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(25, extensionAdditionList_StartIndex); }

    return retval;
}
/* $ANTLR end extensionAdditionList */

/** 
 * $ANTLR start extensionAddition
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:238:1: extensionAddition : ( componentType | extensionAdditionGroup );
 */
static asn1Parser_extensionAddition_return
extensionAddition(pasn1Parser ctx)
{   
    asn1Parser_extensionAddition_return retval;
    ANTLR3_UINT32 extensionAddition_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_componentType_return componentType76;
    #undef	RETURN_TYPE_componentType76
    #define	RETURN_TYPE_componentType76 asn1Parser_componentType_return

    asn1Parser_extensionAdditionGroup_return extensionAdditionGroup77;
    #undef	RETURN_TYPE_extensionAdditionGroup77
    #define	RETURN_TYPE_extensionAdditionGroup77 asn1Parser_extensionAdditionGroup_return


    /* Initialize rule variables
     */
    extensionAddition_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(26)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    componentType76.tree = NULL;

    extensionAdditionGroup77.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:238:20: ( componentType | extensionAdditionGroup )
            
            ANTLR3_UINT32 alt32;

            alt32=2;

            switch ( LA(1) ) 
            {
            case COMPONENTS_LITERAL:
            case IDENTIFIER:
            	{
            		alt32=1;
            	}
                break;
            case DOUBLE_L_BRACKET:
            	{
            		alt32=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 32;
                EXCEPTION->state        = 0;


                goto ruleextensionAdditionEx;
            }

            switch (alt32) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:238:22: componentType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_componentType_in_extensionAddition4133);
        	        componentType76=componentType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionAdditionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, componentType76.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:238:40: extensionAdditionGroup
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_extensionAdditionGroup_in_extensionAddition4139);
        	        extensionAdditionGroup77=extensionAdditionGroup(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionAdditionEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAdditionGroup77.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleextensionAdditionEx; /* Prevent compiler warnings */
    ruleextensionAdditionEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(26, extensionAddition_StartIndex); }

    return retval;
}
/* $ANTLR end extensionAddition */

/** 
 * $ANTLR start extensionAdditionGroup
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:241:1: extensionAdditionGroup : DOUBLE_L_BRACKET versionNumber componentTypeList DOUBLE_R_BRACKET ;
 */
static asn1Parser_extensionAdditionGroup_return
extensionAdditionGroup(pasn1Parser ctx)
{   
    asn1Parser_extensionAdditionGroup_return retval;
    ANTLR3_UINT32 extensionAdditionGroup_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DOUBLE_L_BRACKET78;
    pANTLR3_COMMON_TOKEN    DOUBLE_R_BRACKET81;
    asn1Parser_versionNumber_return versionNumber79;
    #undef	RETURN_TYPE_versionNumber79
    #define	RETURN_TYPE_versionNumber79 asn1Parser_versionNumber_return

    asn1Parser_componentTypeList_return componentTypeList80;
    #undef	RETURN_TYPE_componentTypeList80
    #define	RETURN_TYPE_componentTypeList80 asn1Parser_componentTypeList_return

    pANTLR3_BASE_TREE DOUBLE_L_BRACKET78_tree;
    pANTLR3_BASE_TREE DOUBLE_R_BRACKET81_tree;

    /* Initialize rule variables
     */
    extensionAdditionGroup_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(27)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    DOUBLE_L_BRACKET78       = NULL;
    DOUBLE_R_BRACKET81       = NULL;
    versionNumber79.tree = NULL;

    componentTypeList80.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    DOUBLE_L_BRACKET78_tree   = NULL;
    DOUBLE_R_BRACKET81_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:241:25: ( DOUBLE_L_BRACKET versionNumber componentTypeList DOUBLE_R_BRACKET )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:241:28: DOUBLE_L_BRACKET versionNumber componentTypeList DOUBLE_R_BRACKET
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            DOUBLE_L_BRACKET78 = (pANTLR3_COMMON_TOKEN) MATCHT(DOUBLE_L_BRACKET, &FOLLOW_DOUBLE_L_BRACKET_in_extensionAdditionGroup4151); 
            if  (HASEXCEPTION())
            {
                goto ruleextensionAdditionGroupEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            DOUBLE_L_BRACKET78_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOUBLE_L_BRACKET78));
            ADAPTOR->addChild(ADAPTOR, root_0, DOUBLE_L_BRACKET78_tree);
            }
            FOLLOWPUSH(FOLLOW_versionNumber_in_extensionAdditionGroup4154);
            versionNumber79=versionNumber(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionAdditionGroupEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, versionNumber79.tree);
            FOLLOWPUSH(FOLLOW_componentTypeList_in_extensionAdditionGroup4157);
            componentTypeList80=componentTypeList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionAdditionGroupEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, componentTypeList80.tree);
            DOUBLE_R_BRACKET81 = (pANTLR3_COMMON_TOKEN) MATCHT(DOUBLE_R_BRACKET, &FOLLOW_DOUBLE_R_BRACKET_in_extensionAdditionGroup4160); 
            if  (HASEXCEPTION())
            {
                goto ruleextensionAdditionGroupEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            DOUBLE_R_BRACKET81_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOUBLE_R_BRACKET81));
            ADAPTOR->addChild(ADAPTOR, root_0, DOUBLE_R_BRACKET81_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextensionAdditionGroupEx; /* Prevent compiler warnings */
    ruleextensionAdditionGroupEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(27, extensionAdditionGroup_StartIndex); }

    return retval;
}
/* $ANTLR end extensionAdditionGroup */

/** 
 * $ANTLR start versionNumber
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:244:1: versionNumber : ( NUMBER COLON )? ;
 */
static asn1Parser_versionNumber_return
versionNumber(pasn1Parser ctx)
{   
    asn1Parser_versionNumber_return retval;
    ANTLR3_UINT32 versionNumber_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    NUMBER82;
    pANTLR3_COMMON_TOKEN    COLON83;

    pANTLR3_BASE_TREE NUMBER82_tree;
    pANTLR3_BASE_TREE COLON83_tree;

    /* Initialize rule variables
     */
    versionNumber_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(28)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    NUMBER82       = NULL;
    COLON83       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    NUMBER82_tree   = NULL;
    COLON83_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:244:16: ( ( NUMBER COLON )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:244:19: ( NUMBER COLON )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:244:19: ( NUMBER COLON )?
            {
                int alt33=2;
                switch ( LA(1) ) 
                {
                    case NUMBER:
                    	{
                    		alt33=1;
                    	}
                        break;
                }

                switch (alt33) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:244:20: NUMBER COLON
            	    {
            	        NUMBER82 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_versionNumber4173); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleversionNumberEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        NUMBER82_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER82));
            	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER82_tree);
            	        }
            	        COLON83 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_versionNumber4176); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleversionNumberEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        COLON83_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON83));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COLON83_tree);
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleversionNumberEx; /* Prevent compiler warnings */
    ruleversionNumberEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(28, versionNumber_StartIndex); }

    return retval;
}
/* $ANTLR end versionNumber */

/** 
 * $ANTLR start sequenceOfType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:1: sequenceOfType : SEQUENCE_LITERAL (sz+= SIZE_LITERAL )* ( ( L_PARAN )* (c1= constraint | c2= sizeConstraint ) ( R_PARAN )* )? OF_LITERAL (tp= type | nt= namedType ) -> ^( SEQUENCE_LITERAL[\"SEQUENCE_OF\"] ^( TAG_SPECIFIC ( $sz)* ( $c1)? ( $c2)? ( $tp)? ( $nt)? ) ) ;
 */
static asn1Parser_sequenceOfType_return
sequenceOfType(pasn1Parser ctx)
{   
    asn1Parser_sequenceOfType_return retval;
    ANTLR3_UINT32 sequenceOfType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SEQUENCE_LITERAL84;
    pANTLR3_COMMON_TOKEN    L_PARAN85;
    pANTLR3_COMMON_TOKEN    R_PARAN86;
    pANTLR3_COMMON_TOKEN    OF_LITERAL87;
    pANTLR3_COMMON_TOKEN    sz;
    pANTLR3_VECTOR    list_sz;
    asn1Parser_constraint_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 asn1Parser_constraint_return

    asn1Parser_sizeConstraint_return c2;
    #undef	RETURN_TYPE_c2
    #define	RETURN_TYPE_c2 asn1Parser_sizeConstraint_return

    asn1Parser_type_return tp;
    #undef	RETURN_TYPE_tp
    #define	RETURN_TYPE_tp asn1Parser_type_return

    asn1Parser_namedType_return nt;
    #undef	RETURN_TYPE_nt
    #define	RETURN_TYPE_nt asn1Parser_namedType_return

    pANTLR3_BASE_TREE SEQUENCE_LITERAL84_tree;
    pANTLR3_BASE_TREE L_PARAN85_tree;
    pANTLR3_BASE_TREE R_PARAN86_tree;
    pANTLR3_BASE_TREE OF_LITERAL87_tree;
    pANTLR3_BASE_TREE sz_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SEQUENCE_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SIZE_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_PARAN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_OF_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_PARAN;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_namedType;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_constraint;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_type;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_sizeConstraint;
    /* Initialize rule variables
     */
    sequenceOfType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(29)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    SEQUENCE_LITERAL84       = NULL;
    L_PARAN85       = NULL;
    R_PARAN86       = NULL;
    OF_LITERAL87       = NULL;
    sz       = NULL;
    list_sz     = NULL;
    c1.tree = NULL;

    c2.tree = NULL;

    tp.tree = NULL;

    nt.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    SEQUENCE_LITERAL84_tree   = NULL;
    L_PARAN85_tree   = NULL;
    R_PARAN86_tree   = NULL;
    OF_LITERAL87_tree   = NULL;
    sz_tree   = NULL;

    stream_SEQUENCE_LITERAL   = NULL;
    #define CREATE_stream_SEQUENCE_LITERAL  if (stream_SEQUENCE_LITERAL == NULL) {stream_SEQUENCE_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SEQUENCE_LITERAL"); } 
    stream_SIZE_LITERAL   = NULL;
    #define CREATE_stream_SIZE_LITERAL  if (stream_SIZE_LITERAL == NULL) {stream_SIZE_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SIZE_LITERAL"); } 
    stream_L_PARAN   = NULL;
    #define CREATE_stream_L_PARAN  if (stream_L_PARAN == NULL) {stream_L_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_PARAN"); } 
    stream_OF_LITERAL   = NULL;
    #define CREATE_stream_OF_LITERAL  if (stream_OF_LITERAL == NULL) {stream_OF_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token OF_LITERAL"); } 
    stream_R_PARAN   = NULL;
    #define CREATE_stream_R_PARAN  if (stream_R_PARAN == NULL) {stream_R_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_PARAN"); } 
    stream_namedType   = NULL;
    #define CREATE_stream_namedType  if (stream_namedType == NULL) {stream_namedType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule namedType"); }
    stream_constraint   = NULL;
    #define CREATE_stream_constraint  if (stream_constraint == NULL) {stream_constraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule constraint"); }
    stream_type   = NULL;
    #define CREATE_stream_type  if (stream_type == NULL) {stream_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule type"); }
    stream_sizeConstraint   = NULL;
    #define CREATE_stream_sizeConstraint  if (stream_sizeConstraint == NULL) {stream_sizeConstraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule sizeConstraint"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:17: ( SEQUENCE_LITERAL (sz+= SIZE_LITERAL )* ( ( L_PARAN )* (c1= constraint | c2= sizeConstraint ) ( R_PARAN )* )? OF_LITERAL (tp= type | nt= namedType ) -> ^( SEQUENCE_LITERAL[\"SEQUENCE_OF\"] ^( TAG_SPECIFIC ( $sz)* ( $c1)? ( $c2)? ( $tp)? ( $nt)? ) ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:19: SEQUENCE_LITERAL (sz+= SIZE_LITERAL )* ( ( L_PARAN )* (c1= constraint | c2= sizeConstraint ) ( R_PARAN )* )? OF_LITERAL (tp= type | nt= namedType )
        {
            SEQUENCE_LITERAL84 = (pANTLR3_COMMON_TOKEN) MATCHT(SEQUENCE_LITERAL, &FOLLOW_SEQUENCE_LITERAL_in_sequenceOfType4189); 
            if  (HASEXCEPTION())
            {
                goto rulesequenceOfTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_SEQUENCE_LITERAL; stream_SEQUENCE_LITERAL->add(stream_SEQUENCE_LITERAL, SEQUENCE_LITERAL84, NULL); }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:38: (sz+= SIZE_LITERAL )*

            for (;;)
            {
                int alt34=2;
                switch ( LA(1) ) 
                {
                case SIZE_LITERAL:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA34_12 = LA(2);
                		    if ( (synpred42_asn1(ctx)) ) 
                		    {
                		        alt34=1;
                		    }

                		}
                	}
                    break;

                }

                switch (alt34) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: sz+= SIZE_LITERAL
            	    {
            	        sz = (pANTLR3_COMMON_TOKEN) MATCHT(SIZE_LITERAL, &FOLLOW_SIZE_LITERAL_in_sequenceOfType4193); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceOfTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_SIZE_LITERAL; stream_SIZE_LITERAL->add(stream_SIZE_LITERAL, sz, NULL); }

            	        if (list_sz == NULL)
            	        {
            	            list_sz=ctx->vectors->newVector(ctx->vectors);
            	        }
            	        list_sz->add(list_sz, sz, NULL);

            	    }
            	    break;

            	default:
            	    goto loop34;	/* break out of the loop */
            	    break;
                }
            }
            loop34: ; /* Jump out to here if this rule does not match */


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:54: ( ( L_PARAN )* (c1= constraint | c2= sizeConstraint ) ( R_PARAN )* )?
            {
                int alt38=2;
                switch ( LA(1) ) 
                {
                    case TRUE_LITERAL:
                    case FALSE_LITERAL:
                    case TRUE_SMALL_LITERAL:
                    case FALSE_SMALL_LITERAL:
                    case L_BRACE:
                    case L_PARAN:
                    case MINUS:
                    case CONTAINING_LITERAL:
                    case ALL_LITERAL:
                    case MIN_LITERAL:
                    case SIZE_LITERAL:
                    case PATTERN_LITERAL:
                    case CONSTRAINED_LITERAL:
                    case ENCODED_LITERAL:
                    case IDENTIFIER:
                    case NUMBER:
                    case BSTRING:
                    	{
                    		alt38=1;
                    	}
                        break;
                }

                switch (alt38) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:55: ( L_PARAN )* (c1= constraint | c2= sizeConstraint ) ( R_PARAN )*
            	    {

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:55: ( L_PARAN )*

            	        for (;;)
            	        {
            	            int alt35=2;
            	            switch ( LA(1) ) 
            	            {
            	            case L_PARAN:
            	            	{
            	            		{
            	            		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            		    */
            	            		    int LA35_1 = LA(2);
            	            		    if ( (synpred43_asn1(ctx)) ) 
            	            		    {
            	            		        alt35=1;
            	            		    }

            	            		}
            	            	}
            	                break;

            	            }

            	            switch (alt35) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: L_PARAN
            	        	    {
            	        	        L_PARAN85 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_sequenceOfType4197); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceOfTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        } 
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_L_PARAN; stream_L_PARAN->add(stream_L_PARAN, L_PARAN85, NULL); }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop35;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop35: ; /* Jump out to here if this rule does not match */


            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:64: (c1= constraint | c2= sizeConstraint )
            	        {
            	            int alt36=2;
            	            switch ( LA(1) ) 
            	            {
            	            case TRUE_LITERAL:
            	            case FALSE_LITERAL:
            	            case TRUE_SMALL_LITERAL:
            	            case FALSE_SMALL_LITERAL:
            	            case L_BRACE:
            	            case L_PARAN:
            	            case MINUS:
            	            case CONTAINING_LITERAL:
            	            case ALL_LITERAL:
            	            case MIN_LITERAL:
            	            case PATTERN_LITERAL:
            	            case CONSTRAINED_LITERAL:
            	            case ENCODED_LITERAL:
            	            case IDENTIFIER:
            	            case NUMBER:
            	            case BSTRING:
            	            	{
            	            		alt36=1;
            	            	}
            	                break;
            	            case SIZE_LITERAL:
            	            	{

            	            		{
            	            		    int LA36_12 = LA(2);
            	            		    if ( (synpred44_asn1(ctx)) ) 
            	            		    {
            	            		        alt36=1;
            	            		    }
            	            		    else if ( (ANTLR3_TRUE) ) 
            	            		    {
            	            		        alt36=2;
            	            		    }
            	            		    else 
            	            		    {
            	            		        if (BACKTRACKING>0)
            	            		        {
            	            		            FAILEDFLAG = ANTLR3_TRUE;
            	            		            return retval;
            	            		        }
            	            		    
            	            		        CONSTRUCTEX();
            	            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		        EXCEPTION->message      = (void *)"";
            	            		        EXCEPTION->decisionNum  = 36;
            	            		        EXCEPTION->state        = 12;


            	            		        goto rulesequenceOfTypeEx;
            	            		    }
            	            		}
            	            	}
            	                break;

            	            default:
            	                if (BACKTRACKING>0)
            	                {
            	                    FAILEDFLAG = ANTLR3_TRUE;
            	                    return retval;
            	                }
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 36;
            	                EXCEPTION->state        = 0;


            	                goto rulesequenceOfTypeEx;
            	            }

            	            switch (alt36) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:65: c1= constraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constraint_in_sequenceOfType4203);
            	        	        c1=constraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceOfTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_constraint; stream_constraint->add(stream_constraint, c1.tree, NULL); }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:81: c2= sizeConstraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_sizeConstraint_in_sequenceOfType4209);
            	        	        c2=sizeConstraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceOfTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_sizeConstraint; stream_sizeConstraint->add(stream_sizeConstraint, c2.tree, NULL); }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:100: ( R_PARAN )*

            	        for (;;)
            	        {
            	            int alt37=2;
            	            switch ( LA(1) ) 
            	            {
            	            case R_PARAN:
            	            	{
            	            		alt37=1;
            	            	}
            	                break;

            	            }

            	            switch (alt37) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: R_PARAN
            	        	    {
            	        	        R_PARAN86 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_sequenceOfType4212); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesequenceOfTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        } 
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_R_PARAN; stream_R_PARAN->add(stream_R_PARAN, R_PARAN86, NULL); }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop37;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop37: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }
            OF_LITERAL87 = (pANTLR3_COMMON_TOKEN) MATCHT(OF_LITERAL, &FOLLOW_OF_LITERAL_in_sequenceOfType4217); 
            if  (HASEXCEPTION())
            {
                goto rulesequenceOfTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_OF_LITERAL; stream_OF_LITERAL->add(stream_OF_LITERAL, OF_LITERAL87, NULL); }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:122: (tp= type | nt= namedType )
            {
                int alt39=2;
                switch ( LA(1) ) 
                {
                case BOOLEAN_LITERAL:
                case INTEGER_LITERAL:
                case IA5_STRING_LITERAL:
                case ENUMERATED_LITERAL:
                case BIT_LITERAL:
                case OCTET_LITERAL:
                case NULL_LITERAL:
                case SEQUENCE_LITERAL:
                case SET_LITERAL:
                case TYPE_IDENTIFIER_LITERAL:
                case ABSTRACT_SYNTAX_LITERAL:
                case L_BRACKET:
                case CHOICE_LITERAL:
                case OBJECT_LITERAL:
                	{
                		alt39=1;
                	}
                    break;
                case IDENTIFIER:
                	{
                		switch ( LA(2) ) 
                		{
                		case EOF:
                		case ASSIGN_OP:
                		case DOT:
                		case L_BRACE:
                		case R_BRACE:
                		case COMMA:
                		case L_PARAN:
                		case R_PARAN:
                		case OPTIONAL_LITERAL:
                		case DEFAULT_LITERAL:
                		case OF_LITERAL:
                		case EXCLAM:
                		case EXCEPT_LITERAL:
                		case POWER:
                		case PIPE:
                		case UNION_LITERAL:
                		case INTERSECTION_LITERAL:
                		case UNIQUE_LITERAL:
                		case END_LITERAL:
                		case DOUBLE_R_BRACKET:
                		case COLON:
                		case ENCODED_LITERAL:
                		case EXTENSTIONENDMARKER:
                			{
                				alt39=1;
                			}
                		    break;
                		case BOOLEAN_LITERAL:
                		case INTEGER_LITERAL:
                		case IA5_STRING_LITERAL:
                		case ENUMERATED_LITERAL:
                		case BIT_LITERAL:
                		case OCTET_LITERAL:
                		case NULL_LITERAL:
                		case SEQUENCE_LITERAL:
                		case SET_LITERAL:
                		case TYPE_IDENTIFIER_LITERAL:
                		case ABSTRACT_SYNTAX_LITERAL:
                		case L_BRACKET:
                		case CHOICE_LITERAL:
                		case OBJECT_LITERAL:
                			{
                				alt39=2;
                			}
                		    break;
                		case IDENTIFIER:
                			{

                				{
                				    int LA39_4 = LA(3);
                				    if ( (synpred47_asn1(ctx)) ) 
                				    {
                				        alt39=1;
                				    }
                				    else if ( (ANTLR3_TRUE) ) 
                				    {
                				        alt39=2;
                				    }
                				    else 
                				    {
                				        if (BACKTRACKING>0)
                				        {
                				            FAILEDFLAG = ANTLR3_TRUE;
                				            return retval;
                				        }
                				    
                				        CONSTRUCTEX();
                				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				        EXCEPTION->message      = (void *)"";
                				        EXCEPTION->decisionNum  = 39;
                				        EXCEPTION->state        = 4;


                				        goto rulesequenceOfTypeEx;
                				    }
                				}
                			}
                		    break;

                		default:
                		    if (BACKTRACKING>0)
                		    {
                		        FAILEDFLAG = ANTLR3_TRUE;
                		        return retval;
                		    }
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 39;
                		    EXCEPTION->state        = 2;


                		    goto rulesequenceOfTypeEx;
                		}

                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 39;
                    EXCEPTION->state        = 0;


                    goto rulesequenceOfTypeEx;
                }

                switch (alt39) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:123: tp= type
            	    {
            	        FOLLOWPUSH(FOLLOW_type_in_sequenceOfType4222);
            	        tp=type(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceOfTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_type; stream_type->add(stream_type, tp.tree, NULL); }

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:133: nt= namedType
            	    {
            	        FOLLOWPUSH(FOLLOW_namedType_in_sequenceOfType4228);
            	        nt=namedType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesequenceOfTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_namedType; stream_namedType->add(stream_namedType, nt.tree, NULL); }

            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : c2, SEQUENCE_LITERAL, tp, sz, nt, c1
             * token labels      : 
             * rule labels       : nt, retval, c1, c2, tp
             * token list labels : sz
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_sz;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_nt;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c2;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_tp;

            	stream_sz=antlr3RewriteRuleTOKENStreamNewAEV(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token sz", list_sz); 
            	stream_nt=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token nt", nt.tree != NULL ? nt.tree : NULL);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_c1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c1", c1.tree != NULL ? c1.tree : NULL);
            	stream_c2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c2", c2.tree != NULL ? c2.tree : NULL);
            	stream_tp=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token tp", tp.tree != NULL ? tp.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 248:3: -> ^( SEQUENCE_LITERAL[\"SEQUENCE_OF\"] ^( TAG_SPECIFIC ( $sz)* ( $c1)? ( $c2)? ( $tp)? ( $nt)? ) )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:248:6: ^( SEQUENCE_LITERAL[\"SEQUENCE_OF\"] ^( TAG_SPECIFIC ( $sz)* ( $c1)? ( $c2)? ( $tp)? ( $nt)? ) )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        #if 1 == 2
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, SEQUENCE_LITERAL, TOKTEXT("SEQUENCE_OF"))
            	        #else
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, SEQUENCE_LITERAL, (pANTLR3_UINT8)"SEQUENCE_OF")
            	        #endif
            	        , root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:248:40: ^( TAG_SPECIFIC ( $sz)* ( $c1)? ( $c2)? ( $tp)? ( $nt)? )
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TAG_SPECIFIC, (pANTLR3_UINT8)"TAG_SPECIFIC"), root_2));

            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:248:55: ( $sz)*
            	            {
            	            	while ( (stream_sz != NULL && stream_sz->hasNext(stream_sz))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_sz == NULL ? NULL : stream_sz->nextNode(stream_sz));

            	            	}
            	            	if (stream_sz != NULL) stream_sz->reset(stream_sz);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:248:60: ( $c1)?
            	            {
            	            	if ( (stream_c1 != NULL && stream_c1->hasNext(stream_c1))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_c1 == NULL ? NULL : stream_c1->nextTree(stream_c1));

            	            	}
            	            	if ( stream_c1 != NULL) stream_c1->reset(stream_c1);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:248:65: ( $c2)?
            	            {
            	            	if ( (stream_c2 != NULL && stream_c2->hasNext(stream_c2))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_c2 == NULL ? NULL : stream_c2->nextTree(stream_c2));

            	            	}
            	            	if ( stream_c2 != NULL) stream_c2->reset(stream_c2);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:248:70: ( $tp)?
            	            {
            	            	if ( (stream_tp != NULL && stream_tp->hasNext(stream_tp))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_tp == NULL ? NULL : stream_tp->nextTree(stream_tp));

            	            	}
            	            	if ( stream_tp != NULL) stream_tp->reset(stream_tp);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:248:75: ( $nt)?
            	            {
            	            	if ( (stream_nt != NULL && stream_nt->hasNext(stream_nt))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_nt == NULL ? NULL : stream_nt->nextTree(stream_nt));

            	            	}
            	            	if ( stream_nt != NULL) stream_nt->reset(stream_nt);

            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_sz != NULL) stream_sz->free(stream_sz);
            	if (stream_nt != NULL) stream_nt->free(stream_nt);
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_c1 != NULL) stream_c1->free(stream_c1);
            	if (stream_c2 != NULL) stream_c2->free(stream_c2);
            	if (stream_tp != NULL) stream_tp->free(stream_tp);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesequenceOfTypeEx; /* Prevent compiler warnings */
    rulesequenceOfTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_SEQUENCE_LITERAL != NULL) stream_SEQUENCE_LITERAL->free(stream_SEQUENCE_LITERAL);
        if (stream_SIZE_LITERAL != NULL) stream_SIZE_LITERAL->free(stream_SIZE_LITERAL);
        if (stream_L_PARAN != NULL) stream_L_PARAN->free(stream_L_PARAN);
        if (stream_OF_LITERAL != NULL) stream_OF_LITERAL->free(stream_OF_LITERAL);
        if (stream_R_PARAN != NULL) stream_R_PARAN->free(stream_R_PARAN);
        if (stream_namedType != NULL) stream_namedType->free(stream_namedType);
        if (stream_constraint != NULL) stream_constraint->free(stream_constraint);
        if (stream_type != NULL) stream_type->free(stream_type);
        if (stream_sizeConstraint != NULL) stream_sizeConstraint->free(stream_sizeConstraint);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(29, sequenceOfType_StartIndex); }

    return retval;
}
/* $ANTLR end sequenceOfType */

/** 
 * $ANTLR start sizeConstraint
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:251:1: sizeConstraint : SIZE_LITERAL constraint ;
 */
static asn1Parser_sizeConstraint_return
sizeConstraint(pasn1Parser ctx)
{   
    asn1Parser_sizeConstraint_return retval;
    ANTLR3_UINT32 sizeConstraint_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SIZE_LITERAL88;
    asn1Parser_constraint_return constraint89;
    #undef	RETURN_TYPE_constraint89
    #define	RETURN_TYPE_constraint89 asn1Parser_constraint_return

    pANTLR3_BASE_TREE SIZE_LITERAL88_tree;

    /* Initialize rule variables
     */
    sizeConstraint_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(30)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    SIZE_LITERAL88       = NULL;
    constraint89.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    SIZE_LITERAL88_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:251:16: ( SIZE_LITERAL constraint )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:251:18: SIZE_LITERAL constraint
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            SIZE_LITERAL88 = (pANTLR3_COMMON_TOKEN) MATCHT(SIZE_LITERAL, &FOLLOW_SIZE_LITERAL_in_sizeConstraint4272); 
            if  (HASEXCEPTION())
            {
                goto rulesizeConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            SIZE_LITERAL88_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SIZE_LITERAL88));
            ADAPTOR->addChild(ADAPTOR, root_0, SIZE_LITERAL88_tree);
            }
            FOLLOWPUSH(FOLLOW_constraint_in_sizeConstraint4274);
            constraint89=constraint(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesizeConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, constraint89.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesizeConstraintEx; /* Prevent compiler warnings */
    rulesizeConstraintEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(30, sizeConstraint_StartIndex); }

    return retval;
}
/* $ANTLR end sizeConstraint */

/** 
 * $ANTLR start parameterizedAssignment
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:254:1: parameterizedAssignment : ( parameterList ( ASSIGN_OP ( type | value | valueSet ) ) | ( definedObjectClass ASSIGN_OP ( object | objectClass | objectSet ) ) );
 */
static asn1Parser_parameterizedAssignment_return
parameterizedAssignment(pasn1Parser ctx)
{   
    asn1Parser_parameterizedAssignment_return retval;
    ANTLR3_UINT32 parameterizedAssignment_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ASSIGN_OP91;
    pANTLR3_COMMON_TOKEN    ASSIGN_OP96;
    asn1Parser_parameterList_return parameterList90;
    #undef	RETURN_TYPE_parameterList90
    #define	RETURN_TYPE_parameterList90 asn1Parser_parameterList_return

    asn1Parser_type_return type92;
    #undef	RETURN_TYPE_type92
    #define	RETURN_TYPE_type92 asn1Parser_type_return

    asn1Parser_value_return value93;
    #undef	RETURN_TYPE_value93
    #define	RETURN_TYPE_value93 asn1Parser_value_return

    asn1Parser_valueSet_return valueSet94;
    #undef	RETURN_TYPE_valueSet94
    #define	RETURN_TYPE_valueSet94 asn1Parser_valueSet_return

    asn1Parser_definedObjectClass_return definedObjectClass95;
    #undef	RETURN_TYPE_definedObjectClass95
    #define	RETURN_TYPE_definedObjectClass95 asn1Parser_definedObjectClass_return

    asn1Parser_object_return object97;
    #undef	RETURN_TYPE_object97
    #define	RETURN_TYPE_object97 asn1Parser_object_return

    asn1Parser_objectClass_return objectClass98;
    #undef	RETURN_TYPE_objectClass98
    #define	RETURN_TYPE_objectClass98 asn1Parser_objectClass_return

    asn1Parser_objectSet_return objectSet99;
    #undef	RETURN_TYPE_objectSet99
    #define	RETURN_TYPE_objectSet99 asn1Parser_objectSet_return

    pANTLR3_BASE_TREE ASSIGN_OP91_tree;
    pANTLR3_BASE_TREE ASSIGN_OP96_tree;

    /* Initialize rule variables
     */
    parameterizedAssignment_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(31)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    ASSIGN_OP91       = NULL;
    ASSIGN_OP96       = NULL;
    parameterList90.tree = NULL;

    type92.tree = NULL;

    value93.tree = NULL;

    valueSet94.tree = NULL;

    definedObjectClass95.tree = NULL;

    object97.tree = NULL;

    objectClass98.tree = NULL;

    objectSet99.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    ASSIGN_OP91_tree   = NULL;
    ASSIGN_OP96_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:254:25: ( parameterList ( ASSIGN_OP ( type | value | valueSet ) ) | ( definedObjectClass ASSIGN_OP ( object | objectClass | objectSet ) ) )
            
            ANTLR3_UINT32 alt42;

            alt42=2;

            switch ( LA(1) ) 
            {
            case L_BRACE:
            	{
            		alt42=1;
            	}
                break;
            case TYPE_IDENTIFIER_LITERAL:
            case ABSTRACT_SYNTAX_LITERAL:
            case IDENTIFIER:
            	{
            		alt42=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 42;
                EXCEPTION->state        = 0;


                goto ruleparameterizedAssignmentEx;
            }

            switch (alt42) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:255:2: parameterList ( ASSIGN_OP ( type | value | valueSet ) )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_parameterList_in_parameterizedAssignment4287);
        	        parameterList90=parameterList(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparameterizedAssignmentEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, parameterList90.tree);
        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:256:1: ( ASSIGN_OP ( type | value | valueSet ) )
        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:256:2: ASSIGN_OP ( type | value | valueSet )
        	        {
        	            ASSIGN_OP91 = (pANTLR3_COMMON_TOKEN) MATCHT(ASSIGN_OP, &FOLLOW_ASSIGN_OP_in_parameterizedAssignment4291); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleparameterizedAssignmentEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }
        	            if ( BACKTRACKING==0 ) {
        	            ASSIGN_OP91_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ASSIGN_OP91));
        	            ADAPTOR->addChild(ADAPTOR, root_0, ASSIGN_OP91_tree);
        	            }

        	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:257:2: ( type | value | valueSet )
        	            {
        	                int alt40=3;
        	                switch ( LA(1) ) 
        	                {
        	                case BOOLEAN_LITERAL:
        	                case INTEGER_LITERAL:
        	                case IA5_STRING_LITERAL:
        	                case ENUMERATED_LITERAL:
        	                case BIT_LITERAL:
        	                case OCTET_LITERAL:
        	                case NULL_LITERAL:
        	                case SEQUENCE_LITERAL:
        	                case SET_LITERAL:
        	                case TYPE_IDENTIFIER_LITERAL:
        	                case ABSTRACT_SYNTAX_LITERAL:
        	                case L_BRACKET:
        	                case CHOICE_LITERAL:
        	                case OBJECT_LITERAL:
        	                	{
        	                		alt40=1;
        	                	}
        	                    break;
        	                case IDENTIFIER:
        	                	{

        	                		{
        	                		    int LA40_2 = LA(2);
        	                		    if ( (synpred48_asn1(ctx)) ) 
        	                		    {
        	                		        alt40=1;
        	                		    }
        	                		    else if ( (synpred49_asn1(ctx)) ) 
        	                		    {
        	                		        alt40=2;
        	                		    }
        	                		    else 
        	                		    {
        	                		        if (BACKTRACKING>0)
        	                		        {
        	                		            FAILEDFLAG = ANTLR3_TRUE;
        	                		            return retval;
        	                		        }
        	                		    
        	                		        CONSTRUCTEX();
        	                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                		        EXCEPTION->message      = (void *)"";
        	                		        EXCEPTION->decisionNum  = 40;
        	                		        EXCEPTION->state        = 2;


        	                		        goto ruleparameterizedAssignmentEx;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	                case TRUE_LITERAL:
        	                case FALSE_LITERAL:
        	                case TRUE_SMALL_LITERAL:
        	                case FALSE_SMALL_LITERAL:
        	                case MINUS:
        	                case NUMBER:
        	                case BSTRING:
        	                	{
        	                		alt40=2;
        	                	}
        	                    break;
        	                case L_BRACE:
        	                	{
        	                		switch ( LA(2) ) 
        	                		{
        	                		case IDENTIFIER:
        	                			{
        	                				switch ( LA(3) ) 
        	                				{
        	                				case DOUBLE_DOT:
        	                				case LESS_THAN:
        	                				case COMMA:
        	                				case EXCEPT_LITERAL:
        	                				case POWER:
        	                				case PIPE:
        	                				case UNION_LITERAL:
        	                				case INTERSECTION_LITERAL:
        	                				case COLON:
        	                					{
        	                						alt40=3;
        	                					}
        	                				    break;
        	                				case DOT:
        	                				case L_BRACE:
        	                				case L_PARAN:
        	                				case IDENTIFIER:
        	                				case NUMBER:
        	                					{
        	                						alt40=2;
        	                					}
        	                				    break;
        	                				case R_BRACE:
        	                					{

        	                						{
        	                						    int LA40_8 = LA(4);
        	                						    if ( (synpred49_asn1(ctx)) ) 
        	                						    {
        	                						        alt40=2;
        	                						    }
        	                						    else if ( (ANTLR3_TRUE) ) 
        	                						    {
        	                						        alt40=3;
        	                						    }
        	                						    else 
        	                						    {
        	                						        if (BACKTRACKING>0)
        	                						        {
        	                						            FAILEDFLAG = ANTLR3_TRUE;
        	                						            return retval;
        	                						        }
        	                						    
        	                						        CONSTRUCTEX();
        	                						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                						        EXCEPTION->message      = (void *)"";
        	                						        EXCEPTION->decisionNum  = 40;
        	                						        EXCEPTION->state        = 8;


        	                						        goto ruleparameterizedAssignmentEx;
        	                						    }
        	                						}
        	                					}
        	                				    break;

        	                				default:
        	                				    if (BACKTRACKING>0)
        	                				    {
        	                				        FAILEDFLAG = ANTLR3_TRUE;
        	                				        return retval;
        	                				    }
        	                				    CONSTRUCTEX();
        	                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                				    EXCEPTION->message      = (void *)"";
        	                				    EXCEPTION->decisionNum  = 40;
        	                				    EXCEPTION->state        = 5;


        	                				    goto ruleparameterizedAssignmentEx;
        	                				}

        	                			}
        	                		    break;
        	                		case TRUE_LITERAL:
        	                		case FALSE_LITERAL:
        	                		case TRUE_SMALL_LITERAL:
        	                		case FALSE_SMALL_LITERAL:
        	                		case L_BRACE:
        	                		case MINUS:
        	                		case ALL_LITERAL:
        	                		case MIN_LITERAL:
        	                		case SIZE_LITERAL:
        	                		case PATTERN_LITERAL:
        	                		case BSTRING:
        	                			{
        	                				alt40=3;
        	                			}
        	                		    break;
        	                		case NUMBER:
        	                			{
        	                				switch ( LA(3) ) 
        	                				{
        	                				case DOUBLE_DOT:
        	                				case LESS_THAN:
        	                				case COMMA:
        	                				case EXCEPT_LITERAL:
        	                				case POWER:
        	                				case PIPE:
        	                				case UNION_LITERAL:
        	                				case INTERSECTION_LITERAL:
        	                					{
        	                						alt40=3;
        	                					}
        	                				    break;
        	                				case R_BRACE:
        	                					{

        	                						{
        	                						    int LA40_8 = LA(4);
        	                						    if ( (synpred49_asn1(ctx)) ) 
        	                						    {
        	                						        alt40=2;
        	                						    }
        	                						    else if ( (ANTLR3_TRUE) ) 
        	                						    {
        	                						        alt40=3;
        	                						    }
        	                						    else 
        	                						    {
        	                						        if (BACKTRACKING>0)
        	                						        {
        	                						            FAILEDFLAG = ANTLR3_TRUE;
        	                						            return retval;
        	                						        }
        	                						    
        	                						        CONSTRUCTEX();
        	                						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                						        EXCEPTION->message      = (void *)"";
        	                						        EXCEPTION->decisionNum  = 40;
        	                						        EXCEPTION->state        = 8;


        	                						        goto ruleparameterizedAssignmentEx;
        	                						    }
        	                						}
        	                					}
        	                				    break;
        	                				case IDENTIFIER:
        	                				case NUMBER:
        	                					{
        	                						alt40=2;
        	                					}
        	                				    break;

        	                				default:
        	                				    if (BACKTRACKING>0)
        	                				    {
        	                				        FAILEDFLAG = ANTLR3_TRUE;
        	                				        return retval;
        	                				    }
        	                				    CONSTRUCTEX();
        	                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                				    EXCEPTION->message      = (void *)"";
        	                				    EXCEPTION->decisionNum  = 40;
        	                				    EXCEPTION->state        = 7;


        	                				    goto ruleparameterizedAssignmentEx;
        	                				}

        	                			}
        	                		    break;

        	                		default:
        	                		    if (BACKTRACKING>0)
        	                		    {
        	                		        FAILEDFLAG = ANTLR3_TRUE;
        	                		        return retval;
        	                		    }
        	                		    CONSTRUCTEX();
        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                		    EXCEPTION->message      = (void *)"";
        	                		    EXCEPTION->decisionNum  = 40;
        	                		    EXCEPTION->state        = 4;


        	                		    goto ruleparameterizedAssignmentEx;
        	                		}

        	                	}
        	                    break;

        	                default:
        	                    if (BACKTRACKING>0)
        	                    {
        	                        FAILEDFLAG = ANTLR3_TRUE;
        	                        return retval;
        	                    }
        	                    CONSTRUCTEX();
        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                    EXCEPTION->message      = (void *)"";
        	                    EXCEPTION->decisionNum  = 40;
        	                    EXCEPTION->state        = 0;


        	                    goto ruleparameterizedAssignmentEx;
        	                }

        	                switch (alt40) 
        	                {
        	            	case 1:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:257:3: type
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_type_in_parameterizedAssignment4296);
        	            	        type92=type(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleparameterizedAssignmentEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type92.tree);

        	            	    }
        	            	    break;
        	            	case 2:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:258:5: value
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_value_in_parameterizedAssignment4303);
        	            	        value93=value(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleparameterizedAssignmentEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value93.tree);

        	            	    }
        	            	    break;
        	            	case 3:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:259:5: valueSet
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_valueSet_in_parameterizedAssignment4309);
        	            	        valueSet94=valueSet(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleparameterizedAssignmentEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, valueSet94.tree);

        	            	    }
        	            	    break;

        	                }
        	            }

        	        }


        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:262:2: ( definedObjectClass ASSIGN_OP ( object | objectClass | objectSet ) )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:262:2: ( definedObjectClass ASSIGN_OP ( object | objectClass | objectSet ) )
        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:262:4: definedObjectClass ASSIGN_OP ( object | objectClass | objectSet )
        	        {
        	            FOLLOWPUSH(FOLLOW_definedObjectClass_in_parameterizedAssignment4319);
        	            definedObjectClass95=definedObjectClass(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleparameterizedAssignmentEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }
        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedObjectClass95.tree);
        	            ASSIGN_OP96 = (pANTLR3_COMMON_TOKEN) MATCHT(ASSIGN_OP, &FOLLOW_ASSIGN_OP_in_parameterizedAssignment4321); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleparameterizedAssignmentEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }

        	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:263:2: ( object | objectClass | objectSet )
        	            {
        	                int alt41=3;
        	                switch ( LA(1) ) 
        	                {
        	                case IDENTIFIER:
        	                	{

        	                		{
        	                		    int LA41_1 = LA(2);
        	                		    if ( (synpred51_asn1(ctx)) ) 
        	                		    {
        	                		        alt41=1;
        	                		    }
        	                		    else if ( (synpred52_asn1(ctx)) ) 
        	                		    {
        	                		        alt41=2;
        	                		    }
        	                		    else 
        	                		    {
        	                		        if (BACKTRACKING>0)
        	                		        {
        	                		            FAILEDFLAG = ANTLR3_TRUE;
        	                		            return retval;
        	                		        }
        	                		    
        	                		        CONSTRUCTEX();
        	                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                		        EXCEPTION->message      = (void *)"";
        	                		        EXCEPTION->decisionNum  = 41;
        	                		        EXCEPTION->state        = 1;


        	                		        goto ruleparameterizedAssignmentEx;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	                case TRUE_LITERAL:
        	                case FALSE_LITERAL:
        	                case TRUE_SMALL_LITERAL:
        	                case FALSE_SMALL_LITERAL:
        	                case MINUS:
        	                case TYPE_IDENTIFIER_LITERAL:
        	                case ABSTRACT_SYNTAX_LITERAL:
        	                case CLASS_LITERAL:
        	                case NUMBER:
        	                case BSTRING:
        	                	{
        	                		alt41=2;
        	                	}
        	                    break;
        	                case L_BRACE:
        	                	{
        	                		switch ( LA(2) ) 
        	                		{
        	                		case NUMBER:
        	                			{
        	                				switch ( LA(3) ) 
        	                				{
        	                				case DOUBLE_DOT:
        	                				case LESS_THAN:
        	                				case COMMA:
        	                				case EXCEPT_LITERAL:
        	                				case POWER:
        	                				case PIPE:
        	                				case UNION_LITERAL:
        	                				case INTERSECTION_LITERAL:
        	                					{
        	                						alt41=3;
        	                					}
        	                				    break;
        	                				case R_BRACE:
        	                					{

        	                						{
        	                						    int LA41_8 = LA(4);
        	                						    if ( (synpred52_asn1(ctx)) ) 
        	                						    {
        	                						        alt41=2;
        	                						    }
        	                						    else if ( (ANTLR3_TRUE) ) 
        	                						    {
        	                						        alt41=3;
        	                						    }
        	                						    else 
        	                						    {
        	                						        if (BACKTRACKING>0)
        	                						        {
        	                						            FAILEDFLAG = ANTLR3_TRUE;
        	                						            return retval;
        	                						        }
        	                						    
        	                						        CONSTRUCTEX();
        	                						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                						        EXCEPTION->message      = (void *)"";
        	                						        EXCEPTION->decisionNum  = 41;
        	                						        EXCEPTION->state        = 8;


        	                						        goto ruleparameterizedAssignmentEx;
        	                						    }
        	                						}
        	                					}
        	                				    break;
        	                				case IDENTIFIER:
        	                				case NUMBER:
        	                					{
        	                						alt41=2;
        	                					}
        	                				    break;

        	                				default:
        	                				    if (BACKTRACKING>0)
        	                				    {
        	                				        FAILEDFLAG = ANTLR3_TRUE;
        	                				        return retval;
        	                				    }
        	                				    CONSTRUCTEX();
        	                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                				    EXCEPTION->message      = (void *)"";
        	                				    EXCEPTION->decisionNum  = 41;
        	                				    EXCEPTION->state        = 5;


        	                				    goto ruleparameterizedAssignmentEx;
        	                				}

        	                			}
        	                		    break;
        	                		case IDENTIFIER:
        	                			{
        	                				switch ( LA(3) ) 
        	                				{
        	                				case DOUBLE_DOT:
        	                				case LESS_THAN:
        	                				case COMMA:
        	                				case EXCEPT_LITERAL:
        	                				case POWER:
        	                				case PIPE:
        	                				case UNION_LITERAL:
        	                				case INTERSECTION_LITERAL:
        	                				case COLON:
        	                					{
        	                						alt41=3;
        	                					}
        	                				    break;
        	                				case R_BRACE:
        	                					{

        	                						{
        	                						    int LA41_8 = LA(4);
        	                						    if ( (synpred52_asn1(ctx)) ) 
        	                						    {
        	                						        alt41=2;
        	                						    }
        	                						    else if ( (ANTLR3_TRUE) ) 
        	                						    {
        	                						        alt41=3;
        	                						    }
        	                						    else 
        	                						    {
        	                						        if (BACKTRACKING>0)
        	                						        {
        	                						            FAILEDFLAG = ANTLR3_TRUE;
        	                						            return retval;
        	                						        }
        	                						    
        	                						        CONSTRUCTEX();
        	                						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                						        EXCEPTION->message      = (void *)"";
        	                						        EXCEPTION->decisionNum  = 41;
        	                						        EXCEPTION->state        = 8;


        	                						        goto ruleparameterizedAssignmentEx;
        	                						    }
        	                						}
        	                					}
        	                				    break;
        	                				case DOT:
        	                				case L_BRACE:
        	                				case L_PARAN:
        	                				case IDENTIFIER:
        	                				case NUMBER:
        	                					{
        	                						alt41=2;
        	                					}
        	                				    break;

        	                				default:
        	                				    if (BACKTRACKING>0)
        	                				    {
        	                				        FAILEDFLAG = ANTLR3_TRUE;
        	                				        return retval;
        	                				    }
        	                				    CONSTRUCTEX();
        	                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                				    EXCEPTION->message      = (void *)"";
        	                				    EXCEPTION->decisionNum  = 41;
        	                				    EXCEPTION->state        = 6;


        	                				    goto ruleparameterizedAssignmentEx;
        	                				}

        	                			}
        	                		    break;
        	                		case TRUE_LITERAL:
        	                		case FALSE_LITERAL:
        	                		case ELLIPSIS:
        	                		case TRUE_SMALL_LITERAL:
        	                		case FALSE_SMALL_LITERAL:
        	                		case L_BRACE:
        	                		case MINUS:
        	                		case ALL_LITERAL:
        	                		case MIN_LITERAL:
        	                		case SIZE_LITERAL:
        	                		case PATTERN_LITERAL:
        	                		case BSTRING:
        	                			{
        	                				alt41=3;
        	                			}
        	                		    break;

        	                		default:
        	                		    if (BACKTRACKING>0)
        	                		    {
        	                		        FAILEDFLAG = ANTLR3_TRUE;
        	                		        return retval;
        	                		    }
        	                		    CONSTRUCTEX();
        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                		    EXCEPTION->message      = (void *)"";
        	                		    EXCEPTION->decisionNum  = 41;
        	                		    EXCEPTION->state        = 3;


        	                		    goto ruleparameterizedAssignmentEx;
        	                		}

        	                	}
        	                    break;

        	                default:
        	                    if (BACKTRACKING>0)
        	                    {
        	                        FAILEDFLAG = ANTLR3_TRUE;
        	                        return retval;
        	                    }
        	                    CONSTRUCTEX();
        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                    EXCEPTION->message      = (void *)"";
        	                    EXCEPTION->decisionNum  = 41;
        	                    EXCEPTION->state        = 0;


        	                    goto ruleparameterizedAssignmentEx;
        	                }

        	                switch (alt41) 
        	                {
        	            	case 1:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:263:4: object
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_object_in_parameterizedAssignment4327);
        	            	        object97=object(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleparameterizedAssignmentEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, object97.tree);

        	            	    }
        	            	    break;
        	            	case 2:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:264:5: objectClass
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_objectClass_in_parameterizedAssignment4334);
        	            	        objectClass98=objectClass(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleparameterizedAssignmentEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectClass98.tree);

        	            	    }
        	            	    break;
        	            	case 3:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:265:5: objectSet
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_objectSet_in_parameterizedAssignment4340);
        	            	        objectSet99=objectSet(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruleparameterizedAssignmentEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectSet99.tree);

        	            	    }
        	            	    break;

        	                }
        	            }

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleparameterizedAssignmentEx; /* Prevent compiler warnings */
    ruleparameterizedAssignmentEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(31, parameterizedAssignment_StartIndex); }

    return retval;
}
/* $ANTLR end parameterizedAssignment */

/** 
 * $ANTLR start parameterList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:276:1: parameterList : L_BRACE parameter ( COMMA parameter )* R_BRACE ;
 */
static asn1Parser_parameterList_return
parameterList(pasn1Parser ctx)
{   
    asn1Parser_parameterList_return retval;
    ANTLR3_UINT32 parameterList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    L_BRACE100;
    pANTLR3_COMMON_TOKEN    COMMA102;
    pANTLR3_COMMON_TOKEN    R_BRACE104;
    asn1Parser_parameter_return parameter101;
    #undef	RETURN_TYPE_parameter101
    #define	RETURN_TYPE_parameter101 asn1Parser_parameter_return

    asn1Parser_parameter_return parameter103;
    #undef	RETURN_TYPE_parameter103
    #define	RETURN_TYPE_parameter103 asn1Parser_parameter_return

    pANTLR3_BASE_TREE L_BRACE100_tree;
    pANTLR3_BASE_TREE COMMA102_tree;
    pANTLR3_BASE_TREE R_BRACE104_tree;

    /* Initialize rule variables
     */
    parameterList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(32)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    L_BRACE100       = NULL;
    COMMA102       = NULL;
    R_BRACE104       = NULL;
    parameter101.tree = NULL;

    parameter103.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    L_BRACE100_tree   = NULL;
    COMMA102_tree   = NULL;
    R_BRACE104_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:276:15: ( L_BRACE parameter ( COMMA parameter )* R_BRACE )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:276:17: L_BRACE parameter ( COMMA parameter )* R_BRACE
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            L_BRACE100 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_parameterList4360); 
            if  (HASEXCEPTION())
            {
                goto ruleparameterListEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            L_BRACE100_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, L_BRACE100));
            ADAPTOR->addChild(ADAPTOR, root_0, L_BRACE100_tree);
            }
            FOLLOWPUSH(FOLLOW_parameter_in_parameterList4362);
            parameter101=parameter(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameterListEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, parameter101.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:276:35: ( COMMA parameter )*

            for (;;)
            {
                int alt43=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt43=1;
                	}
                    break;

                }

                switch (alt43) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:276:36: COMMA parameter
            	    {
            	        COMMA102 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_parameterList4365); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparameterListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        COMMA102_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA102));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA102_tree);
            	        }
            	        FOLLOWPUSH(FOLLOW_parameter_in_parameterList4367);
            	        parameter103=parameter(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparameterListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, parameter103.tree);

            	    }
            	    break;

            	default:
            	    goto loop43;	/* break out of the loop */
            	    break;
                }
            }
            loop43: ; /* Jump out to here if this rule does not match */

            R_BRACE104 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_parameterList4371); 
            if  (HASEXCEPTION())
            {
                goto ruleparameterListEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            R_BRACE104_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, R_BRACE104));
            ADAPTOR->addChild(ADAPTOR, root_0, R_BRACE104_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparameterListEx; /* Prevent compiler warnings */
    ruleparameterListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(32, parameterList_StartIndex); }

    return retval;
}
/* $ANTLR end parameterList */

/** 
 * $ANTLR start parameter
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:278:1: parameter : ( paramGovernor COLON )? IDENTIFIER ;
 */
static asn1Parser_parameter_return
parameter(pasn1Parser ctx)
{   
    asn1Parser_parameter_return retval;
    ANTLR3_UINT32 parameter_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COLON106;
    pANTLR3_COMMON_TOKEN    IDENTIFIER107;
    asn1Parser_paramGovernor_return paramGovernor105;
    #undef	RETURN_TYPE_paramGovernor105
    #define	RETURN_TYPE_paramGovernor105 asn1Parser_paramGovernor_return

    pANTLR3_BASE_TREE COLON106_tree;
    pANTLR3_BASE_TREE IDENTIFIER107_tree;

    /* Initialize rule variables
     */
    parameter_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(33)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COLON106       = NULL;
    IDENTIFIER107       = NULL;
    paramGovernor105.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COLON106_tree   = NULL;
    IDENTIFIER107_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:278:11: ( ( paramGovernor COLON )? IDENTIFIER )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:278:13: ( paramGovernor COLON )? IDENTIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:278:13: ( paramGovernor COLON )?
            {
                int alt44=2;
                switch ( LA(1) ) 
                {
                    case BOOLEAN_LITERAL:
                    case INTEGER_LITERAL:
                    case IA5_STRING_LITERAL:
                    case ENUMERATED_LITERAL:
                    case BIT_LITERAL:
                    case OCTET_LITERAL:
                    case NULL_LITERAL:
                    case SEQUENCE_LITERAL:
                    case SET_LITERAL:
                    case TYPE_IDENTIFIER_LITERAL:
                    case ABSTRACT_SYNTAX_LITERAL:
                    case L_BRACKET:
                    case CHOICE_LITERAL:
                    case OBJECT_LITERAL:
                    	{
                    		alt44=1;
                    	}
                        break;
                    case IDENTIFIER:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		    case DOT:
                    		    case L_BRACE:
                    		    case L_PARAN:
                    		    case COLON:
                    		    	{
                    		    		alt44=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt44) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:278:14: paramGovernor COLON
            	    {
            	        FOLLOWPUSH(FOLLOW_paramGovernor_in_parameter4381);
            	        paramGovernor105=paramGovernor(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparameterEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, paramGovernor105.tree);
            	        COLON106 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_parameter4383); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparameterEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        COLON106_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON106));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COLON106_tree);
            	        }

            	    }
            	    break;

                }
            }
            IDENTIFIER107 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_parameter4387); 
            if  (HASEXCEPTION())
            {
                goto ruleparameterEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER107_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER107));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER107_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparameterEx; /* Prevent compiler warnings */
    ruleparameterEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(33, parameter_StartIndex); }

    return retval;
}
/* $ANTLR end parameter */

/** 
 * $ANTLR start paramGovernor
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:280:1: paramGovernor : ( governor | IDENTIFIER );
 */
static asn1Parser_paramGovernor_return
paramGovernor(pasn1Parser ctx)
{   
    asn1Parser_paramGovernor_return retval;
    ANTLR3_UINT32 paramGovernor_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER109;
    asn1Parser_governor_return governor108;
    #undef	RETURN_TYPE_governor108
    #define	RETURN_TYPE_governor108 asn1Parser_governor_return

    pANTLR3_BASE_TREE IDENTIFIER109_tree;

    /* Initialize rule variables
     */
    paramGovernor_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(34)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IDENTIFIER109       = NULL;
    governor108.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER109_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:280:15: ( governor | IDENTIFIER )
            
            ANTLR3_UINT32 alt45;

            alt45=2;

            switch ( LA(1) ) 
            {
            case BOOLEAN_LITERAL:
            case INTEGER_LITERAL:
            case IA5_STRING_LITERAL:
            case ENUMERATED_LITERAL:
            case BIT_LITERAL:
            case OCTET_LITERAL:
            case NULL_LITERAL:
            case SEQUENCE_LITERAL:
            case SET_LITERAL:
            case TYPE_IDENTIFIER_LITERAL:
            case ABSTRACT_SYNTAX_LITERAL:
            case L_BRACKET:
            case CHOICE_LITERAL:
            case OBJECT_LITERAL:
            	{
            		alt45=1;
            	}
                break;
            case IDENTIFIER:
            	{

            		{
            		    int LA45_2 = LA(2);
            		    if ( (synpred55_asn1(ctx)) ) 
            		    {
            		        alt45=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt45=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 45;
            		        EXCEPTION->state        = 2;


            		        goto ruleparamGovernorEx;
            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 45;
                EXCEPTION->state        = 0;


                goto ruleparamGovernorEx;
            }

            switch (alt45) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:280:17: governor
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_governor_in_paramGovernor4395);
        	        governor108=governor(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparamGovernorEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, governor108.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:280:28: IDENTIFIER
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        IDENTIFIER109 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_paramGovernor4399); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparamGovernorEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        IDENTIFIER109_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER109));
        	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER109_tree);
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleparamGovernorEx; /* Prevent compiler warnings */
    ruleparamGovernorEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(34, paramGovernor_StartIndex); }

    return retval;
}
/* $ANTLR end paramGovernor */

/** 
 * $ANTLR start governor
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:285:1: governor : ( type | definedObjectClass );
 */
static asn1Parser_governor_return
governor(pasn1Parser ctx)
{   
    asn1Parser_governor_return retval;
    ANTLR3_UINT32 governor_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_type_return type110;
    #undef	RETURN_TYPE_type110
    #define	RETURN_TYPE_type110 asn1Parser_type_return

    asn1Parser_definedObjectClass_return definedObjectClass111;
    #undef	RETURN_TYPE_definedObjectClass111
    #define	RETURN_TYPE_definedObjectClass111 asn1Parser_definedObjectClass_return


    /* Initialize rule variables
     */
    governor_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(35)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    type110.tree = NULL;

    definedObjectClass111.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:285:10: ( type | definedObjectClass )
            
            ANTLR3_UINT32 alt46;

            alt46=2;

            switch ( LA(1) ) 
            {
            case BOOLEAN_LITERAL:
            case INTEGER_LITERAL:
            case IA5_STRING_LITERAL:
            case ENUMERATED_LITERAL:
            case BIT_LITERAL:
            case OCTET_LITERAL:
            case NULL_LITERAL:
            case SEQUENCE_LITERAL:
            case SET_LITERAL:
            case L_BRACKET:
            case CHOICE_LITERAL:
            case OBJECT_LITERAL:
            	{
            		alt46=1;
            	}
                break;
            case IDENTIFIER:
            	{

            		{
            		    int LA46_13 = LA(2);
            		    if ( (synpred56_asn1(ctx)) ) 
            		    {
            		        alt46=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt46=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 46;
            		        EXCEPTION->state        = 13;


            		        goto rulegovernorEx;
            		    }
            		}
            	}
                break;
            case TYPE_IDENTIFIER_LITERAL:
            	{

            		{
            		    int LA46_14 = LA(2);
            		    if ( (synpred56_asn1(ctx)) ) 
            		    {
            		        alt46=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt46=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 46;
            		        EXCEPTION->state        = 14;


            		        goto rulegovernorEx;
            		    }
            		}
            	}
                break;
            case ABSTRACT_SYNTAX_LITERAL:
            	{

            		{
            		    int LA46_15 = LA(2);
            		    if ( (synpred56_asn1(ctx)) ) 
            		    {
            		        alt46=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt46=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 46;
            		        EXCEPTION->state        = 15;


            		        goto rulegovernorEx;
            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 46;
                EXCEPTION->state        = 0;


                goto rulegovernorEx;
            }

            switch (alt46) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:285:12: type
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_type_in_governor4411);
        	        type110=type(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegovernorEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type110.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:285:19: definedObjectClass
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_definedObjectClass_in_governor4415);
        	        definedObjectClass111=definedObjectClass(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegovernorEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedObjectClass111.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulegovernorEx; /* Prevent compiler warnings */
    rulegovernorEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(35, governor_StartIndex); }

    return retval;
}
/* $ANTLR end governor */

/** 
 * $ANTLR start objectClassAssignment
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:289:1: objectClassAssignment : ASSIGN_OP objectClass ;
 */
static asn1Parser_objectClassAssignment_return
objectClassAssignment(pasn1Parser ctx)
{   
    asn1Parser_objectClassAssignment_return retval;
    ANTLR3_UINT32 objectClassAssignment_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ASSIGN_OP112;
    asn1Parser_objectClass_return objectClass113;
    #undef	RETURN_TYPE_objectClass113
    #define	RETURN_TYPE_objectClass113 asn1Parser_objectClass_return

    pANTLR3_BASE_TREE ASSIGN_OP112_tree;

    /* Initialize rule variables
     */
    objectClassAssignment_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(36)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    ASSIGN_OP112       = NULL;
    objectClass113.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    ASSIGN_OP112_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:289:23: ( ASSIGN_OP objectClass )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:289:40: ASSIGN_OP objectClass
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            ASSIGN_OP112 = (pANTLR3_COMMON_TOKEN) MATCHT(ASSIGN_OP, &FOLLOW_ASSIGN_OP_in_objectClassAssignment4429); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectClassAssignmentEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_objectClass_in_objectClassAssignment4432);
            objectClass113=objectClass(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobjectClassAssignmentEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectClass113.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectClassAssignmentEx; /* Prevent compiler warnings */
    ruleobjectClassAssignmentEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(36, objectClassAssignment_StartIndex); }

    return retval;
}
/* $ANTLR end objectClassAssignment */

/** 
 * $ANTLR start objectClass
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:292:1: objectClass : (a1= definedObjectClass | a2= objectClassDefn | a3= value -> ^( VALUE_NODE ( $a1)? ( $a2)? ( $a3)? ) );
 */
static asn1Parser_objectClass_return
objectClass(pasn1Parser ctx)
{   
    asn1Parser_objectClass_return retval;
    ANTLR3_UINT32 objectClass_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_definedObjectClass_return a1;
    #undef	RETURN_TYPE_a1
    #define	RETURN_TYPE_a1 asn1Parser_definedObjectClass_return

    asn1Parser_objectClassDefn_return a2;
    #undef	RETURN_TYPE_a2
    #define	RETURN_TYPE_a2 asn1Parser_objectClassDefn_return

    asn1Parser_value_return a3;
    #undef	RETURN_TYPE_a3
    #define	RETURN_TYPE_a3 asn1Parser_value_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_value;
    /* Initialize rule variables
     */
    objectClass_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(37)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    a1.tree = NULL;

    a2.tree = NULL;

    a3.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_value   = NULL;
    #define CREATE_stream_value  if (stream_value == NULL) {stream_value = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule value"); }

    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:292:13: (a1= definedObjectClass | a2= objectClassDefn | a3= value -> ^( VALUE_NODE ( $a1)? ( $a2)? ( $a3)? ) )
            
            ANTLR3_UINT32 alt47;

            alt47=3;

            switch ( LA(1) ) 
            {
            case IDENTIFIER:
            	{

            		{
            		    int LA47_1 = LA(2);
            		    if ( (synpred57_asn1(ctx)) ) 
            		    {
            		        alt47=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt47=3;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 47;
            		        EXCEPTION->state        = 1;


            		        goto ruleobjectClassEx;
            		    }
            		}
            	}
                break;
            case TYPE_IDENTIFIER_LITERAL:
            case ABSTRACT_SYNTAX_LITERAL:
            	{
            		alt47=1;
            	}
                break;
            case CLASS_LITERAL:
            	{
            		alt47=2;
            	}
                break;
            case TRUE_LITERAL:
            case FALSE_LITERAL:
            case TRUE_SMALL_LITERAL:
            case FALSE_SMALL_LITERAL:
            case L_BRACE:
            case MINUS:
            case NUMBER:
            case BSTRING:
            	{
            		alt47=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 47;
                EXCEPTION->state        = 0;


                goto ruleobjectClassEx;
            }

            switch (alt47) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:292:15: a1= definedObjectClass
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_definedObjectClass_in_objectClass4444);
        	        a1=definedObjectClass(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectClassEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, a1.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:292:39: a2= objectClassDefn
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_objectClassDefn_in_objectClass4450);
        	        a2=objectClassDefn(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectClassEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, a2.tree);

        	    }
        	    break;
        	case 3:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:292:60: a3= value
        	    {
        	        FOLLOWPUSH(FOLLOW_value_in_objectClass4456);
        	        a3=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectClassEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) { CREATE_stream_value; stream_value->add(stream_value, a3.tree, NULL); }

        	         
        	        /* AST REWRITE
        	         * elements          : a2, a3, a1
        	         * token labels      : 
        	         * rule labels       : retval, a1, a2, a3
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        if ( BACKTRACKING==0 ) 
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_a1;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_a2;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_a3;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
        	        	stream_a1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a1", a1.tree != NULL ? a1.tree : NULL);
        	        	stream_a2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a2", a2.tree != NULL ? a2.tree : NULL);
        	        	stream_a3=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a3", a3.tree != NULL ? a3.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 293:2: -> ^( VALUE_NODE ( $a1)? ( $a2)? ( $a3)? )
        	        	{
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:293:5: ^( VALUE_NODE ( $a1)? ( $a2)? ( $a3)? )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, VALUE_NODE, (pANTLR3_UINT8)"VALUE_NODE"), root_1));

        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:293:18: ( $a1)?
        	        	        {
        	        	        	if ( (stream_a1 != NULL && stream_a1->hasNext(stream_a1))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_a1 == NULL ? NULL : stream_a1->nextTree(stream_a1));

        	        	        	}
        	        	        	if ( stream_a1 != NULL) stream_a1->reset(stream_a1);

        	        	        }
        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:293:23: ( $a2)?
        	        	        {
        	        	        	if ( (stream_a2 != NULL && stream_a2->hasNext(stream_a2))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_a2 == NULL ? NULL : stream_a2->nextTree(stream_a2));

        	        	        	}
        	        	        	if ( stream_a2 != NULL) stream_a2->reset(stream_a2);

        	        	        }
        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:293:28: ( $a3)?
        	        	        {
        	        	        	if ( (stream_a3 != NULL && stream_a3->hasNext(stream_a3))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_a3 == NULL ? NULL : stream_a3->nextTree(stream_a3));

        	        	        	}
        	        	        	if ( stream_a3 != NULL) stream_a3->reset(stream_a3);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);
        	        	if (stream_a1 != NULL) stream_a1->free(stream_a1);
        	        	if (stream_a2 != NULL) stream_a2->free(stream_a2);
        	        	if (stream_a3 != NULL) stream_a3->free(stream_a3);


        	        }
        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectClassEx; /* Prevent compiler warnings */
    ruleobjectClassEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_value != NULL) stream_value->free(stream_value);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(37, objectClass_StartIndex); }

    return retval;
}
/* $ANTLR end objectClass */

/** 
 * $ANTLR start definedObjectClass
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:295:1: definedObjectClass : ( (id1= IDENTIFIER DOT )? id2= IDENTIFIER | TYPE_IDENTIFIER_LITERAL | ABSTRACT_SYNTAX_LITERAL ) ( L_PARAN (c1= constraint | c2= sizeConstraint ) R_PARAN )? -> ^( NODE_INFO ( $id1)? ^( $id2 ^( TAG_SPECIFIC ( $c1)? ( $c2)? ) ) ) ;
 */
static asn1Parser_definedObjectClass_return
definedObjectClass(pasn1Parser ctx)
{   
    asn1Parser_definedObjectClass_return retval;
    ANTLR3_UINT32 definedObjectClass_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    pANTLR3_COMMON_TOKEN    DOT114;
    pANTLR3_COMMON_TOKEN    TYPE_IDENTIFIER_LITERAL115;
    pANTLR3_COMMON_TOKEN    ABSTRACT_SYNTAX_LITERAL116;
    pANTLR3_COMMON_TOKEN    L_PARAN117;
    pANTLR3_COMMON_TOKEN    R_PARAN118;
    asn1Parser_constraint_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 asn1Parser_constraint_return

    asn1Parser_sizeConstraint_return c2;
    #undef	RETURN_TYPE_c2
    #define	RETURN_TYPE_c2 asn1Parser_sizeConstraint_return

    pANTLR3_BASE_TREE id1_tree;
    pANTLR3_BASE_TREE id2_tree;
    pANTLR3_BASE_TREE DOT114_tree;
    pANTLR3_BASE_TREE TYPE_IDENTIFIER_LITERAL115_tree;
    pANTLR3_BASE_TREE ABSTRACT_SYNTAX_LITERAL116_tree;
    pANTLR3_BASE_TREE L_PARAN117_tree;
    pANTLR3_BASE_TREE R_PARAN118_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_TYPE_IDENTIFIER_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_DOT;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_PARAN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ABSTRACT_SYNTAX_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_PARAN;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_constraint;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_sizeConstraint;
    /* Initialize rule variables
     */
    definedObjectClass_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(38)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    id1       = NULL;
    id2       = NULL;
    DOT114       = NULL;
    TYPE_IDENTIFIER_LITERAL115       = NULL;
    ABSTRACT_SYNTAX_LITERAL116       = NULL;
    L_PARAN117       = NULL;
    R_PARAN118       = NULL;
    c1.tree = NULL;

    c2.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    id1_tree   = NULL;
    id2_tree   = NULL;
    DOT114_tree   = NULL;
    TYPE_IDENTIFIER_LITERAL115_tree   = NULL;
    ABSTRACT_SYNTAX_LITERAL116_tree   = NULL;
    L_PARAN117_tree   = NULL;
    R_PARAN118_tree   = NULL;

    stream_TYPE_IDENTIFIER_LITERAL   = NULL;
    #define CREATE_stream_TYPE_IDENTIFIER_LITERAL  if (stream_TYPE_IDENTIFIER_LITERAL == NULL) {stream_TYPE_IDENTIFIER_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token TYPE_IDENTIFIER_LITERAL"); } 
    stream_DOT   = NULL;
    #define CREATE_stream_DOT  if (stream_DOT == NULL) {stream_DOT = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token DOT"); } 
    stream_L_PARAN   = NULL;
    #define CREATE_stream_L_PARAN  if (stream_L_PARAN == NULL) {stream_L_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_PARAN"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_ABSTRACT_SYNTAX_LITERAL   = NULL;
    #define CREATE_stream_ABSTRACT_SYNTAX_LITERAL  if (stream_ABSTRACT_SYNTAX_LITERAL == NULL) {stream_ABSTRACT_SYNTAX_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ABSTRACT_SYNTAX_LITERAL"); } 
    stream_R_PARAN   = NULL;
    #define CREATE_stream_R_PARAN  if (stream_R_PARAN == NULL) {stream_R_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_PARAN"); } 
    stream_constraint   = NULL;
    #define CREATE_stream_constraint  if (stream_constraint == NULL) {stream_constraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule constraint"); }
    stream_sizeConstraint   = NULL;
    #define CREATE_stream_sizeConstraint  if (stream_sizeConstraint == NULL) {stream_sizeConstraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule sizeConstraint"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:295:20: ( ( (id1= IDENTIFIER DOT )? id2= IDENTIFIER | TYPE_IDENTIFIER_LITERAL | ABSTRACT_SYNTAX_LITERAL ) ( L_PARAN (c1= constraint | c2= sizeConstraint ) R_PARAN )? -> ^( NODE_INFO ( $id1)? ^( $id2 ^( TAG_SPECIFIC ( $c1)? ( $c2)? ) ) ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:296:2: ( (id1= IDENTIFIER DOT )? id2= IDENTIFIER | TYPE_IDENTIFIER_LITERAL | ABSTRACT_SYNTAX_LITERAL ) ( L_PARAN (c1= constraint | c2= sizeConstraint ) R_PARAN )?
        {

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:296:2: ( (id1= IDENTIFIER DOT )? id2= IDENTIFIER | TYPE_IDENTIFIER_LITERAL | ABSTRACT_SYNTAX_LITERAL )
            {
                int alt49=3;
                switch ( LA(1) ) 
                {
                case IDENTIFIER:
                	{
                		alt49=1;
                	}
                    break;
                case TYPE_IDENTIFIER_LITERAL:
                	{
                		alt49=2;
                	}
                    break;
                case ABSTRACT_SYNTAX_LITERAL:
                	{
                		alt49=3;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 49;
                    EXCEPTION->state        = 0;


                    goto ruledefinedObjectClassEx;
                }

                switch (alt49) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:296:3: (id1= IDENTIFIER DOT )? id2= IDENTIFIER
            	    {

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:296:3: (id1= IDENTIFIER DOT )?
            	        {
            	            int alt48=2;
            	            switch ( LA(1) ) 
            	            {
            	                case IDENTIFIER:
            	                	{
            	                		switch ( LA(2) ) 
            	                		{
            	                		    case DOT:
            	                		    	{
            	                		    		switch ( LA(3) ) 
            	                		    		{
            	                		    		    case IDENTIFIER:
            	                		    		    	{
            	                		    		    		alt48=1;
            	                		    		    	}
            	                		    		        break;
            	                		    		}

            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt48) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:296:4: id1= IDENTIFIER DOT
            	        	    {
            	        	        id1 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_definedObjectClass4490); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledefinedObjectClassEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        } 
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, id1, NULL); }

            	        	        DOT114 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_definedObjectClass4492); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledefinedObjectClassEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        } 
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_DOT; stream_DOT->add(stream_DOT, DOT114, NULL); }


            	        	    }
            	        	    break;

            	            }
            	        }
            	        id2 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_definedObjectClass4498); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledefinedObjectClassEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, id2, NULL); }


            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:297:4: TYPE_IDENTIFIER_LITERAL
            	    {
            	        TYPE_IDENTIFIER_LITERAL115 = (pANTLR3_COMMON_TOKEN) MATCHT(TYPE_IDENTIFIER_LITERAL, &FOLLOW_TYPE_IDENTIFIER_LITERAL_in_definedObjectClass4504); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledefinedObjectClassEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_TYPE_IDENTIFIER_LITERAL; stream_TYPE_IDENTIFIER_LITERAL->add(stream_TYPE_IDENTIFIER_LITERAL, TYPE_IDENTIFIER_LITERAL115, NULL); }


            	    }
            	    break;
            	case 3:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:298:5: ABSTRACT_SYNTAX_LITERAL
            	    {
            	        ABSTRACT_SYNTAX_LITERAL116 = (pANTLR3_COMMON_TOKEN) MATCHT(ABSTRACT_SYNTAX_LITERAL, &FOLLOW_ABSTRACT_SYNTAX_LITERAL_in_definedObjectClass4510); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledefinedObjectClassEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_ABSTRACT_SYNTAX_LITERAL; stream_ABSTRACT_SYNTAX_LITERAL->add(stream_ABSTRACT_SYNTAX_LITERAL, ABSTRACT_SYNTAX_LITERAL116, NULL); }


            	    }
            	    break;

                }
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:299:4: ( L_PARAN (c1= constraint | c2= sizeConstraint ) R_PARAN )?
            {
                int alt51=2;
                switch ( LA(1) ) 
                {
                    case L_PARAN:
                    	{
                    		alt51=1;
                    	}
                        break;
                }

                switch (alt51) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:299:5: L_PARAN (c1= constraint | c2= sizeConstraint ) R_PARAN
            	    {
            	        L_PARAN117 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_definedObjectClass4524); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledefinedObjectClassEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_L_PARAN; stream_L_PARAN->add(stream_L_PARAN, L_PARAN117, NULL); }


            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:299:13: (c1= constraint | c2= sizeConstraint )
            	        {
            	            int alt50=2;
            	            switch ( LA(1) ) 
            	            {
            	            case TRUE_LITERAL:
            	            case FALSE_LITERAL:
            	            case TRUE_SMALL_LITERAL:
            	            case FALSE_SMALL_LITERAL:
            	            case L_BRACE:
            	            case L_PARAN:
            	            case MINUS:
            	            case CONTAINING_LITERAL:
            	            case ALL_LITERAL:
            	            case MIN_LITERAL:
            	            case PATTERN_LITERAL:
            	            case CONSTRAINED_LITERAL:
            	            case ENCODED_LITERAL:
            	            case IDENTIFIER:
            	            case NUMBER:
            	            case BSTRING:
            	            	{
            	            		alt50=1;
            	            	}
            	                break;
            	            case SIZE_LITERAL:
            	            	{

            	            		{
            	            		    int LA50_12 = LA(2);
            	            		    if ( (synpred62_asn1(ctx)) ) 
            	            		    {
            	            		        alt50=1;
            	            		    }
            	            		    else if ( (ANTLR3_TRUE) ) 
            	            		    {
            	            		        alt50=2;
            	            		    }
            	            		    else 
            	            		    {
            	            		        if (BACKTRACKING>0)
            	            		        {
            	            		            FAILEDFLAG = ANTLR3_TRUE;
            	            		            return retval;
            	            		        }
            	            		    
            	            		        CONSTRUCTEX();
            	            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		        EXCEPTION->message      = (void *)"";
            	            		        EXCEPTION->decisionNum  = 50;
            	            		        EXCEPTION->state        = 12;


            	            		        goto ruledefinedObjectClassEx;
            	            		    }
            	            		}
            	            	}
            	                break;

            	            default:
            	                if (BACKTRACKING>0)
            	                {
            	                    FAILEDFLAG = ANTLR3_TRUE;
            	                    return retval;
            	                }
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 50;
            	                EXCEPTION->state        = 0;


            	                goto ruledefinedObjectClassEx;
            	            }

            	            switch (alt50) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:299:14: c1= constraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constraint_in_definedObjectClass4529);
            	        	        c1=constraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledefinedObjectClassEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_constraint; stream_constraint->add(stream_constraint, c1.tree, NULL); }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:299:30: c2= sizeConstraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_sizeConstraint_in_definedObjectClass4535);
            	        	        c2=sizeConstraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledefinedObjectClassEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_sizeConstraint; stream_sizeConstraint->add(stream_sizeConstraint, c2.tree, NULL); }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        R_PARAN118 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_definedObjectClass4538); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledefinedObjectClassEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_R_PARAN; stream_R_PARAN->add(stream_R_PARAN, R_PARAN118, NULL); }


            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : c2, id2, c1, id1
             * token labels      : id2, id1
             * rule labels       : retval, c1, c2
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_id2;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_id1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c2;

            	stream_id2=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token id2", id2);
            	stream_id1=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token id1", id1);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_c1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c1", c1.tree != NULL ? c1.tree : NULL);
            	stream_c2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c2", c2.tree != NULL ? c2.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 300:2: -> ^( NODE_INFO ( $id1)? ^( $id2 ^( TAG_SPECIFIC ( $c1)? ( $c2)? ) ) )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:300:5: ^( NODE_INFO ( $id1)? ^( $id2 ^( TAG_SPECIFIC ( $c1)? ( $c2)? ) ) )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NODE_INFO, (pANTLR3_UINT8)"NODE_INFO"), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:300:17: ( $id1)?
            	        {
            	        	if ( (stream_id1 != NULL && stream_id1->hasNext(stream_id1))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_id1 == NULL ? NULL : stream_id1->nextNode(stream_id1));

            	        	}
            	        	if ( stream_id1 != NULL) stream_id1->reset(stream_id1);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:300:23: ^( $id2 ^( TAG_SPECIFIC ( $c1)? ( $c2)? ) )
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRootToken(ADAPTOR, stream_id2 == NULL ? NULL : stream_id2->nextToken(stream_id2), root_2));

            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:300:30: ^( TAG_SPECIFIC ( $c1)? ( $c2)? )
            	            {
            	                pANTLR3_BASE_TREE root_3 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	                root_3 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TAG_SPECIFIC, (pANTLR3_UINT8)"TAG_SPECIFIC"), root_3));

            	                // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:300:45: ( $c1)?
            	                {
            	                	if ( (stream_c1 != NULL && stream_c1->hasNext(stream_c1))  )
            	                	{
            	                		ADAPTOR->addChild(ADAPTOR, root_3, stream_c1 == NULL ? NULL : stream_c1->nextTree(stream_c1));

            	                	}
            	                	if ( stream_c1 != NULL) stream_c1->reset(stream_c1);

            	                }
            	                // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:300:50: ( $c2)?
            	                {
            	                	if ( (stream_c2 != NULL && stream_c2->hasNext(stream_c2))  )
            	                	{
            	                		ADAPTOR->addChild(ADAPTOR, root_3, stream_c2 == NULL ? NULL : stream_c2->nextTree(stream_c2));

            	                	}
            	                	if ( stream_c2 != NULL) stream_c2->reset(stream_c2);

            	                }

            	                ADAPTOR->addChild(ADAPTOR, root_2, root_3);
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_id2 != NULL) stream_id2->free(stream_id2); 
            	if (stream_id1 != NULL) stream_id1->free(stream_id1); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_c1 != NULL) stream_c1->free(stream_c1);
            	if (stream_c2 != NULL) stream_c2->free(stream_c2);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledefinedObjectClassEx; /* Prevent compiler warnings */
    ruledefinedObjectClassEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_TYPE_IDENTIFIER_LITERAL != NULL) stream_TYPE_IDENTIFIER_LITERAL->free(stream_TYPE_IDENTIFIER_LITERAL);
        if (stream_DOT != NULL) stream_DOT->free(stream_DOT);
        if (stream_L_PARAN != NULL) stream_L_PARAN->free(stream_L_PARAN);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_ABSTRACT_SYNTAX_LITERAL != NULL) stream_ABSTRACT_SYNTAX_LITERAL->free(stream_ABSTRACT_SYNTAX_LITERAL);
        if (stream_R_PARAN != NULL) stream_R_PARAN->free(stream_R_PARAN);
        if (stream_constraint != NULL) stream_constraint->free(stream_constraint);
        if (stream_sizeConstraint != NULL) stream_sizeConstraint->free(stream_sizeConstraint);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(38, definedObjectClass_StartIndex); }

    return retval;
}
/* $ANTLR end definedObjectClass */

/** 
 * $ANTLR start usefulObjectClassReference
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:303:1: usefulObjectClassReference : ( TYPE_IDENTIFIER_LITERAL | ABSTRACT_SYNTAX_LITERAL );
 */
static asn1Parser_usefulObjectClassReference_return
usefulObjectClassReference(pasn1Parser ctx)
{   
    asn1Parser_usefulObjectClassReference_return retval;
    ANTLR3_UINT32 usefulObjectClassReference_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set119;

    pANTLR3_BASE_TREE set119_tree;

    /* Initialize rule variables
     */
    usefulObjectClassReference_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(39)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    set119       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set119_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:303:28: ( TYPE_IDENTIFIER_LITERAL | ABSTRACT_SYNTAX_LITERAL )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set119=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= TYPE_IDENTIFIER_LITERAL) && (LA(1) <= ABSTRACT_SYNTAX_LITERAL)) )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set119)));
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_usefulObjectClassReference0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_usefulObjectClassReference0);    goto ruleusefulObjectClassReferenceEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleusefulObjectClassReferenceEx; /* Prevent compiler warnings */
    ruleusefulObjectClassReferenceEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(39, usefulObjectClassReference_StartIndex); }

    return retval;
}
/* $ANTLR end usefulObjectClassReference */

/** 
 * $ANTLR start externalObjectClassReference
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:308:1: externalObjectClassReference : IDENTIFIER DOT IDENTIFIER ;
 */
static asn1Parser_externalObjectClassReference_return
externalObjectClassReference(pasn1Parser ctx)
{   
    asn1Parser_externalObjectClassReference_return retval;
    ANTLR3_UINT32 externalObjectClassReference_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER120;
    pANTLR3_COMMON_TOKEN    DOT121;
    pANTLR3_COMMON_TOKEN    IDENTIFIER122;

    pANTLR3_BASE_TREE IDENTIFIER120_tree;
    pANTLR3_BASE_TREE DOT121_tree;
    pANTLR3_BASE_TREE IDENTIFIER122_tree;

    /* Initialize rule variables
     */
    externalObjectClassReference_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(40)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IDENTIFIER120       = NULL;
    DOT121       = NULL;
    IDENTIFIER122       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER120_tree   = NULL;
    DOT121_tree   = NULL;
    IDENTIFIER122_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:308:30: ( IDENTIFIER DOT IDENTIFIER )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:308:32: IDENTIFIER DOT IDENTIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER120 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_externalObjectClassReference4598); 
            if  (HASEXCEPTION())
            {
                goto ruleexternalObjectClassReferenceEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER120_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER120));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER120_tree);
            }
            DOT121 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_externalObjectClassReference4600); 
            if  (HASEXCEPTION())
            {
                goto ruleexternalObjectClassReferenceEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            DOT121_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT121));
            ADAPTOR->addChild(ADAPTOR, root_0, DOT121_tree);
            }
            IDENTIFIER122 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_externalObjectClassReference4602); 
            if  (HASEXCEPTION())
            {
                goto ruleexternalObjectClassReferenceEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER122_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER122));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER122_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexternalObjectClassReferenceEx; /* Prevent compiler warnings */
    ruleexternalObjectClassReferenceEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(40, externalObjectClassReference_StartIndex); }

    return retval;
}
/* $ANTLR end externalObjectClassReference */

/** 
 * $ANTLR start objectClassDefn
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:311:1: objectClassDefn : CLASS_LITERAL L_BRACE fieldSpec ( COMMA fieldSpec )* R_BRACE ( withSyntaxSpec )? ;
 */
static asn1Parser_objectClassDefn_return
objectClassDefn(pasn1Parser ctx)
{   
    asn1Parser_objectClassDefn_return retval;
    ANTLR3_UINT32 objectClassDefn_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    CLASS_LITERAL123;
    pANTLR3_COMMON_TOKEN    L_BRACE124;
    pANTLR3_COMMON_TOKEN    COMMA126;
    pANTLR3_COMMON_TOKEN    R_BRACE128;
    asn1Parser_fieldSpec_return fieldSpec125;
    #undef	RETURN_TYPE_fieldSpec125
    #define	RETURN_TYPE_fieldSpec125 asn1Parser_fieldSpec_return

    asn1Parser_fieldSpec_return fieldSpec127;
    #undef	RETURN_TYPE_fieldSpec127
    #define	RETURN_TYPE_fieldSpec127 asn1Parser_fieldSpec_return

    asn1Parser_withSyntaxSpec_return withSyntaxSpec129;
    #undef	RETURN_TYPE_withSyntaxSpec129
    #define	RETURN_TYPE_withSyntaxSpec129 asn1Parser_withSyntaxSpec_return

    pANTLR3_BASE_TREE CLASS_LITERAL123_tree;
    pANTLR3_BASE_TREE L_BRACE124_tree;
    pANTLR3_BASE_TREE COMMA126_tree;
    pANTLR3_BASE_TREE R_BRACE128_tree;

    /* Initialize rule variables
     */
    objectClassDefn_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(41)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    CLASS_LITERAL123       = NULL;
    L_BRACE124       = NULL;
    COMMA126       = NULL;
    R_BRACE128       = NULL;
    fieldSpec125.tree = NULL;

    fieldSpec127.tree = NULL;

    withSyntaxSpec129.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    CLASS_LITERAL123_tree   = NULL;
    L_BRACE124_tree   = NULL;
    COMMA126_tree   = NULL;
    R_BRACE128_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:311:17: ( CLASS_LITERAL L_BRACE fieldSpec ( COMMA fieldSpec )* R_BRACE ( withSyntaxSpec )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:311:19: CLASS_LITERAL L_BRACE fieldSpec ( COMMA fieldSpec )* R_BRACE ( withSyntaxSpec )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            CLASS_LITERAL123 = (pANTLR3_COMMON_TOKEN) MATCHT(CLASS_LITERAL, &FOLLOW_CLASS_LITERAL_in_objectClassDefn4612); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectClassDefnEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            CLASS_LITERAL123_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CLASS_LITERAL123));
            ADAPTOR->addChild(ADAPTOR, root_0, CLASS_LITERAL123_tree);
            }
            L_BRACE124 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_objectClassDefn4614); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectClassDefnEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            L_BRACE124_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, L_BRACE124));
            ADAPTOR->addChild(ADAPTOR, root_0, L_BRACE124_tree);
            }
            FOLLOWPUSH(FOLLOW_fieldSpec_in_objectClassDefn4617);
            fieldSpec125=fieldSpec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobjectClassDefnEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fieldSpec125.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:311:52: ( COMMA fieldSpec )*

            for (;;)
            {
                int alt52=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt52=1;
                	}
                    break;

                }

                switch (alt52) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:311:53: COMMA fieldSpec
            	    {
            	        COMMA126 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_objectClassDefn4620); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobjectClassDefnEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        COMMA126_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA126));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA126_tree);
            	        }
            	        FOLLOWPUSH(FOLLOW_fieldSpec_in_objectClassDefn4622);
            	        fieldSpec127=fieldSpec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobjectClassDefnEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fieldSpec127.tree);

            	    }
            	    break;

            	default:
            	    goto loop52;	/* break out of the loop */
            	    break;
                }
            }
            loop52: ; /* Jump out to here if this rule does not match */

            R_BRACE128 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_objectClassDefn4629); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectClassDefnEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            R_BRACE128_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, R_BRACE128));
            ADAPTOR->addChild(ADAPTOR, root_0, R_BRACE128_tree);
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:311:83: ( withSyntaxSpec )?
            {
                int alt53=2;
                switch ( LA(1) ) 
                {
                    case WITH_LITERAL:
                    	{
                    		alt53=1;
                    	}
                        break;
                }

                switch (alt53) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: withSyntaxSpec
            	    {
            	        FOLLOWPUSH(FOLLOW_withSyntaxSpec_in_objectClassDefn4632);
            	        withSyntaxSpec129=withSyntaxSpec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobjectClassDefnEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, withSyntaxSpec129.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectClassDefnEx; /* Prevent compiler warnings */
    ruleobjectClassDefnEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(41, objectClassDefn_StartIndex); }

    return retval;
}
/* $ANTLR end objectClassDefn */

/** 
 * $ANTLR start withSyntaxSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:313:1: withSyntaxSpec : WITH_LITERAL SYNTAX_LITERAL syntaxList ;
 */
static asn1Parser_withSyntaxSpec_return
withSyntaxSpec(pasn1Parser ctx)
{   
    asn1Parser_withSyntaxSpec_return retval;
    ANTLR3_UINT32 withSyntaxSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    WITH_LITERAL130;
    pANTLR3_COMMON_TOKEN    SYNTAX_LITERAL131;
    asn1Parser_syntaxList_return syntaxList132;
    #undef	RETURN_TYPE_syntaxList132
    #define	RETURN_TYPE_syntaxList132 asn1Parser_syntaxList_return

    pANTLR3_BASE_TREE WITH_LITERAL130_tree;
    pANTLR3_BASE_TREE SYNTAX_LITERAL131_tree;

    /* Initialize rule variables
     */
    withSyntaxSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(42)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    WITH_LITERAL130       = NULL;
    SYNTAX_LITERAL131       = NULL;
    syntaxList132.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    WITH_LITERAL130_tree   = NULL;
    SYNTAX_LITERAL131_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:313:16: ( WITH_LITERAL SYNTAX_LITERAL syntaxList )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:313:18: WITH_LITERAL SYNTAX_LITERAL syntaxList
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            WITH_LITERAL130 = (pANTLR3_COMMON_TOKEN) MATCHT(WITH_LITERAL, &FOLLOW_WITH_LITERAL_in_withSyntaxSpec4642); 
            if  (HASEXCEPTION())
            {
                goto rulewithSyntaxSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            WITH_LITERAL130_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, WITH_LITERAL130));
            ADAPTOR->addChild(ADAPTOR, root_0, WITH_LITERAL130_tree);
            }
            SYNTAX_LITERAL131 = (pANTLR3_COMMON_TOKEN) MATCHT(SYNTAX_LITERAL, &FOLLOW_SYNTAX_LITERAL_in_withSyntaxSpec4644); 
            if  (HASEXCEPTION())
            {
                goto rulewithSyntaxSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            SYNTAX_LITERAL131_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SYNTAX_LITERAL131));
            ADAPTOR->addChild(ADAPTOR, root_0, SYNTAX_LITERAL131_tree);
            }
            FOLLOWPUSH(FOLLOW_syntaxList_in_withSyntaxSpec4646);
            syntaxList132=syntaxList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewithSyntaxSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, syntaxList132.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewithSyntaxSpecEx; /* Prevent compiler warnings */
    rulewithSyntaxSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(42, withSyntaxSpec_StartIndex); }

    return retval;
}
/* $ANTLR end withSyntaxSpec */

/** 
 * $ANTLR start syntaxList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:315:1: syntaxList : L_BRACE ( tokenOrGroupSpec )+ R_BRACE ;
 */
static asn1Parser_syntaxList_return
syntaxList(pasn1Parser ctx)
{   
    asn1Parser_syntaxList_return retval;
    ANTLR3_UINT32 syntaxList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    L_BRACE133;
    pANTLR3_COMMON_TOKEN    R_BRACE135;
    asn1Parser_tokenOrGroupSpec_return tokenOrGroupSpec134;
    #undef	RETURN_TYPE_tokenOrGroupSpec134
    #define	RETURN_TYPE_tokenOrGroupSpec134 asn1Parser_tokenOrGroupSpec_return

    pANTLR3_BASE_TREE L_BRACE133_tree;
    pANTLR3_BASE_TREE R_BRACE135_tree;

    /* Initialize rule variables
     */
    syntaxList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(43)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    L_BRACE133       = NULL;
    R_BRACE135       = NULL;
    tokenOrGroupSpec134.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    L_BRACE133_tree   = NULL;
    R_BRACE135_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:315:12: ( L_BRACE ( tokenOrGroupSpec )+ R_BRACE )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:315:14: L_BRACE ( tokenOrGroupSpec )+ R_BRACE
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            L_BRACE133 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_syntaxList4655); 
            if  (HASEXCEPTION())
            {
                goto rulesyntaxListEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            L_BRACE133_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, L_BRACE133));
            ADAPTOR->addChild(ADAPTOR, root_0, L_BRACE133_tree);
            }
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:315:22: ( tokenOrGroupSpec )+
            {
                int cnt54=0;

                for (;;)
                {
                    int alt54=2;
            	switch ( LA(1) ) 
            	{
            	case AMPERSAND:
            	case COMMA:
            	case L_BRACKET:
            	case IDENTIFIER:
            		{
            			alt54=1;
            		}
            	    break;

            	}

            	switch (alt54) 
            	{
            	    case 1:
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: tokenOrGroupSpec
            	        {
            	            FOLLOWPUSH(FOLLOW_tokenOrGroupSpec_in_syntaxList4657);
            	            tokenOrGroupSpec134=tokenOrGroupSpec(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesyntaxListEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }
            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, tokenOrGroupSpec134.tree);

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt54 >= 1 )
            		{
            		    goto loop54;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulesyntaxListEx;
            	}
            	cnt54++;
                }
                loop54: ;	/* Jump to here if this rule does not match */
            }
            R_BRACE135 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_syntaxList4660); 
            if  (HASEXCEPTION())
            {
                goto rulesyntaxListEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            R_BRACE135_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, R_BRACE135));
            ADAPTOR->addChild(ADAPTOR, root_0, R_BRACE135_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesyntaxListEx; /* Prevent compiler warnings */
    rulesyntaxListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(43, syntaxList_StartIndex); }

    return retval;
}
/* $ANTLR end syntaxList */

/** 
 * $ANTLR start tokenOrGroupSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:318:1: tokenOrGroupSpec : ( requiredToken | optionalGroup );
 */
static asn1Parser_tokenOrGroupSpec_return
tokenOrGroupSpec(pasn1Parser ctx)
{   
    asn1Parser_tokenOrGroupSpec_return retval;
    ANTLR3_UINT32 tokenOrGroupSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_requiredToken_return requiredToken136;
    #undef	RETURN_TYPE_requiredToken136
    #define	RETURN_TYPE_requiredToken136 asn1Parser_requiredToken_return

    asn1Parser_optionalGroup_return optionalGroup137;
    #undef	RETURN_TYPE_optionalGroup137
    #define	RETURN_TYPE_optionalGroup137 asn1Parser_optionalGroup_return


    /* Initialize rule variables
     */
    tokenOrGroupSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(44)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    requiredToken136.tree = NULL;

    optionalGroup137.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:318:18: ( requiredToken | optionalGroup )
            
            ANTLR3_UINT32 alt55;

            alt55=2;

            switch ( LA(1) ) 
            {
            case AMPERSAND:
            case COMMA:
            case IDENTIFIER:
            	{
            		alt55=1;
            	}
                break;
            case L_BRACKET:
            	{
            		alt55=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 55;
                EXCEPTION->state        = 0;


                goto ruletokenOrGroupSpecEx;
            }

            switch (alt55) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:318:20: requiredToken
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_requiredToken_in_tokenOrGroupSpec4670);
        	        requiredToken136=requiredToken(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletokenOrGroupSpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, requiredToken136.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:318:36: optionalGroup
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_optionalGroup_in_tokenOrGroupSpec4674);
        	        optionalGroup137=optionalGroup(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletokenOrGroupSpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, optionalGroup137.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletokenOrGroupSpecEx; /* Prevent compiler warnings */
    ruletokenOrGroupSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(44, tokenOrGroupSpec_StartIndex); }

    return retval;
}
/* $ANTLR end tokenOrGroupSpec */

/** 
 * $ANTLR start optionalGroup
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:321:1: optionalGroup : L_BRACKET ( tokenOrGroupSpec )+ R_BRACKET ;
 */
static asn1Parser_optionalGroup_return
optionalGroup(pasn1Parser ctx)
{   
    asn1Parser_optionalGroup_return retval;
    ANTLR3_UINT32 optionalGroup_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    L_BRACKET138;
    pANTLR3_COMMON_TOKEN    R_BRACKET140;
    asn1Parser_tokenOrGroupSpec_return tokenOrGroupSpec139;
    #undef	RETURN_TYPE_tokenOrGroupSpec139
    #define	RETURN_TYPE_tokenOrGroupSpec139 asn1Parser_tokenOrGroupSpec_return

    pANTLR3_BASE_TREE L_BRACKET138_tree;
    pANTLR3_BASE_TREE R_BRACKET140_tree;

    /* Initialize rule variables
     */
    optionalGroup_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(45)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    L_BRACKET138       = NULL;
    R_BRACKET140       = NULL;
    tokenOrGroupSpec139.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    L_BRACKET138_tree   = NULL;
    R_BRACKET140_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:321:15: ( L_BRACKET ( tokenOrGroupSpec )+ R_BRACKET )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:321:17: L_BRACKET ( tokenOrGroupSpec )+ R_BRACKET
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            L_BRACKET138 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACKET, &FOLLOW_L_BRACKET_in_optionalGroup4684); 
            if  (HASEXCEPTION())
            {
                goto ruleoptionalGroupEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            L_BRACKET138_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, L_BRACKET138));
            ADAPTOR->addChild(ADAPTOR, root_0, L_BRACKET138_tree);
            }
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:321:27: ( tokenOrGroupSpec )+
            {
                int cnt56=0;

                for (;;)
                {
                    int alt56=2;
            	switch ( LA(1) ) 
            	{
            	case AMPERSAND:
            	case COMMA:
            	case L_BRACKET:
            	case IDENTIFIER:
            		{
            			alt56=1;
            		}
            	    break;

            	}

            	switch (alt56) 
            	{
            	    case 1:
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:321:28: tokenOrGroupSpec
            	        {
            	            FOLLOWPUSH(FOLLOW_tokenOrGroupSpec_in_optionalGroup4687);
            	            tokenOrGroupSpec139=tokenOrGroupSpec(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleoptionalGroupEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }
            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, tokenOrGroupSpec139.tree);

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt56 >= 1 )
            		{
            		    goto loop56;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleoptionalGroupEx;
            	}
            	cnt56++;
                }
                loop56: ;	/* Jump to here if this rule does not match */
            }
            R_BRACKET140 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACKET, &FOLLOW_R_BRACKET_in_optionalGroup4691); 
            if  (HASEXCEPTION())
            {
                goto ruleoptionalGroupEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            R_BRACKET140_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, R_BRACKET140));
            ADAPTOR->addChild(ADAPTOR, root_0, R_BRACKET140_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleoptionalGroupEx; /* Prevent compiler warnings */
    ruleoptionalGroupEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(45, optionalGroup_StartIndex); }

    return retval;
}
/* $ANTLR end optionalGroup */

/** 
 * $ANTLR start requiredToken
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:324:1: requiredToken : ( literal | primitiveFieldName );
 */
static asn1Parser_requiredToken_return
requiredToken(pasn1Parser ctx)
{   
    asn1Parser_requiredToken_return retval;
    ANTLR3_UINT32 requiredToken_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_literal_return literal141;
    #undef	RETURN_TYPE_literal141
    #define	RETURN_TYPE_literal141 asn1Parser_literal_return

    asn1Parser_primitiveFieldName_return primitiveFieldName142;
    #undef	RETURN_TYPE_primitiveFieldName142
    #define	RETURN_TYPE_primitiveFieldName142 asn1Parser_primitiveFieldName_return


    /* Initialize rule variables
     */
    requiredToken_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(46)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    literal141.tree = NULL;

    primitiveFieldName142.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:324:15: ( literal | primitiveFieldName )
            
            ANTLR3_UINT32 alt57;

            alt57=2;

            switch ( LA(1) ) 
            {
            case COMMA:
            case IDENTIFIER:
            	{
            		alt57=1;
            	}
                break;
            case AMPERSAND:
            	{
            		alt57=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 57;
                EXCEPTION->state        = 0;


                goto rulerequiredTokenEx;
            }

            switch (alt57) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:324:17: literal
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_literal_in_requiredToken4701);
        	        literal141=literal(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerequiredTokenEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, literal141.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:324:27: primitiveFieldName
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_primitiveFieldName_in_requiredToken4705);
        	        primitiveFieldName142=primitiveFieldName(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerequiredTokenEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, primitiveFieldName142.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulerequiredTokenEx; /* Prevent compiler warnings */
    rulerequiredTokenEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(46, requiredToken_StartIndex); }

    return retval;
}
/* $ANTLR end requiredToken */

/** 
 * $ANTLR start literal
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:326:1: literal : ( IDENTIFIER | COMMA );
 */
static asn1Parser_literal_return
literal(pasn1Parser ctx)
{   
    asn1Parser_literal_return retval;
    ANTLR3_UINT32 literal_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set143;

    pANTLR3_BASE_TREE set143_tree;

    /* Initialize rule variables
     */
    literal_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(47)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    set143       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set143_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:326:9: ( IDENTIFIER | COMMA )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set143=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( LA(1) == COMMA || LA(1) == IDENTIFIER )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set143)));
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_literal0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_literal0);    goto ruleliteralEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleliteralEx; /* Prevent compiler warnings */
    ruleliteralEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(47, literal_StartIndex); }

    return retval;
}
/* $ANTLR end literal */

/** 
 * $ANTLR start primitiveFieldName
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:328:1: primitiveFieldName : AMPERSAND IDENTIFIER ;
 */
static asn1Parser_primitiveFieldName_return
primitiveFieldName(pasn1Parser ctx)
{   
    asn1Parser_primitiveFieldName_return retval;
    ANTLR3_UINT32 primitiveFieldName_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AMPERSAND144;
    pANTLR3_COMMON_TOKEN    IDENTIFIER145;

    pANTLR3_BASE_TREE AMPERSAND144_tree;
    pANTLR3_BASE_TREE IDENTIFIER145_tree;

    /* Initialize rule variables
     */
    primitiveFieldName_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(48)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    AMPERSAND144       = NULL;
    IDENTIFIER145       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    AMPERSAND144_tree   = NULL;
    IDENTIFIER145_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:328:20: ( AMPERSAND IDENTIFIER )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:329:2: AMPERSAND IDENTIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            AMPERSAND144 = (pANTLR3_COMMON_TOKEN) MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_primitiveFieldName4728); 
            if  (HASEXCEPTION())
            {
                goto ruleprimitiveFieldNameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            AMPERSAND144_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AMPERSAND144));
            ADAPTOR->addChild(ADAPTOR, root_0, AMPERSAND144_tree);
            }
            IDENTIFIER145 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_primitiveFieldName4730); 
            if  (HASEXCEPTION())
            {
                goto ruleprimitiveFieldNameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER145_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER145));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER145_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprimitiveFieldNameEx; /* Prevent compiler warnings */
    ruleprimitiveFieldNameEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(48, primitiveFieldName_StartIndex); }

    return retval;
}
/* $ANTLR end primitiveFieldName */

/** 
 * $ANTLR start fieldSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:332:1: fieldSpec : AMPERSAND IDENTIFIER ( ( typeOptionalitySpec )? | type ( ( valueSetOptionalitySpec )? | ( UNIQUE_LITERAL )? ( valueOptionalitySpec )? ) | fieldName ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( valueSet | value ) ) )? | definedObjectClass ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( objectSet | object ) ) )? ) ;
 */
static asn1Parser_fieldSpec_return
fieldSpec(pasn1Parser ctx)
{   
    asn1Parser_fieldSpec_return retval;
    ANTLR3_UINT32 fieldSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AMPERSAND146;
    pANTLR3_COMMON_TOKEN    IDENTIFIER147;
    pANTLR3_COMMON_TOKEN    UNIQUE_LITERAL151;
    pANTLR3_COMMON_TOKEN    OPTIONAL_LITERAL154;
    pANTLR3_COMMON_TOKEN    DEFAULT_LITERAL155;
    pANTLR3_COMMON_TOKEN    OPTIONAL_LITERAL159;
    pANTLR3_COMMON_TOKEN    DEFAULT_LITERAL160;
    asn1Parser_typeOptionalitySpec_return typeOptionalitySpec148;
    #undef	RETURN_TYPE_typeOptionalitySpec148
    #define	RETURN_TYPE_typeOptionalitySpec148 asn1Parser_typeOptionalitySpec_return

    asn1Parser_type_return type149;
    #undef	RETURN_TYPE_type149
    #define	RETURN_TYPE_type149 asn1Parser_type_return

    asn1Parser_valueSetOptionalitySpec_return valueSetOptionalitySpec150;
    #undef	RETURN_TYPE_valueSetOptionalitySpec150
    #define	RETURN_TYPE_valueSetOptionalitySpec150 asn1Parser_valueSetOptionalitySpec_return

    asn1Parser_valueOptionalitySpec_return valueOptionalitySpec152;
    #undef	RETURN_TYPE_valueOptionalitySpec152
    #define	RETURN_TYPE_valueOptionalitySpec152 asn1Parser_valueOptionalitySpec_return

    asn1Parser_fieldName_return fieldName153;
    #undef	RETURN_TYPE_fieldName153
    #define	RETURN_TYPE_fieldName153 asn1Parser_fieldName_return

    asn1Parser_valueSet_return valueSet156;
    #undef	RETURN_TYPE_valueSet156
    #define	RETURN_TYPE_valueSet156 asn1Parser_valueSet_return

    asn1Parser_value_return value157;
    #undef	RETURN_TYPE_value157
    #define	RETURN_TYPE_value157 asn1Parser_value_return

    asn1Parser_definedObjectClass_return definedObjectClass158;
    #undef	RETURN_TYPE_definedObjectClass158
    #define	RETURN_TYPE_definedObjectClass158 asn1Parser_definedObjectClass_return

    asn1Parser_objectSet_return objectSet161;
    #undef	RETURN_TYPE_objectSet161
    #define	RETURN_TYPE_objectSet161 asn1Parser_objectSet_return

    asn1Parser_object_return object162;
    #undef	RETURN_TYPE_object162
    #define	RETURN_TYPE_object162 asn1Parser_object_return

    pANTLR3_BASE_TREE AMPERSAND146_tree;
    pANTLR3_BASE_TREE IDENTIFIER147_tree;
    pANTLR3_BASE_TREE UNIQUE_LITERAL151_tree;
    pANTLR3_BASE_TREE OPTIONAL_LITERAL154_tree;
    pANTLR3_BASE_TREE DEFAULT_LITERAL155_tree;
    pANTLR3_BASE_TREE OPTIONAL_LITERAL159_tree;
    pANTLR3_BASE_TREE DEFAULT_LITERAL160_tree;

    /* Initialize rule variables
     */
    fieldSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(49)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    AMPERSAND146       = NULL;
    IDENTIFIER147       = NULL;
    UNIQUE_LITERAL151       = NULL;
    OPTIONAL_LITERAL154       = NULL;
    DEFAULT_LITERAL155       = NULL;
    OPTIONAL_LITERAL159       = NULL;
    DEFAULT_LITERAL160       = NULL;
    typeOptionalitySpec148.tree = NULL;

    type149.tree = NULL;

    valueSetOptionalitySpec150.tree = NULL;

    valueOptionalitySpec152.tree = NULL;

    fieldName153.tree = NULL;

    valueSet156.tree = NULL;

    value157.tree = NULL;

    definedObjectClass158.tree = NULL;

    objectSet161.tree = NULL;

    object162.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    AMPERSAND146_tree   = NULL;
    IDENTIFIER147_tree   = NULL;
    UNIQUE_LITERAL151_tree   = NULL;
    OPTIONAL_LITERAL154_tree   = NULL;
    DEFAULT_LITERAL155_tree   = NULL;
    OPTIONAL_LITERAL159_tree   = NULL;
    DEFAULT_LITERAL160_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:332:11: ( AMPERSAND IDENTIFIER ( ( typeOptionalitySpec )? | type ( ( valueSetOptionalitySpec )? | ( UNIQUE_LITERAL )? ( valueOptionalitySpec )? ) | fieldName ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( valueSet | value ) ) )? | definedObjectClass ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( objectSet | object ) ) )? ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:333:2: AMPERSAND IDENTIFIER ( ( typeOptionalitySpec )? | type ( ( valueSetOptionalitySpec )? | ( UNIQUE_LITERAL )? ( valueOptionalitySpec )? ) | fieldName ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( valueSet | value ) ) )? | definedObjectClass ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( objectSet | object ) ) )? )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            AMPERSAND146 = (pANTLR3_COMMON_TOKEN) MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_fieldSpec4741); 
            if  (HASEXCEPTION())
            {
                goto rulefieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            AMPERSAND146_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AMPERSAND146));
            ADAPTOR->addChild(ADAPTOR, root_0, AMPERSAND146_tree);
            }
            IDENTIFIER147 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_fieldSpec4743); 
            if  (HASEXCEPTION())
            {
                goto rulefieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER147_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER147));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER147_tree);
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:334:2: ( ( typeOptionalitySpec )? | type ( ( valueSetOptionalitySpec )? | ( UNIQUE_LITERAL )? ( valueOptionalitySpec )? ) | fieldName ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( valueSet | value ) ) )? | definedObjectClass ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( objectSet | object ) ) )? )
            {
                int alt67=4;
                switch ( LA(1) ) 
                {
                case EOF:
                case R_BRACE:
                case COMMA:
                case OPTIONAL_LITERAL:
                case DEFAULT_LITERAL:
                	{
                		alt67=1;
                	}
                    break;
                case BOOLEAN_LITERAL:
                case INTEGER_LITERAL:
                case IA5_STRING_LITERAL:
                case ENUMERATED_LITERAL:
                case BIT_LITERAL:
                case OCTET_LITERAL:
                case NULL_LITERAL:
                case SEQUENCE_LITERAL:
                case SET_LITERAL:
                case L_BRACKET:
                case CHOICE_LITERAL:
                case OBJECT_LITERAL:
                	{
                		alt67=2;
                	}
                    break;
                case IDENTIFIER:
                	{

                		{
                		    int LA67_18 = LA(2);
                		    if ( (synpred78_asn1(ctx)) ) 
                		    {
                		        alt67=2;
                		    }
                		    else if ( (ANTLR3_TRUE) ) 
                		    {
                		        alt67=4;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return retval;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 67;
                		        EXCEPTION->state        = 18;


                		        goto rulefieldSpecEx;
                		    }
                		}
                	}
                    break;
                case TYPE_IDENTIFIER_LITERAL:
                	{

                		{
                		    int LA67_19 = LA(2);
                		    if ( (synpred78_asn1(ctx)) ) 
                		    {
                		        alt67=2;
                		    }
                		    else if ( (ANTLR3_TRUE) ) 
                		    {
                		        alt67=4;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return retval;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 67;
                		        EXCEPTION->state        = 19;


                		        goto rulefieldSpecEx;
                		    }
                		}
                	}
                    break;
                case ABSTRACT_SYNTAX_LITERAL:
                	{

                		{
                		    int LA67_20 = LA(2);
                		    if ( (synpred78_asn1(ctx)) ) 
                		    {
                		        alt67=2;
                		    }
                		    else if ( (ANTLR3_TRUE) ) 
                		    {
                		        alt67=4;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return retval;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 67;
                		        EXCEPTION->state        = 20;


                		        goto rulefieldSpecEx;
                		    }
                		}
                	}
                    break;
                case AMPERSAND:
                	{
                		alt67=3;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 67;
                    EXCEPTION->state        = 0;


                    goto rulefieldSpecEx;
                }

                switch (alt67) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:335:4: ( typeOptionalitySpec )?
            	    {

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:335:4: ( typeOptionalitySpec )?
            	        {
            	            int alt58=2;
            	            switch ( LA(1) ) 
            	            {
            	                case OPTIONAL_LITERAL:
            	                case DEFAULT_LITERAL:
            	                	{
            	                		alt58=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt58) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: typeOptionalitySpec
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_typeOptionalitySpec_in_fieldSpec4752);
            	        	        typeOptionalitySpec148=typeOptionalitySpec(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefieldSpecEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typeOptionalitySpec148.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:6: type ( ( valueSetOptionalitySpec )? | ( UNIQUE_LITERAL )? ( valueOptionalitySpec )? )
            	    {
            	        FOLLOWPUSH(FOLLOW_type_in_fieldSpec4762);
            	        type149=type(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefieldSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type149.tree);

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:11: ( ( valueSetOptionalitySpec )? | ( UNIQUE_LITERAL )? ( valueOptionalitySpec )? )
            	        {
            	            int alt62=2;
            	            switch ( LA(1) ) 
            	            {
            	            case OPTIONAL_LITERAL:
            	            	{

            	            		{
            	            		    int LA62_1 = LA(2);
            	            		    if ( (synpred75_asn1(ctx)) ) 
            	            		    {
            	            		        alt62=1;
            	            		    }
            	            		    else if ( (ANTLR3_TRUE) ) 
            	            		    {
            	            		        alt62=2;
            	            		    }
            	            		    else 
            	            		    {
            	            		        if (BACKTRACKING>0)
            	            		        {
            	            		            FAILEDFLAG = ANTLR3_TRUE;
            	            		            return retval;
            	            		        }
            	            		    
            	            		        CONSTRUCTEX();
            	            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		        EXCEPTION->message      = (void *)"";
            	            		        EXCEPTION->decisionNum  = 62;
            	            		        EXCEPTION->state        = 1;


            	            		        goto rulefieldSpecEx;
            	            		    }
            	            		}
            	            	}
            	                break;
            	            case DEFAULT_LITERAL:
            	            	{
            	            		switch ( LA(2) ) 
            	            		{
            	            		case TRUE_LITERAL:
            	            		case FALSE_LITERAL:
            	            		case TRUE_SMALL_LITERAL:
            	            		case FALSE_SMALL_LITERAL:
            	            		case MINUS:
            	            		case IDENTIFIER:
            	            		case NUMBER:
            	            		case BSTRING:
            	            			{
            	            				alt62=2;
            	            			}
            	            		    break;
            	            		case L_BRACE:
            	            			{
            	            				switch ( LA(3) ) 
            	            				{
            	            				case NUMBER:
            	            					{
            	            						switch ( LA(4) ) 
            	            						{
            	            						case IDENTIFIER:
            	            						case NUMBER:
            	            							{
            	            								alt62=2;
            	            							}
            	            						    break;
            	            						case R_BRACE:
            	            							{

            	            								{
            	            								    int LA62_11 = LA(5);
            	            								    if ( (synpred75_asn1(ctx)) ) 
            	            								    {
            	            								        alt62=1;
            	            								    }
            	            								    else if ( (ANTLR3_TRUE) ) 
            	            								    {
            	            								        alt62=2;
            	            								    }
            	            								    else 
            	            								    {
            	            								        if (BACKTRACKING>0)
            	            								        {
            	            								            FAILEDFLAG = ANTLR3_TRUE;
            	            								            return retval;
            	            								        }
            	            								    
            	            								        CONSTRUCTEX();
            	            								        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            								        EXCEPTION->message      = (void *)"";
            	            								        EXCEPTION->decisionNum  = 62;
            	            								        EXCEPTION->state        = 11;


            	            								        goto rulefieldSpecEx;
            	            								    }
            	            								}
            	            							}
            	            						    break;
            	            						case DOUBLE_DOT:
            	            						case LESS_THAN:
            	            						case COMMA:
            	            						case EXCEPT_LITERAL:
            	            						case POWER:
            	            						case PIPE:
            	            						case UNION_LITERAL:
            	            						case INTERSECTION_LITERAL:
            	            							{
            	            								alt62=1;
            	            							}
            	            						    break;

            	            						default:
            	            						    if (BACKTRACKING>0)
            	            						    {
            	            						        FAILEDFLAG = ANTLR3_TRUE;
            	            						        return retval;
            	            						    }
            	            						    CONSTRUCTEX();
            	            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            						    EXCEPTION->message      = (void *)"";
            	            						    EXCEPTION->decisionNum  = 62;
            	            						    EXCEPTION->state        = 9;


            	            						    goto rulefieldSpecEx;
            	            						}

            	            					}
            	            				    break;
            	            				case IDENTIFIER:
            	            					{
            	            						switch ( LA(4) ) 
            	            						{
            	            						case DOUBLE_DOT:
            	            						case LESS_THAN:
            	            						case COMMA:
            	            						case EXCEPT_LITERAL:
            	            						case POWER:
            	            						case PIPE:
            	            						case UNION_LITERAL:
            	            						case INTERSECTION_LITERAL:
            	            						case COLON:
            	            							{
            	            								alt62=1;
            	            							}
            	            						    break;
            	            						case R_BRACE:
            	            							{

            	            								{
            	            								    int LA62_11 = LA(5);
            	            								    if ( (synpred75_asn1(ctx)) ) 
            	            								    {
            	            								        alt62=1;
            	            								    }
            	            								    else if ( (ANTLR3_TRUE) ) 
            	            								    {
            	            								        alt62=2;
            	            								    }
            	            								    else 
            	            								    {
            	            								        if (BACKTRACKING>0)
            	            								        {
            	            								            FAILEDFLAG = ANTLR3_TRUE;
            	            								            return retval;
            	            								        }
            	            								    
            	            								        CONSTRUCTEX();
            	            								        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            								        EXCEPTION->message      = (void *)"";
            	            								        EXCEPTION->decisionNum  = 62;
            	            								        EXCEPTION->state        = 11;


            	            								        goto rulefieldSpecEx;
            	            								    }
            	            								}
            	            							}
            	            						    break;
            	            						case DOT:
            	            						case L_BRACE:
            	            						case L_PARAN:
            	            						case IDENTIFIER:
            	            						case NUMBER:
            	            							{
            	            								alt62=2;
            	            							}
            	            						    break;

            	            						default:
            	            						    if (BACKTRACKING>0)
            	            						    {
            	            						        FAILEDFLAG = ANTLR3_TRUE;
            	            						        return retval;
            	            						    }
            	            						    CONSTRUCTEX();
            	            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            						    EXCEPTION->message      = (void *)"";
            	            						    EXCEPTION->decisionNum  = 62;
            	            						    EXCEPTION->state        = 10;


            	            						    goto rulefieldSpecEx;
            	            						}

            	            					}
            	            				    break;
            	            				case TRUE_LITERAL:
            	            				case FALSE_LITERAL:
            	            				case TRUE_SMALL_LITERAL:
            	            				case FALSE_SMALL_LITERAL:
            	            				case L_BRACE:
            	            				case MINUS:
            	            				case ALL_LITERAL:
            	            				case MIN_LITERAL:
            	            				case SIZE_LITERAL:
            	            				case PATTERN_LITERAL:
            	            				case BSTRING:
            	            					{
            	            						alt62=1;
            	            					}
            	            				    break;

            	            				default:
            	            				    if (BACKTRACKING>0)
            	            				    {
            	            				        FAILEDFLAG = ANTLR3_TRUE;
            	            				        return retval;
            	            				    }
            	            				    CONSTRUCTEX();
            	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				    EXCEPTION->message      = (void *)"";
            	            				    EXCEPTION->decisionNum  = 62;
            	            				    EXCEPTION->state        = 8;


            	            				    goto rulefieldSpecEx;
            	            				}

            	            			}
            	            		    break;

            	            		default:
            	            		    if (BACKTRACKING>0)
            	            		    {
            	            		        FAILEDFLAG = ANTLR3_TRUE;
            	            		        return retval;
            	            		    }
            	            		    CONSTRUCTEX();
            	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		    EXCEPTION->message      = (void *)"";
            	            		    EXCEPTION->decisionNum  = 62;
            	            		    EXCEPTION->state        = 2;


            	            		    goto rulefieldSpecEx;
            	            		}

            	            	}
            	                break;
            	            case COMMA:
            	            	{

            	            		{
            	            		    int LA62_3 = LA(2);
            	            		    if ( (synpred75_asn1(ctx)) ) 
            	            		    {
            	            		        alt62=1;
            	            		    }
            	            		    else if ( (ANTLR3_TRUE) ) 
            	            		    {
            	            		        alt62=2;
            	            		    }
            	            		    else 
            	            		    {
            	            		        if (BACKTRACKING>0)
            	            		        {
            	            		            FAILEDFLAG = ANTLR3_TRUE;
            	            		            return retval;
            	            		        }
            	            		    
            	            		        CONSTRUCTEX();
            	            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		        EXCEPTION->message      = (void *)"";
            	            		        EXCEPTION->decisionNum  = 62;
            	            		        EXCEPTION->state        = 3;


            	            		        goto rulefieldSpecEx;
            	            		    }
            	            		}
            	            	}
            	                break;
            	            case R_BRACE:
            	            	{

            	            		{
            	            		    int LA62_4 = LA(2);
            	            		    if ( (synpred75_asn1(ctx)) ) 
            	            		    {
            	            		        alt62=1;
            	            		    }
            	            		    else if ( (ANTLR3_TRUE) ) 
            	            		    {
            	            		        alt62=2;
            	            		    }
            	            		    else 
            	            		    {
            	            		        if (BACKTRACKING>0)
            	            		        {
            	            		            FAILEDFLAG = ANTLR3_TRUE;
            	            		            return retval;
            	            		        }
            	            		    
            	            		        CONSTRUCTEX();
            	            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		        EXCEPTION->message      = (void *)"";
            	            		        EXCEPTION->decisionNum  = 62;
            	            		        EXCEPTION->state        = 4;


            	            		        goto rulefieldSpecEx;
            	            		    }
            	            		}
            	            	}
            	                break;
            	            case EOF:
            	            	{

            	            		{
            	            		    int LA62_5 = LA(2);
            	            		    if ( (synpred75_asn1(ctx)) ) 
            	            		    {
            	            		        alt62=1;
            	            		    }
            	            		    else if ( (ANTLR3_TRUE) ) 
            	            		    {
            	            		        alt62=2;
            	            		    }
            	            		    else 
            	            		    {
            	            		        if (BACKTRACKING>0)
            	            		        {
            	            		            FAILEDFLAG = ANTLR3_TRUE;
            	            		            return retval;
            	            		        }
            	            		    
            	            		        CONSTRUCTEX();
            	            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		        EXCEPTION->message      = (void *)"";
            	            		        EXCEPTION->decisionNum  = 62;
            	            		        EXCEPTION->state        = 5;


            	            		        goto rulefieldSpecEx;
            	            		    }
            	            		}
            	            	}
            	                break;
            	            case UNIQUE_LITERAL:
            	            	{
            	            		alt62=2;
            	            	}
            	                break;

            	            default:
            	                if (BACKTRACKING>0)
            	                {
            	                    FAILEDFLAG = ANTLR3_TRUE;
            	                    return retval;
            	                }
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 62;
            	                EXCEPTION->state        = 0;


            	                goto rulefieldSpecEx;
            	            }

            	            switch (alt62) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:12: ( valueSetOptionalitySpec )?
            	        	    {

            	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:12: ( valueSetOptionalitySpec )?
            	        	        {
            	        	            int alt59=2;
            	        	            switch ( LA(1) ) 
            	        	            {
            	        	                case OPTIONAL_LITERAL:
            	        	                case DEFAULT_LITERAL:
            	        	                	{
            	        	                		alt59=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt59) 
            	        	            {
            	        	        	case 1:
            	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: valueSetOptionalitySpec
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_valueSetOptionalitySpec_in_fieldSpec4765);
            	        	        	        valueSetOptionalitySpec150=valueSetOptionalitySpec(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulefieldSpecEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }
            	        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, valueSetOptionalitySpec150.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:40: ( UNIQUE_LITERAL )? ( valueOptionalitySpec )?
            	        	    {

            	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:40: ( UNIQUE_LITERAL )?
            	        	        {
            	        	            int alt60=2;
            	        	            switch ( LA(1) ) 
            	        	            {
            	        	                case UNIQUE_LITERAL:
            	        	                	{
            	        	                		alt60=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt60) 
            	        	            {
            	        	        	case 1:
            	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: UNIQUE_LITERAL
            	        	        	    {
            	        	        	        UNIQUE_LITERAL151 = (pANTLR3_COMMON_TOKEN) MATCHT(UNIQUE_LITERAL, &FOLLOW_UNIQUE_LITERAL_in_fieldSpec4771); 
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulefieldSpecEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }
            	        	        	        if ( BACKTRACKING==0 ) {
            	        	        	        UNIQUE_LITERAL151_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, UNIQUE_LITERAL151));
            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, UNIQUE_LITERAL151_tree);
            	        	        	        }

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:56: ( valueOptionalitySpec )?
            	        	        {
            	        	            int alt61=2;
            	        	            switch ( LA(1) ) 
            	        	            {
            	        	                case OPTIONAL_LITERAL:
            	        	                case DEFAULT_LITERAL:
            	        	                	{
            	        	                		alt61=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt61) 
            	        	            {
            	        	        	case 1:
            	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: valueOptionalitySpec
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_valueOptionalitySpec_in_fieldSpec4774);
            	        	        	        valueOptionalitySpec152=valueOptionalitySpec(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulefieldSpecEx;
            	        	        	        }
            	        	        	        if (HASFAILED())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }
            	        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, valueOptionalitySpec152.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 3:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:337:4: fieldName ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( valueSet | value ) ) )?
            	    {
            	        FOLLOWPUSH(FOLLOW_fieldName_in_fieldSpec4782);
            	        fieldName153=fieldName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefieldSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fieldName153.tree);

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:337:14: ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( valueSet | value ) ) )?
            	        {
            	            int alt64=3;
            	            switch ( LA(1) ) 
            	            {
            	                case OPTIONAL_LITERAL:
            	                	{
            	                		alt64=1;
            	                	}
            	                    break;
            	                case DEFAULT_LITERAL:
            	                	{
            	                		alt64=2;
            	                	}
            	                    break;
            	            }

            	            switch (alt64) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:337:15: OPTIONAL_LITERAL
            	        	    {
            	        	        OPTIONAL_LITERAL154 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTIONAL_LITERAL, &FOLLOW_OPTIONAL_LITERAL_in_fieldSpec4785); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefieldSpecEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) {
            	        	        OPTIONAL_LITERAL154_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OPTIONAL_LITERAL154));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, OPTIONAL_LITERAL154_tree);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:337:34: ( DEFAULT_LITERAL ( valueSet | value ) )
            	        	    {
            	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:337:34: ( DEFAULT_LITERAL ( valueSet | value ) )
            	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:337:35: DEFAULT_LITERAL ( valueSet | value )
            	        	        {
            	        	            DEFAULT_LITERAL155 = (pANTLR3_COMMON_TOKEN) MATCHT(DEFAULT_LITERAL, &FOLLOW_DEFAULT_LITERAL_in_fieldSpec4790); 
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto rulefieldSpecEx;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return retval;
            	        	            }
            	        	            if ( BACKTRACKING==0 ) {
            	        	            DEFAULT_LITERAL155_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DEFAULT_LITERAL155));
            	        	            ADAPTOR->addChild(ADAPTOR, root_0, DEFAULT_LITERAL155_tree);
            	        	            }

            	        	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:337:51: ( valueSet | value )
            	        	            {
            	        	                int alt63=2;
            	        	                switch ( LA(1) ) 
            	        	                {
            	        	                case L_BRACE:
            	        	                	{
            	        	                		switch ( LA(2) ) 
            	        	                		{
            	        	                		case NUMBER:
            	        	                			{
            	        	                				switch ( LA(3) ) 
            	        	                				{
            	        	                				case IDENTIFIER:
            	        	                				case NUMBER:
            	        	                					{
            	        	                						alt63=2;
            	        	                					}
            	        	                				    break;
            	        	                				case R_BRACE:
            	        	                					{

            	        	                						{
            	        	                						    int LA63_6 = LA(4);
            	        	                						    if ( (synpred80_asn1(ctx)) ) 
            	        	                						    {
            	        	                						        alt63=1;
            	        	                						    }
            	        	                						    else if ( (ANTLR3_TRUE) ) 
            	        	                						    {
            	        	                						        alt63=2;
            	        	                						    }
            	        	                						    else 
            	        	                						    {
            	        	                						        if (BACKTRACKING>0)
            	        	                						        {
            	        	                						            FAILEDFLAG = ANTLR3_TRUE;
            	        	                						            return retval;
            	        	                						        }
            	        	                						    
            	        	                						        CONSTRUCTEX();
            	        	                						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                						        EXCEPTION->message      = (void *)"";
            	        	                						        EXCEPTION->decisionNum  = 63;
            	        	                						        EXCEPTION->state        = 6;


            	        	                						        goto rulefieldSpecEx;
            	        	                						    }
            	        	                						}
            	        	                					}
            	        	                				    break;
            	        	                				case DOUBLE_DOT:
            	        	                				case LESS_THAN:
            	        	                				case COMMA:
            	        	                				case EXCEPT_LITERAL:
            	        	                				case POWER:
            	        	                				case PIPE:
            	        	                				case UNION_LITERAL:
            	        	                				case INTERSECTION_LITERAL:
            	        	                					{
            	        	                						alt63=1;
            	        	                					}
            	        	                				    break;

            	        	                				default:
            	        	                				    if (BACKTRACKING>0)
            	        	                				    {
            	        	                				        FAILEDFLAG = ANTLR3_TRUE;
            	        	                				        return retval;
            	        	                				    }
            	        	                				    CONSTRUCTEX();
            	        	                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                				    EXCEPTION->message      = (void *)"";
            	        	                				    EXCEPTION->decisionNum  = 63;
            	        	                				    EXCEPTION->state        = 3;


            	        	                				    goto rulefieldSpecEx;
            	        	                				}

            	        	                			}
            	        	                		    break;
            	        	                		case IDENTIFIER:
            	        	                			{
            	        	                				switch ( LA(3) ) 
            	        	                				{
            	        	                				case DOUBLE_DOT:
            	        	                				case LESS_THAN:
            	        	                				case COMMA:
            	        	                				case EXCEPT_LITERAL:
            	        	                				case POWER:
            	        	                				case PIPE:
            	        	                				case UNION_LITERAL:
            	        	                				case INTERSECTION_LITERAL:
            	        	                				case COLON:
            	        	                					{
            	        	                						alt63=1;
            	        	                					}
            	        	                				    break;
            	        	                				case DOT:
            	        	                				case L_BRACE:
            	        	                				case L_PARAN:
            	        	                				case IDENTIFIER:
            	        	                				case NUMBER:
            	        	                					{
            	        	                						alt63=2;
            	        	                					}
            	        	                				    break;
            	        	                				case R_BRACE:
            	        	                					{

            	        	                						{
            	        	                						    int LA63_6 = LA(4);
            	        	                						    if ( (synpred80_asn1(ctx)) ) 
            	        	                						    {
            	        	                						        alt63=1;
            	        	                						    }
            	        	                						    else if ( (ANTLR3_TRUE) ) 
            	        	                						    {
            	        	                						        alt63=2;
            	        	                						    }
            	        	                						    else 
            	        	                						    {
            	        	                						        if (BACKTRACKING>0)
            	        	                						        {
            	        	                						            FAILEDFLAG = ANTLR3_TRUE;
            	        	                						            return retval;
            	        	                						        }
            	        	                						    
            	        	                						        CONSTRUCTEX();
            	        	                						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                						        EXCEPTION->message      = (void *)"";
            	        	                						        EXCEPTION->decisionNum  = 63;
            	        	                						        EXCEPTION->state        = 6;


            	        	                						        goto rulefieldSpecEx;
            	        	                						    }
            	        	                						}
            	        	                					}
            	        	                				    break;

            	        	                				default:
            	        	                				    if (BACKTRACKING>0)
            	        	                				    {
            	        	                				        FAILEDFLAG = ANTLR3_TRUE;
            	        	                				        return retval;
            	        	                				    }
            	        	                				    CONSTRUCTEX();
            	        	                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                				    EXCEPTION->message      = (void *)"";
            	        	                				    EXCEPTION->decisionNum  = 63;
            	        	                				    EXCEPTION->state        = 4;


            	        	                				    goto rulefieldSpecEx;
            	        	                				}

            	        	                			}
            	        	                		    break;
            	        	                		case TRUE_LITERAL:
            	        	                		case FALSE_LITERAL:
            	        	                		case TRUE_SMALL_LITERAL:
            	        	                		case FALSE_SMALL_LITERAL:
            	        	                		case L_BRACE:
            	        	                		case MINUS:
            	        	                		case ALL_LITERAL:
            	        	                		case MIN_LITERAL:
            	        	                		case SIZE_LITERAL:
            	        	                		case PATTERN_LITERAL:
            	        	                		case BSTRING:
            	        	                			{
            	        	                				alt63=1;
            	        	                			}
            	        	                		    break;

            	        	                		default:
            	        	                		    if (BACKTRACKING>0)
            	        	                		    {
            	        	                		        FAILEDFLAG = ANTLR3_TRUE;
            	        	                		        return retval;
            	        	                		    }
            	        	                		    CONSTRUCTEX();
            	        	                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                		    EXCEPTION->message      = (void *)"";
            	        	                		    EXCEPTION->decisionNum  = 63;
            	        	                		    EXCEPTION->state        = 1;


            	        	                		    goto rulefieldSpecEx;
            	        	                		}

            	        	                	}
            	        	                    break;
            	        	                case TRUE_LITERAL:
            	        	                case FALSE_LITERAL:
            	        	                case TRUE_SMALL_LITERAL:
            	        	                case FALSE_SMALL_LITERAL:
            	        	                case MINUS:
            	        	                case IDENTIFIER:
            	        	                case NUMBER:
            	        	                case BSTRING:
            	        	                	{
            	        	                		alt63=2;
            	        	                	}
            	        	                    break;

            	        	                default:
            	        	                    if (BACKTRACKING>0)
            	        	                    {
            	        	                        FAILEDFLAG = ANTLR3_TRUE;
            	        	                        return retval;
            	        	                    }
            	        	                    CONSTRUCTEX();
            	        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                    EXCEPTION->message      = (void *)"";
            	        	                    EXCEPTION->decisionNum  = 63;
            	        	                    EXCEPTION->state        = 0;


            	        	                    goto rulefieldSpecEx;
            	        	                }

            	        	                switch (alt63) 
            	        	                {
            	        	            	case 1:
            	        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:337:52: valueSet
            	        	            	    {
            	        	            	        FOLLOWPUSH(FOLLOW_valueSet_in_fieldSpec4793);
            	        	            	        valueSet156=valueSet(ctx);

            	        	            	        FOLLOWPOP();
            	        	            	        if  (HASEXCEPTION())
            	        	            	        {
            	        	            	            goto rulefieldSpecEx;
            	        	            	        }
            	        	            	        if (HASFAILED())
            	        	            	        {
            	        	            	            return retval;
            	        	            	        }
            	        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, valueSet156.tree);

            	        	            	    }
            	        	            	    break;
            	        	            	case 2:
            	        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:337:63: value
            	        	            	    {
            	        	            	        FOLLOWPUSH(FOLLOW_value_in_fieldSpec4797);
            	        	            	        value157=value(ctx);

            	        	            	        FOLLOWPOP();
            	        	            	        if  (HASEXCEPTION())
            	        	            	        {
            	        	            	            goto rulefieldSpecEx;
            	        	            	        }
            	        	            	        if (HASFAILED())
            	        	            	        {
            	        	            	            return retval;
            	        	            	        }
            	        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value157.tree);

            	        	            	    }
            	        	            	    break;

            	        	                }
            	        	            }

            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 4:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:338:4: definedObjectClass ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( objectSet | object ) ) )?
            	    {
            	        FOLLOWPUSH(FOLLOW_definedObjectClass_in_fieldSpec4806);
            	        definedObjectClass158=definedObjectClass(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefieldSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedObjectClass158.tree);

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:338:23: ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL ( objectSet | object ) ) )?
            	        {
            	            int alt66=3;
            	            switch ( LA(1) ) 
            	            {
            	                case OPTIONAL_LITERAL:
            	                	{
            	                		alt66=1;
            	                	}
            	                    break;
            	                case DEFAULT_LITERAL:
            	                	{
            	                		alt66=2;
            	                	}
            	                    break;
            	            }

            	            switch (alt66) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:338:24: OPTIONAL_LITERAL
            	        	    {
            	        	        OPTIONAL_LITERAL159 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTIONAL_LITERAL, &FOLLOW_OPTIONAL_LITERAL_in_fieldSpec4809); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefieldSpecEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) {
            	        	        OPTIONAL_LITERAL159_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OPTIONAL_LITERAL159));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, OPTIONAL_LITERAL159_tree);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:338:43: ( DEFAULT_LITERAL ( objectSet | object ) )
            	        	    {
            	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:338:43: ( DEFAULT_LITERAL ( objectSet | object ) )
            	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:338:44: DEFAULT_LITERAL ( objectSet | object )
            	        	        {
            	        	            DEFAULT_LITERAL160 = (pANTLR3_COMMON_TOKEN) MATCHT(DEFAULT_LITERAL, &FOLLOW_DEFAULT_LITERAL_in_fieldSpec4814); 
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto rulefieldSpecEx;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return retval;
            	        	            }
            	        	            if ( BACKTRACKING==0 ) {
            	        	            DEFAULT_LITERAL160_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DEFAULT_LITERAL160));
            	        	            ADAPTOR->addChild(ADAPTOR, root_0, DEFAULT_LITERAL160_tree);
            	        	            }

            	        	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:338:60: ( objectSet | object )
            	        	            {
            	        	                int alt65=2;
            	        	                switch ( LA(1) ) 
            	        	                {
            	        	                case L_BRACE:
            	        	                	{
            	        	                		alt65=1;
            	        	                	}
            	        	                    break;
            	        	                case IDENTIFIER:
            	        	                	{
            	        	                		alt65=2;
            	        	                	}
            	        	                    break;

            	        	                default:
            	        	                    if (BACKTRACKING>0)
            	        	                    {
            	        	                        FAILEDFLAG = ANTLR3_TRUE;
            	        	                        return retval;
            	        	                    }
            	        	                    CONSTRUCTEX();
            	        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                    EXCEPTION->message      = (void *)"";
            	        	                    EXCEPTION->decisionNum  = 65;
            	        	                    EXCEPTION->state        = 0;


            	        	                    goto rulefieldSpecEx;
            	        	                }

            	        	                switch (alt65) 
            	        	                {
            	        	            	case 1:
            	        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:338:61: objectSet
            	        	            	    {
            	        	            	        FOLLOWPUSH(FOLLOW_objectSet_in_fieldSpec4817);
            	        	            	        objectSet161=objectSet(ctx);

            	        	            	        FOLLOWPOP();
            	        	            	        if  (HASEXCEPTION())
            	        	            	        {
            	        	            	            goto rulefieldSpecEx;
            	        	            	        }
            	        	            	        if (HASFAILED())
            	        	            	        {
            	        	            	            return retval;
            	        	            	        }
            	        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectSet161.tree);

            	        	            	    }
            	        	            	    break;
            	        	            	case 2:
            	        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:338:73: object
            	        	            	    {
            	        	            	        FOLLOWPUSH(FOLLOW_object_in_fieldSpec4821);
            	        	            	        object162=object(ctx);

            	        	            	        FOLLOWPOP();
            	        	            	        if  (HASEXCEPTION())
            	        	            	        {
            	        	            	            goto rulefieldSpecEx;
            	        	            	        }
            	        	            	        if (HASFAILED())
            	        	            	        {
            	        	            	            return retval;
            	        	            	        }
            	        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, object162.tree);

            	        	            	    }
            	        	            	    break;

            	        	                }
            	        	            }

            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefieldSpecEx; /* Prevent compiler warnings */
    rulefieldSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(49, fieldSpec_StartIndex); }

    return retval;
}
/* $ANTLR end fieldSpec */

/** 
 * $ANTLR start typeFieldSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:351:1: typeFieldSpec : AMPERSAND IDENTIFIER ( typeOptionalitySpec )? ;
 */
static asn1Parser_typeFieldSpec_return
typeFieldSpec(pasn1Parser ctx)
{   
    asn1Parser_typeFieldSpec_return retval;
    ANTLR3_UINT32 typeFieldSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AMPERSAND163;
    pANTLR3_COMMON_TOKEN    IDENTIFIER164;
    asn1Parser_typeOptionalitySpec_return typeOptionalitySpec165;
    #undef	RETURN_TYPE_typeOptionalitySpec165
    #define	RETURN_TYPE_typeOptionalitySpec165 asn1Parser_typeOptionalitySpec_return

    pANTLR3_BASE_TREE AMPERSAND163_tree;
    pANTLR3_BASE_TREE IDENTIFIER164_tree;

    /* Initialize rule variables
     */
    typeFieldSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(50)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    AMPERSAND163       = NULL;
    IDENTIFIER164       = NULL;
    typeOptionalitySpec165.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    AMPERSAND163_tree   = NULL;
    IDENTIFIER164_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:351:15: ( AMPERSAND IDENTIFIER ( typeOptionalitySpec )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:351:17: AMPERSAND IDENTIFIER ( typeOptionalitySpec )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            AMPERSAND163 = (pANTLR3_COMMON_TOKEN) MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_typeFieldSpec4847); 
            if  (HASEXCEPTION())
            {
                goto ruletypeFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            AMPERSAND163_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AMPERSAND163));
            ADAPTOR->addChild(ADAPTOR, root_0, AMPERSAND163_tree);
            }
            IDENTIFIER164 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_typeFieldSpec4849); 
            if  (HASEXCEPTION())
            {
                goto ruletypeFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER164_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER164));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER164_tree);
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:351:38: ( typeOptionalitySpec )?
            {
                int alt68=2;
                switch ( LA(1) ) 
                {
                    case OPTIONAL_LITERAL:
                    case DEFAULT_LITERAL:
                    	{
                    		alt68=1;
                    	}
                        break;
                }

                switch (alt68) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: typeOptionalitySpec
            	    {
            	        FOLLOWPUSH(FOLLOW_typeOptionalitySpec_in_typeFieldSpec4851);
            	        typeOptionalitySpec165=typeOptionalitySpec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeFieldSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typeOptionalitySpec165.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletypeFieldSpecEx; /* Prevent compiler warnings */
    ruletypeFieldSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(50, typeFieldSpec_StartIndex); }

    return retval;
}
/* $ANTLR end typeFieldSpec */

/** 
 * $ANTLR start typeOptionalitySpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:353:1: typeOptionalitySpec : ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL type ) );
 */
static asn1Parser_typeOptionalitySpec_return
typeOptionalitySpec(pasn1Parser ctx)
{   
    asn1Parser_typeOptionalitySpec_return retval;
    ANTLR3_UINT32 typeOptionalitySpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OPTIONAL_LITERAL166;
    pANTLR3_COMMON_TOKEN    DEFAULT_LITERAL167;
    asn1Parser_type_return type168;
    #undef	RETURN_TYPE_type168
    #define	RETURN_TYPE_type168 asn1Parser_type_return

    pANTLR3_BASE_TREE OPTIONAL_LITERAL166_tree;
    pANTLR3_BASE_TREE DEFAULT_LITERAL167_tree;

    /* Initialize rule variables
     */
    typeOptionalitySpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(51)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    OPTIONAL_LITERAL166       = NULL;
    DEFAULT_LITERAL167       = NULL;
    type168.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    OPTIONAL_LITERAL166_tree   = NULL;
    DEFAULT_LITERAL167_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:353:21: ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL type ) )
            
            ANTLR3_UINT32 alt69;

            alt69=2;

            switch ( LA(1) ) 
            {
            case OPTIONAL_LITERAL:
            	{
            		alt69=1;
            	}
                break;
            case DEFAULT_LITERAL:
            	{
            		alt69=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 69;
                EXCEPTION->state        = 0;


                goto ruletypeOptionalitySpecEx;
            }

            switch (alt69) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:353:23: OPTIONAL_LITERAL
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        OPTIONAL_LITERAL166 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTIONAL_LITERAL, &FOLLOW_OPTIONAL_LITERAL_in_typeOptionalitySpec4861); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletypeOptionalitySpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        OPTIONAL_LITERAL166_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OPTIONAL_LITERAL166));
        	        ADAPTOR->addChild(ADAPTOR, root_0, OPTIONAL_LITERAL166_tree);
        	        }

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:353:42: ( DEFAULT_LITERAL type )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:353:42: ( DEFAULT_LITERAL type )
        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:353:43: DEFAULT_LITERAL type
        	        {
        	            DEFAULT_LITERAL167 = (pANTLR3_COMMON_TOKEN) MATCHT(DEFAULT_LITERAL, &FOLLOW_DEFAULT_LITERAL_in_typeOptionalitySpec4866); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruletypeOptionalitySpecEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }
        	            if ( BACKTRACKING==0 ) {
        	            DEFAULT_LITERAL167_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DEFAULT_LITERAL167));
        	            ADAPTOR->addChild(ADAPTOR, root_0, DEFAULT_LITERAL167_tree);
        	            }
        	            FOLLOWPUSH(FOLLOW_type_in_typeOptionalitySpec4868);
        	            type168=type(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruletypeOptionalitySpecEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }
        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type168.tree);

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletypeOptionalitySpecEx; /* Prevent compiler warnings */
    ruletypeOptionalitySpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(51, typeOptionalitySpec_StartIndex); }

    return retval;
}
/* $ANTLR end typeOptionalitySpec */

/** 
 * $ANTLR start fixedTypeValueFieldSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:355:1: fixedTypeValueFieldSpec : AMPERSAND IDENTIFIER type ( UNIQUE_LITERAL )? ( valueOptionalitySpec )? ;
 */
static asn1Parser_fixedTypeValueFieldSpec_return
fixedTypeValueFieldSpec(pasn1Parser ctx)
{   
    asn1Parser_fixedTypeValueFieldSpec_return retval;
    ANTLR3_UINT32 fixedTypeValueFieldSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AMPERSAND169;
    pANTLR3_COMMON_TOKEN    IDENTIFIER170;
    pANTLR3_COMMON_TOKEN    UNIQUE_LITERAL172;
    asn1Parser_type_return type171;
    #undef	RETURN_TYPE_type171
    #define	RETURN_TYPE_type171 asn1Parser_type_return

    asn1Parser_valueOptionalitySpec_return valueOptionalitySpec173;
    #undef	RETURN_TYPE_valueOptionalitySpec173
    #define	RETURN_TYPE_valueOptionalitySpec173 asn1Parser_valueOptionalitySpec_return

    pANTLR3_BASE_TREE AMPERSAND169_tree;
    pANTLR3_BASE_TREE IDENTIFIER170_tree;
    pANTLR3_BASE_TREE UNIQUE_LITERAL172_tree;

    /* Initialize rule variables
     */
    fixedTypeValueFieldSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(52)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    AMPERSAND169       = NULL;
    IDENTIFIER170       = NULL;
    UNIQUE_LITERAL172       = NULL;
    type171.tree = NULL;

    valueOptionalitySpec173.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    AMPERSAND169_tree   = NULL;
    IDENTIFIER170_tree   = NULL;
    UNIQUE_LITERAL172_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:355:25: ( AMPERSAND IDENTIFIER type ( UNIQUE_LITERAL )? ( valueOptionalitySpec )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:355:27: AMPERSAND IDENTIFIER type ( UNIQUE_LITERAL )? ( valueOptionalitySpec )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            AMPERSAND169 = (pANTLR3_COMMON_TOKEN) MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_fixedTypeValueFieldSpec4877); 
            if  (HASEXCEPTION())
            {
                goto rulefixedTypeValueFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            AMPERSAND169_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AMPERSAND169));
            ADAPTOR->addChild(ADAPTOR, root_0, AMPERSAND169_tree);
            }
            IDENTIFIER170 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_fixedTypeValueFieldSpec4879); 
            if  (HASEXCEPTION())
            {
                goto rulefixedTypeValueFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER170_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER170));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER170_tree);
            }
            FOLLOWPUSH(FOLLOW_type_in_fixedTypeValueFieldSpec4881);
            type171=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefixedTypeValueFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type171.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:355:53: ( UNIQUE_LITERAL )?
            {
                int alt70=2;
                switch ( LA(1) ) 
                {
                    case UNIQUE_LITERAL:
                    	{
                    		alt70=1;
                    	}
                        break;
                }

                switch (alt70) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: UNIQUE_LITERAL
            	    {
            	        UNIQUE_LITERAL172 = (pANTLR3_COMMON_TOKEN) MATCHT(UNIQUE_LITERAL, &FOLLOW_UNIQUE_LITERAL_in_fixedTypeValueFieldSpec4883); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefixedTypeValueFieldSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        UNIQUE_LITERAL172_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, UNIQUE_LITERAL172));
            	        ADAPTOR->addChild(ADAPTOR, root_0, UNIQUE_LITERAL172_tree);
            	        }

            	    }
            	    break;

                }
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:355:69: ( valueOptionalitySpec )?
            {
                int alt71=2;
                switch ( LA(1) ) 
                {
                    case OPTIONAL_LITERAL:
                    case DEFAULT_LITERAL:
                    	{
                    		alt71=1;
                    	}
                        break;
                }

                switch (alt71) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: valueOptionalitySpec
            	    {
            	        FOLLOWPUSH(FOLLOW_valueOptionalitySpec_in_fixedTypeValueFieldSpec4886);
            	        valueOptionalitySpec173=valueOptionalitySpec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefixedTypeValueFieldSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, valueOptionalitySpec173.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefixedTypeValueFieldSpecEx; /* Prevent compiler warnings */
    rulefixedTypeValueFieldSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(52, fixedTypeValueFieldSpec_StartIndex); }

    return retval;
}
/* $ANTLR end fixedTypeValueFieldSpec */

/** 
 * $ANTLR start valueOptionalitySpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:357:1: valueOptionalitySpec : ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL value ) );
 */
static asn1Parser_valueOptionalitySpec_return
valueOptionalitySpec(pasn1Parser ctx)
{   
    asn1Parser_valueOptionalitySpec_return retval;
    ANTLR3_UINT32 valueOptionalitySpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OPTIONAL_LITERAL174;
    pANTLR3_COMMON_TOKEN    DEFAULT_LITERAL175;
    asn1Parser_value_return value176;
    #undef	RETURN_TYPE_value176
    #define	RETURN_TYPE_value176 asn1Parser_value_return

    pANTLR3_BASE_TREE OPTIONAL_LITERAL174_tree;
    pANTLR3_BASE_TREE DEFAULT_LITERAL175_tree;

    /* Initialize rule variables
     */
    valueOptionalitySpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(53)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    OPTIONAL_LITERAL174       = NULL;
    DEFAULT_LITERAL175       = NULL;
    value176.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    OPTIONAL_LITERAL174_tree   = NULL;
    DEFAULT_LITERAL175_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:357:22: ( OPTIONAL_LITERAL | ( DEFAULT_LITERAL value ) )
            
            ANTLR3_UINT32 alt72;

            alt72=2;

            switch ( LA(1) ) 
            {
            case OPTIONAL_LITERAL:
            	{
            		alt72=1;
            	}
                break;
            case DEFAULT_LITERAL:
            	{
            		alt72=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 72;
                EXCEPTION->state        = 0;


                goto rulevalueOptionalitySpecEx;
            }

            switch (alt72) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:357:24: OPTIONAL_LITERAL
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        OPTIONAL_LITERAL174 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTIONAL_LITERAL, &FOLLOW_OPTIONAL_LITERAL_in_valueOptionalitySpec4897); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevalueOptionalitySpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        OPTIONAL_LITERAL174_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OPTIONAL_LITERAL174));
        	        ADAPTOR->addChild(ADAPTOR, root_0, OPTIONAL_LITERAL174_tree);
        	        }

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:357:43: ( DEFAULT_LITERAL value )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:357:43: ( DEFAULT_LITERAL value )
        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:357:44: DEFAULT_LITERAL value
        	        {
        	            DEFAULT_LITERAL175 = (pANTLR3_COMMON_TOKEN) MATCHT(DEFAULT_LITERAL, &FOLLOW_DEFAULT_LITERAL_in_valueOptionalitySpec4902); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulevalueOptionalitySpecEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }
        	            if ( BACKTRACKING==0 ) {
        	            DEFAULT_LITERAL175_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DEFAULT_LITERAL175));
        	            ADAPTOR->addChild(ADAPTOR, root_0, DEFAULT_LITERAL175_tree);
        	            }
        	            FOLLOWPUSH(FOLLOW_value_in_valueOptionalitySpec4904);
        	            value176=value(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulevalueOptionalitySpecEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }
        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value176.tree);

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulevalueOptionalitySpecEx; /* Prevent compiler warnings */
    rulevalueOptionalitySpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(53, valueOptionalitySpec_StartIndex); }

    return retval;
}
/* $ANTLR end valueOptionalitySpec */

/** 
 * $ANTLR start variableTypeValueFieldSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:360:1: variableTypeValueFieldSpec : AMPERSAND IDENTIFIER fieldName ( valueOptionalitySpec )? ;
 */
static asn1Parser_variableTypeValueFieldSpec_return
variableTypeValueFieldSpec(pasn1Parser ctx)
{   
    asn1Parser_variableTypeValueFieldSpec_return retval;
    ANTLR3_UINT32 variableTypeValueFieldSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AMPERSAND177;
    pANTLR3_COMMON_TOKEN    IDENTIFIER178;
    asn1Parser_fieldName_return fieldName179;
    #undef	RETURN_TYPE_fieldName179
    #define	RETURN_TYPE_fieldName179 asn1Parser_fieldName_return

    asn1Parser_valueOptionalitySpec_return valueOptionalitySpec180;
    #undef	RETURN_TYPE_valueOptionalitySpec180
    #define	RETURN_TYPE_valueOptionalitySpec180 asn1Parser_valueOptionalitySpec_return

    pANTLR3_BASE_TREE AMPERSAND177_tree;
    pANTLR3_BASE_TREE IDENTIFIER178_tree;

    /* Initialize rule variables
     */
    variableTypeValueFieldSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(54)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    AMPERSAND177       = NULL;
    IDENTIFIER178       = NULL;
    fieldName179.tree = NULL;

    valueOptionalitySpec180.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    AMPERSAND177_tree   = NULL;
    IDENTIFIER178_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:360:28: ( AMPERSAND IDENTIFIER fieldName ( valueOptionalitySpec )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:360:30: AMPERSAND IDENTIFIER fieldName ( valueOptionalitySpec )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            AMPERSAND177 = (pANTLR3_COMMON_TOKEN) MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_variableTypeValueFieldSpec4914); 
            if  (HASEXCEPTION())
            {
                goto rulevariableTypeValueFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            AMPERSAND177_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AMPERSAND177));
            ADAPTOR->addChild(ADAPTOR, root_0, AMPERSAND177_tree);
            }
            IDENTIFIER178 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_variableTypeValueFieldSpec4916); 
            if  (HASEXCEPTION())
            {
                goto rulevariableTypeValueFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER178_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER178));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER178_tree);
            }
            FOLLOWPUSH(FOLLOW_fieldName_in_variableTypeValueFieldSpec4919);
            fieldName179=fieldName(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevariableTypeValueFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fieldName179.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:360:62: ( valueOptionalitySpec )?
            {
                int alt73=2;
                switch ( LA(1) ) 
                {
                    case OPTIONAL_LITERAL:
                    case DEFAULT_LITERAL:
                    	{
                    		alt73=1;
                    	}
                        break;
                }

                switch (alt73) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: valueOptionalitySpec
            	    {
            	        FOLLOWPUSH(FOLLOW_valueOptionalitySpec_in_variableTypeValueFieldSpec4921);
            	        valueOptionalitySpec180=valueOptionalitySpec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableTypeValueFieldSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, valueOptionalitySpec180.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableTypeValueFieldSpecEx; /* Prevent compiler warnings */
    rulevariableTypeValueFieldSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(54, variableTypeValueFieldSpec_StartIndex); }

    return retval;
}
/* $ANTLR end variableTypeValueFieldSpec */

/** 
 * $ANTLR start fixedTypeValueSetFieldSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:363:1: fixedTypeValueSetFieldSpec : AMPERSAND IDENTIFIER type ( valueSetOptionalitySpec )? ;
 */
static asn1Parser_fixedTypeValueSetFieldSpec_return
fixedTypeValueSetFieldSpec(pasn1Parser ctx)
{   
    asn1Parser_fixedTypeValueSetFieldSpec_return retval;
    ANTLR3_UINT32 fixedTypeValueSetFieldSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AMPERSAND181;
    pANTLR3_COMMON_TOKEN    IDENTIFIER182;
    asn1Parser_type_return type183;
    #undef	RETURN_TYPE_type183
    #define	RETURN_TYPE_type183 asn1Parser_type_return

    asn1Parser_valueSetOptionalitySpec_return valueSetOptionalitySpec184;
    #undef	RETURN_TYPE_valueSetOptionalitySpec184
    #define	RETURN_TYPE_valueSetOptionalitySpec184 asn1Parser_valueSetOptionalitySpec_return

    pANTLR3_BASE_TREE AMPERSAND181_tree;
    pANTLR3_BASE_TREE IDENTIFIER182_tree;

    /* Initialize rule variables
     */
    fixedTypeValueSetFieldSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(55)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    AMPERSAND181       = NULL;
    IDENTIFIER182       = NULL;
    type183.tree = NULL;

    valueSetOptionalitySpec184.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    AMPERSAND181_tree   = NULL;
    IDENTIFIER182_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:363:28: ( AMPERSAND IDENTIFIER type ( valueSetOptionalitySpec )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:363:30: AMPERSAND IDENTIFIER type ( valueSetOptionalitySpec )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            AMPERSAND181 = (pANTLR3_COMMON_TOKEN) MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_fixedTypeValueSetFieldSpec4933); 
            if  (HASEXCEPTION())
            {
                goto rulefixedTypeValueSetFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            AMPERSAND181_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AMPERSAND181));
            ADAPTOR->addChild(ADAPTOR, root_0, AMPERSAND181_tree);
            }
            IDENTIFIER182 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_fixedTypeValueSetFieldSpec4935); 
            if  (HASEXCEPTION())
            {
                goto rulefixedTypeValueSetFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER182_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER182));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER182_tree);
            }
            FOLLOWPUSH(FOLLOW_type_in_fixedTypeValueSetFieldSpec4939);
            type183=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefixedTypeValueSetFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type183.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:363:58: ( valueSetOptionalitySpec )?
            {
                int alt74=2;
                switch ( LA(1) ) 
                {
                    case OPTIONAL_LITERAL:
                    case DEFAULT_LITERAL:
                    	{
                    		alt74=1;
                    	}
                        break;
                }

                switch (alt74) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: valueSetOptionalitySpec
            	    {
            	        FOLLOWPUSH(FOLLOW_valueSetOptionalitySpec_in_fixedTypeValueSetFieldSpec4941);
            	        valueSetOptionalitySpec184=valueSetOptionalitySpec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefixedTypeValueSetFieldSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, valueSetOptionalitySpec184.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefixedTypeValueSetFieldSpecEx; /* Prevent compiler warnings */
    rulefixedTypeValueSetFieldSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(55, fixedTypeValueSetFieldSpec_StartIndex); }

    return retval;
}
/* $ANTLR end fixedTypeValueSetFieldSpec */

/** 
 * $ANTLR start valueSetOptionalitySpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:366:1: valueSetOptionalitySpec : ( OPTIONAL_LITERAL | DEFAULT_LITERAL valueSet );
 */
static asn1Parser_valueSetOptionalitySpec_return
valueSetOptionalitySpec(pasn1Parser ctx)
{   
    asn1Parser_valueSetOptionalitySpec_return retval;
    ANTLR3_UINT32 valueSetOptionalitySpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OPTIONAL_LITERAL185;
    pANTLR3_COMMON_TOKEN    DEFAULT_LITERAL186;
    asn1Parser_valueSet_return valueSet187;
    #undef	RETURN_TYPE_valueSet187
    #define	RETURN_TYPE_valueSet187 asn1Parser_valueSet_return

    pANTLR3_BASE_TREE OPTIONAL_LITERAL185_tree;
    pANTLR3_BASE_TREE DEFAULT_LITERAL186_tree;

    /* Initialize rule variables
     */
    valueSetOptionalitySpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(56)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    OPTIONAL_LITERAL185       = NULL;
    DEFAULT_LITERAL186       = NULL;
    valueSet187.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    OPTIONAL_LITERAL185_tree   = NULL;
    DEFAULT_LITERAL186_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:366:25: ( OPTIONAL_LITERAL | DEFAULT_LITERAL valueSet )
            
            ANTLR3_UINT32 alt75;

            alt75=2;

            switch ( LA(1) ) 
            {
            case OPTIONAL_LITERAL:
            	{
            		alt75=1;
            	}
                break;
            case DEFAULT_LITERAL:
            	{
            		alt75=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 75;
                EXCEPTION->state        = 0;


                goto rulevalueSetOptionalitySpecEx;
            }

            switch (alt75) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:366:27: OPTIONAL_LITERAL
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        OPTIONAL_LITERAL185 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTIONAL_LITERAL, &FOLLOW_OPTIONAL_LITERAL_in_valueSetOptionalitySpec4953); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevalueSetOptionalitySpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        OPTIONAL_LITERAL185_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OPTIONAL_LITERAL185));
        	        ADAPTOR->addChild(ADAPTOR, root_0, OPTIONAL_LITERAL185_tree);
        	        }

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:366:46: DEFAULT_LITERAL valueSet
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        DEFAULT_LITERAL186 = (pANTLR3_COMMON_TOKEN) MATCHT(DEFAULT_LITERAL, &FOLLOW_DEFAULT_LITERAL_in_valueSetOptionalitySpec4957); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevalueSetOptionalitySpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        DEFAULT_LITERAL186_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DEFAULT_LITERAL186));
        	        ADAPTOR->addChild(ADAPTOR, root_0, DEFAULT_LITERAL186_tree);
        	        }
        	        FOLLOWPUSH(FOLLOW_valueSet_in_valueSetOptionalitySpec4959);
        	        valueSet187=valueSet(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevalueSetOptionalitySpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, valueSet187.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulevalueSetOptionalitySpecEx; /* Prevent compiler warnings */
    rulevalueSetOptionalitySpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(56, valueSetOptionalitySpec_StartIndex); }

    return retval;
}
/* $ANTLR end valueSetOptionalitySpec */

/** 
 * $ANTLR start object
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:369:1: object : ( definedObject | parameterizedObject );
 */
static asn1Parser_object_return
object(pasn1Parser ctx)
{   
    asn1Parser_object_return retval;
    ANTLR3_UINT32 object_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_definedObject_return definedObject188;
    #undef	RETURN_TYPE_definedObject188
    #define	RETURN_TYPE_definedObject188 asn1Parser_definedObject_return

    asn1Parser_parameterizedObject_return parameterizedObject189;
    #undef	RETURN_TYPE_parameterizedObject189
    #define	RETURN_TYPE_parameterizedObject189 asn1Parser_parameterizedObject_return


    /* Initialize rule variables
     */
    object_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(57)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    definedObject188.tree = NULL;

    parameterizedObject189.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:369:8: ( definedObject | parameterizedObject )
            
            ANTLR3_UINT32 alt76;

            alt76=2;

            switch ( LA(1) ) 
            {
            case IDENTIFIER:
            	{
            		switch ( LA(2) ) 
            		{
            		case DOT:
            			{
            				switch ( LA(3) ) 
            				{
            				case EOF:
            				case R_BRACE:
            				case COMMA:
            				case END_LITERAL:
            				case IDENTIFIER:
            					{
            						alt76=1;
            					}
            				    break;
            				case L_BRACE:
            					{
            						alt76=2;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return retval;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 76;
            				    EXCEPTION->state        = 2;


            				    goto ruleobjectEx;
            				}

            			}
            		    break;
            		case L_BRACE:
            			{
            				alt76=2;
            			}
            		    break;
            		case EOF:
            		case R_BRACE:
            		case COMMA:
            		case END_LITERAL:
            		case IDENTIFIER:
            			{
            				alt76=1;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 76;
            		    EXCEPTION->state        = 1;


            		    goto ruleobjectEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 76;
                EXCEPTION->state        = 0;


                goto ruleobjectEx;
            }

            switch (alt76) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:369:10: definedObject
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_definedObject_in_object4969);
        	        definedObject188=definedObject(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedObject188.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:369:63: parameterizedObject
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_parameterizedObject_in_object4975);
        	        parameterizedObject189=parameterizedObject(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, parameterizedObject189.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectEx; /* Prevent compiler warnings */
    ruleobjectEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(57, object_StartIndex); }

    return retval;
}
/* $ANTLR end object */

/** 
 * $ANTLR start parameterizedObject
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:371:1: parameterizedObject : definedObject actualParameterList ;
 */
static asn1Parser_parameterizedObject_return
parameterizedObject(pasn1Parser ctx)
{   
    asn1Parser_parameterizedObject_return retval;
    ANTLR3_UINT32 parameterizedObject_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_definedObject_return definedObject190;
    #undef	RETURN_TYPE_definedObject190
    #define	RETURN_TYPE_definedObject190 asn1Parser_definedObject_return

    asn1Parser_actualParameterList_return actualParameterList191;
    #undef	RETURN_TYPE_actualParameterList191
    #define	RETURN_TYPE_actualParameterList191 asn1Parser_actualParameterList_return


    /* Initialize rule variables
     */
    parameterizedObject_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(58)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    definedObject190.tree = NULL;

    actualParameterList191.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:371:21: ( definedObject actualParameterList )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:371:23: definedObject actualParameterList
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_definedObject_in_parameterizedObject4984);
            definedObject190=definedObject(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameterizedObjectEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedObject190.tree);
            FOLLOWPUSH(FOLLOW_actualParameterList_in_parameterizedObject4986);
            actualParameterList191=actualParameterList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameterizedObjectEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, actualParameterList191.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparameterizedObjectEx; /* Prevent compiler warnings */
    ruleparameterizedObjectEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(58, parameterizedObject_StartIndex); }

    return retval;
}
/* $ANTLR end parameterizedObject */

/** 
 * $ANTLR start definedObject
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:375:1: definedObject : IDENTIFIER ( DOT )? ;
 */
static asn1Parser_definedObject_return
definedObject(pasn1Parser ctx)
{   
    asn1Parser_definedObject_return retval;
    ANTLR3_UINT32 definedObject_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER192;
    pANTLR3_COMMON_TOKEN    DOT193;

    pANTLR3_BASE_TREE IDENTIFIER192_tree;
    pANTLR3_BASE_TREE DOT193_tree;

    /* Initialize rule variables
     */
    definedObject_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(59)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IDENTIFIER192       = NULL;
    DOT193       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER192_tree   = NULL;
    DOT193_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:376:2: ( IDENTIFIER ( DOT )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:376:4: IDENTIFIER ( DOT )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER192 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_definedObject4998); 
            if  (HASEXCEPTION())
            {
                goto ruledefinedObjectEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER192_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER192));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER192_tree);
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:376:15: ( DOT )?
            {
                int alt77=2;
                switch ( LA(1) ) 
                {
                    case DOT:
                    	{
                    		alt77=1;
                    	}
                        break;
                }

                switch (alt77) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:376:16: DOT
            	    {
            	        DOT193 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_definedObject5001); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledefinedObjectEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        DOT193_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT193));
            	        ADAPTOR->addChild(ADAPTOR, root_0, DOT193_tree);
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledefinedObjectEx; /* Prevent compiler warnings */
    ruledefinedObjectEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(59, definedObject_StartIndex); }

    return retval;
}
/* $ANTLR end definedObject */

/** 
 * $ANTLR start objectSet
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:378:1: objectSet : L_BRACE objectSetSpec R_BRACE ;
 */
static asn1Parser_objectSet_return
objectSet(pasn1Parser ctx)
{   
    asn1Parser_objectSet_return retval;
    ANTLR3_UINT32 objectSet_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    L_BRACE194;
    pANTLR3_COMMON_TOKEN    R_BRACE196;
    asn1Parser_objectSetSpec_return objectSetSpec195;
    #undef	RETURN_TYPE_objectSetSpec195
    #define	RETURN_TYPE_objectSetSpec195 asn1Parser_objectSetSpec_return

    pANTLR3_BASE_TREE L_BRACE194_tree;
    pANTLR3_BASE_TREE R_BRACE196_tree;

    /* Initialize rule variables
     */
    objectSet_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(60)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    L_BRACE194       = NULL;
    R_BRACE196       = NULL;
    objectSetSpec195.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    L_BRACE194_tree   = NULL;
    R_BRACE196_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:378:11: ( L_BRACE objectSetSpec R_BRACE )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:378:13: L_BRACE objectSetSpec R_BRACE
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            L_BRACE194 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_objectSet5013); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectSetEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            L_BRACE194_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, L_BRACE194));
            ADAPTOR->addChild(ADAPTOR, root_0, L_BRACE194_tree);
            }
            FOLLOWPUSH(FOLLOW_objectSetSpec_in_objectSet5015);
            objectSetSpec195=objectSetSpec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobjectSetEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectSetSpec195.tree);
            R_BRACE196 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_objectSet5017); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectSetEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            R_BRACE196_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, R_BRACE196));
            ADAPTOR->addChild(ADAPTOR, root_0, R_BRACE196_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectSetEx; /* Prevent compiler warnings */
    ruleobjectSetEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(60, objectSet_StartIndex); }

    return retval;
}
/* $ANTLR end objectSet */

/** 
 * $ANTLR start objectSetSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:380:1: objectSetSpec : ( rootElementSetSpec ( COMMA ELLIPSIS ( COMMA additionalElementSetSpec )? )? | ELLIPSIS ( COMMA additionalElementSetSpec )? );
 */
static asn1Parser_objectSetSpec_return
objectSetSpec(pasn1Parser ctx)
{   
    asn1Parser_objectSetSpec_return retval;
    ANTLR3_UINT32 objectSetSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA198;
    pANTLR3_COMMON_TOKEN    ELLIPSIS199;
    pANTLR3_COMMON_TOKEN    COMMA200;
    pANTLR3_COMMON_TOKEN    ELLIPSIS202;
    pANTLR3_COMMON_TOKEN    COMMA203;
    asn1Parser_rootElementSetSpec_return rootElementSetSpec197;
    #undef	RETURN_TYPE_rootElementSetSpec197
    #define	RETURN_TYPE_rootElementSetSpec197 asn1Parser_rootElementSetSpec_return

    asn1Parser_additionalElementSetSpec_return additionalElementSetSpec201;
    #undef	RETURN_TYPE_additionalElementSetSpec201
    #define	RETURN_TYPE_additionalElementSetSpec201 asn1Parser_additionalElementSetSpec_return

    asn1Parser_additionalElementSetSpec_return additionalElementSetSpec204;
    #undef	RETURN_TYPE_additionalElementSetSpec204
    #define	RETURN_TYPE_additionalElementSetSpec204 asn1Parser_additionalElementSetSpec_return

    pANTLR3_BASE_TREE COMMA198_tree;
    pANTLR3_BASE_TREE ELLIPSIS199_tree;
    pANTLR3_BASE_TREE COMMA200_tree;
    pANTLR3_BASE_TREE ELLIPSIS202_tree;
    pANTLR3_BASE_TREE COMMA203_tree;

    /* Initialize rule variables
     */
    objectSetSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(61)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA198       = NULL;
    ELLIPSIS199       = NULL;
    COMMA200       = NULL;
    ELLIPSIS202       = NULL;
    COMMA203       = NULL;
    rootElementSetSpec197.tree = NULL;

    additionalElementSetSpec201.tree = NULL;

    additionalElementSetSpec204.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA198_tree   = NULL;
    ELLIPSIS199_tree   = NULL;
    COMMA200_tree   = NULL;
    ELLIPSIS202_tree   = NULL;
    COMMA203_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:380:15: ( rootElementSetSpec ( COMMA ELLIPSIS ( COMMA additionalElementSetSpec )? )? | ELLIPSIS ( COMMA additionalElementSetSpec )? )
            
            ANTLR3_UINT32 alt81;

            alt81=2;

            switch ( LA(1) ) 
            {
            case TRUE_LITERAL:
            case FALSE_LITERAL:
            case TRUE_SMALL_LITERAL:
            case FALSE_SMALL_LITERAL:
            case L_BRACE:
            case MINUS:
            case ALL_LITERAL:
            case MIN_LITERAL:
            case SIZE_LITERAL:
            case PATTERN_LITERAL:
            case IDENTIFIER:
            case NUMBER:
            case BSTRING:
            	{
            		alt81=1;
            	}
                break;
            case ELLIPSIS:
            	{
            		alt81=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 81;
                EXCEPTION->state        = 0;


                goto ruleobjectSetSpecEx;
            }

            switch (alt81) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:381:3: rootElementSetSpec ( COMMA ELLIPSIS ( COMMA additionalElementSetSpec )? )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_rootElementSetSpec_in_objectSetSpec5029);
        	        rootElementSetSpec197=rootElementSetSpec(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectSetSpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rootElementSetSpec197.tree);

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:381:22: ( COMMA ELLIPSIS ( COMMA additionalElementSetSpec )? )?
        	        {
        	            int alt79=2;
        	            switch ( LA(1) ) 
        	            {
        	                case COMMA:
        	                	{
        	                		alt79=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt79) 
        	            {
        	        	case 1:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:381:23: COMMA ELLIPSIS ( COMMA additionalElementSetSpec )?
        	        	    {
        	        	        COMMA198 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_objectSetSpec5032); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleobjectSetSpecEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) {
        	        	        COMMA198_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA198));
        	        	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA198_tree);
        	        	        }
        	        	        ELLIPSIS199 = (pANTLR3_COMMON_TOKEN) MATCHT(ELLIPSIS, &FOLLOW_ELLIPSIS_in_objectSetSpec5034); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleobjectSetSpecEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) {
        	        	        ELLIPSIS199_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ELLIPSIS199));
        	        	        ADAPTOR->addChild(ADAPTOR, root_0, ELLIPSIS199_tree);
        	        	        }

        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:381:38: ( COMMA additionalElementSetSpec )?
        	        	        {
        	        	            int alt78=2;
        	        	            switch ( LA(1) ) 
        	        	            {
        	        	                case COMMA:
        	        	                	{
        	        	                		alt78=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt78) 
        	        	            {
        	        	        	case 1:
        	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:381:39: COMMA additionalElementSetSpec
        	        	        	    {
        	        	        	        COMMA200 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_objectSetSpec5037); 
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleobjectSetSpecEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }
        	        	        	        if ( BACKTRACKING==0 ) {
        	        	        	        COMMA200_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA200));
        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA200_tree);
        	        	        	        }
        	        	        	        FOLLOWPUSH(FOLLOW_additionalElementSetSpec_in_objectSetSpec5039);
        	        	        	        additionalElementSetSpec201=additionalElementSetSpec(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleobjectSetSpecEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }
        	        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, additionalElementSetSpec201.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:382:4: ELLIPSIS ( COMMA additionalElementSetSpec )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        ELLIPSIS202 = (pANTLR3_COMMON_TOKEN) MATCHT(ELLIPSIS, &FOLLOW_ELLIPSIS_in_objectSetSpec5049); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectSetSpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        ELLIPSIS202_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ELLIPSIS202));
        	        ADAPTOR->addChild(ADAPTOR, root_0, ELLIPSIS202_tree);
        	        }

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:382:13: ( COMMA additionalElementSetSpec )?
        	        {
        	            int alt80=2;
        	            switch ( LA(1) ) 
        	            {
        	                case COMMA:
        	                	{
        	                		alt80=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt80) 
        	            {
        	        	case 1:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:382:14: COMMA additionalElementSetSpec
        	        	    {
        	        	        COMMA203 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_objectSetSpec5052); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleobjectSetSpecEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) {
        	        	        COMMA203_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA203));
        	        	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA203_tree);
        	        	        }
        	        	        FOLLOWPUSH(FOLLOW_additionalElementSetSpec_in_objectSetSpec5054);
        	        	        additionalElementSetSpec204=additionalElementSetSpec(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleobjectSetSpecEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, additionalElementSetSpec204.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectSetSpecEx; /* Prevent compiler warnings */
    ruleobjectSetSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(61, objectSetSpec_StartIndex); }

    return retval;
}
/* $ANTLR end objectSetSpec */

/** 
 * $ANTLR start fieldName
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:386:1: fieldName : ( AMPERSAND IDENTIFIER ) ( AMPERSAND IDENTIFIER DOT )* ;
 */
static asn1Parser_fieldName_return
fieldName(pasn1Parser ctx)
{   
    asn1Parser_fieldName_return retval;
    ANTLR3_UINT32 fieldName_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AMPERSAND205;
    pANTLR3_COMMON_TOKEN    IDENTIFIER206;
    pANTLR3_COMMON_TOKEN    AMPERSAND207;
    pANTLR3_COMMON_TOKEN    IDENTIFIER208;
    pANTLR3_COMMON_TOKEN    DOT209;

    pANTLR3_BASE_TREE AMPERSAND205_tree;
    pANTLR3_BASE_TREE IDENTIFIER206_tree;
    pANTLR3_BASE_TREE AMPERSAND207_tree;
    pANTLR3_BASE_TREE IDENTIFIER208_tree;
    pANTLR3_BASE_TREE DOT209_tree;

    /* Initialize rule variables
     */
    fieldName_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(62)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    AMPERSAND205       = NULL;
    IDENTIFIER206       = NULL;
    AMPERSAND207       = NULL;
    IDENTIFIER208       = NULL;
    DOT209       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    AMPERSAND205_tree   = NULL;
    IDENTIFIER206_tree   = NULL;
    AMPERSAND207_tree   = NULL;
    IDENTIFIER208_tree   = NULL;
    DOT209_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:386:11: ( ( AMPERSAND IDENTIFIER ) ( AMPERSAND IDENTIFIER DOT )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:386:12: ( AMPERSAND IDENTIFIER ) ( AMPERSAND IDENTIFIER DOT )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:386:12: ( AMPERSAND IDENTIFIER )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:386:13: AMPERSAND IDENTIFIER
            {
                AMPERSAND205 = (pANTLR3_COMMON_TOKEN) MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_fieldName5067); 
                if  (HASEXCEPTION())
                {
                    goto rulefieldNameEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) {
                AMPERSAND205_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AMPERSAND205));
                ADAPTOR->addChild(ADAPTOR, root_0, AMPERSAND205_tree);
                }
                IDENTIFIER206 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_fieldName5069); 
                if  (HASEXCEPTION())
                {
                    goto rulefieldNameEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) {
                IDENTIFIER206_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER206));
                ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER206_tree);
                }

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:386:34: ( AMPERSAND IDENTIFIER DOT )*

            for (;;)
            {
                int alt82=2;
                switch ( LA(1) ) 
                {
                case AMPERSAND:
                	{
                		alt82=1;
                	}
                    break;

                }

                switch (alt82) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:386:35: AMPERSAND IDENTIFIER DOT
            	    {
            	        AMPERSAND207 = (pANTLR3_COMMON_TOKEN) MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_fieldName5072); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefieldNameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        AMPERSAND207_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AMPERSAND207));
            	        ADAPTOR->addChild(ADAPTOR, root_0, AMPERSAND207_tree);
            	        }
            	        IDENTIFIER208 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_fieldName5074); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefieldNameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        IDENTIFIER208_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER208));
            	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER208_tree);
            	        }
            	        DOT209 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_fieldName5076); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefieldNameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        DOT209_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT209));
            	        ADAPTOR->addChild(ADAPTOR, root_0, DOT209_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop82;	/* break out of the loop */
            	    break;
                }
            }
            loop82: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefieldNameEx; /* Prevent compiler warnings */
    rulefieldNameEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(62, fieldName_StartIndex); }

    return retval;
}
/* $ANTLR end fieldName */

/** 
 * $ANTLR start valueSet
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:388:1: valueSet : L_BRACE elementSetSpecs R_BRACE ;
 */
static asn1Parser_valueSet_return
valueSet(pasn1Parser ctx)
{   
    asn1Parser_valueSet_return retval;
    ANTLR3_UINT32 valueSet_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    L_BRACE210;
    pANTLR3_COMMON_TOKEN    R_BRACE212;
    asn1Parser_elementSetSpecs_return elementSetSpecs211;
    #undef	RETURN_TYPE_elementSetSpecs211
    #define	RETURN_TYPE_elementSetSpecs211 asn1Parser_elementSetSpecs_return

    pANTLR3_BASE_TREE L_BRACE210_tree;
    pANTLR3_BASE_TREE R_BRACE212_tree;

    /* Initialize rule variables
     */
    valueSet_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(63)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    L_BRACE210       = NULL;
    R_BRACE212       = NULL;
    elementSetSpecs211.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    L_BRACE210_tree   = NULL;
    R_BRACE212_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:388:10: ( L_BRACE elementSetSpecs R_BRACE )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:388:12: L_BRACE elementSetSpecs R_BRACE
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            L_BRACE210 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_valueSet5086); 
            if  (HASEXCEPTION())
            {
                goto rulevalueSetEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            L_BRACE210_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, L_BRACE210));
            ADAPTOR->addChild(ADAPTOR, root_0, L_BRACE210_tree);
            }
            FOLLOWPUSH(FOLLOW_elementSetSpecs_in_valueSet5088);
            elementSetSpecs211=elementSetSpecs(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevalueSetEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, elementSetSpecs211.tree);
            R_BRACE212 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_valueSet5090); 
            if  (HASEXCEPTION())
            {
                goto rulevalueSetEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            R_BRACE212_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, R_BRACE212));
            ADAPTOR->addChild(ADAPTOR, root_0, R_BRACE212_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevalueSetEx; /* Prevent compiler warnings */
    rulevalueSetEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(63, valueSet_StartIndex); }

    return retval;
}
/* $ANTLR end valueSet */

/** 
 * $ANTLR start elementSetSpecs
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:390:1: elementSetSpecs : rootElementSetSpec ( COMMA ELLIPSIS ( COMMA additionalElementSetSpec )? )? ;
 */
static asn1Parser_elementSetSpecs_return
elementSetSpecs(pasn1Parser ctx)
{   
    asn1Parser_elementSetSpecs_return retval;
    ANTLR3_UINT32 elementSetSpecs_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA214;
    pANTLR3_COMMON_TOKEN    ELLIPSIS215;
    pANTLR3_COMMON_TOKEN    COMMA216;
    asn1Parser_rootElementSetSpec_return rootElementSetSpec213;
    #undef	RETURN_TYPE_rootElementSetSpec213
    #define	RETURN_TYPE_rootElementSetSpec213 asn1Parser_rootElementSetSpec_return

    asn1Parser_additionalElementSetSpec_return additionalElementSetSpec217;
    #undef	RETURN_TYPE_additionalElementSetSpec217
    #define	RETURN_TYPE_additionalElementSetSpec217 asn1Parser_additionalElementSetSpec_return

    pANTLR3_BASE_TREE COMMA214_tree;
    pANTLR3_BASE_TREE ELLIPSIS215_tree;
    pANTLR3_BASE_TREE COMMA216_tree;

    /* Initialize rule variables
     */
    elementSetSpecs_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(64)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA214       = NULL;
    ELLIPSIS215       = NULL;
    COMMA216       = NULL;
    rootElementSetSpec213.tree = NULL;

    additionalElementSetSpec217.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA214_tree   = NULL;
    ELLIPSIS215_tree   = NULL;
    COMMA216_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:390:17: ( rootElementSetSpec ( COMMA ELLIPSIS ( COMMA additionalElementSetSpec )? )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:391:2: rootElementSetSpec ( COMMA ELLIPSIS ( COMMA additionalElementSetSpec )? )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_rootElementSetSpec_in_elementSetSpecs5101);
            rootElementSetSpec213=rootElementSetSpec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleelementSetSpecsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rootElementSetSpec213.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:391:21: ( COMMA ELLIPSIS ( COMMA additionalElementSetSpec )? )?
            {
                int alt84=2;
                switch ( LA(1) ) 
                {
                    case COMMA:
                    	{
                    		{
                    		    int LA84_1 = LA(2);
                    		    if ( (synpred102_asn1(ctx)) ) 
                    		    {
                    		        alt84=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt84) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:391:22: COMMA ELLIPSIS ( COMMA additionalElementSetSpec )?
            	    {
            	        COMMA214 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_elementSetSpecs5104); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleelementSetSpecsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        COMMA214_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA214));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA214_tree);
            	        }
            	        ELLIPSIS215 = (pANTLR3_COMMON_TOKEN) MATCHT(ELLIPSIS, &FOLLOW_ELLIPSIS_in_elementSetSpecs5106); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleelementSetSpecsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        ELLIPSIS215_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ELLIPSIS215));
            	        ADAPTOR->addChild(ADAPTOR, root_0, ELLIPSIS215_tree);
            	        }

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:391:37: ( COMMA additionalElementSetSpec )?
            	        {
            	            int alt83=2;
            	            switch ( LA(1) ) 
            	            {
            	                case COMMA:
            	                	{
            	                		switch ( LA(2) ) 
            	                		{
            	                		    case TRUE_LITERAL:
            	                		    case FALSE_LITERAL:
            	                		    case TRUE_SMALL_LITERAL:
            	                		    case FALSE_SMALL_LITERAL:
            	                		    case L_BRACE:
            	                		    case MINUS:
            	                		    case ALL_LITERAL:
            	                		    case MIN_LITERAL:
            	                		    case SIZE_LITERAL:
            	                		    case PATTERN_LITERAL:
            	                		    case IDENTIFIER:
            	                		    case NUMBER:
            	                		    case BSTRING:
            	                		    	{
            	                		    		alt83=1;
            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt83) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:391:38: COMMA additionalElementSetSpec
            	        	    {
            	        	        COMMA216 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_elementSetSpecs5109); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleelementSetSpecsEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) {
            	        	        COMMA216_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA216));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA216_tree);
            	        	        }
            	        	        FOLLOWPUSH(FOLLOW_additionalElementSetSpec_in_elementSetSpecs5111);
            	        	        additionalElementSetSpec217=additionalElementSetSpec(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleelementSetSpecsEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, additionalElementSetSpec217.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleelementSetSpecsEx; /* Prevent compiler warnings */
    ruleelementSetSpecsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(64, elementSetSpecs_StartIndex); }

    return retval;
}
/* $ANTLR end elementSetSpecs */

/** 
 * $ANTLR start rootElementSetSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:393:1: rootElementSetSpec : elementSetSpec ;
 */
static asn1Parser_rootElementSetSpec_return
rootElementSetSpec(pasn1Parser ctx)
{   
    asn1Parser_rootElementSetSpec_return retval;
    ANTLR3_UINT32 rootElementSetSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_elementSetSpec_return elementSetSpec218;
    #undef	RETURN_TYPE_elementSetSpec218
    #define	RETURN_TYPE_elementSetSpec218 asn1Parser_elementSetSpec_return


    /* Initialize rule variables
     */
    rootElementSetSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(65)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    elementSetSpec218.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:393:20: ( elementSetSpec )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:393:22: elementSetSpec
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_elementSetSpec_in_rootElementSetSpec5124);
            elementSetSpec218=elementSetSpec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerootElementSetSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, elementSetSpec218.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerootElementSetSpecEx; /* Prevent compiler warnings */
    rulerootElementSetSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(65, rootElementSetSpec_StartIndex); }

    return retval;
}
/* $ANTLR end rootElementSetSpec */

/** 
 * $ANTLR start additionalElementSetSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:395:1: additionalElementSetSpec : elementSetSpec ;
 */
static asn1Parser_additionalElementSetSpec_return
additionalElementSetSpec(pasn1Parser ctx)
{   
    asn1Parser_additionalElementSetSpec_return retval;
    ANTLR3_UINT32 additionalElementSetSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_elementSetSpec_return elementSetSpec219;
    #undef	RETURN_TYPE_elementSetSpec219
    #define	RETURN_TYPE_elementSetSpec219 asn1Parser_elementSetSpec_return


    /* Initialize rule variables
     */
    additionalElementSetSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(66)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    elementSetSpec219.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:395:26: ( elementSetSpec )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:395:28: elementSetSpec
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_elementSetSpec_in_additionalElementSetSpec5133);
            elementSetSpec219=elementSetSpec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleadditionalElementSetSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, elementSetSpec219.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleadditionalElementSetSpecEx; /* Prevent compiler warnings */
    ruleadditionalElementSetSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(66, additionalElementSetSpec_StartIndex); }

    return retval;
}
/* $ANTLR end additionalElementSetSpec */

/** 
 * $ANTLR start elementSetSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:397:1: elementSetSpec : ( unions | ALL_LITERAL exclusions );
 */
static asn1Parser_elementSetSpec_return
elementSetSpec(pasn1Parser ctx)
{   
    asn1Parser_elementSetSpec_return retval;
    ANTLR3_UINT32 elementSetSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ALL_LITERAL221;
    asn1Parser_unions_return unions220;
    #undef	RETURN_TYPE_unions220
    #define	RETURN_TYPE_unions220 asn1Parser_unions_return

    asn1Parser_exclusions_return exclusions222;
    #undef	RETURN_TYPE_exclusions222
    #define	RETURN_TYPE_exclusions222 asn1Parser_exclusions_return

    pANTLR3_BASE_TREE ALL_LITERAL221_tree;

    /* Initialize rule variables
     */
    elementSetSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(67)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    ALL_LITERAL221       = NULL;
    unions220.tree = NULL;

    exclusions222.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    ALL_LITERAL221_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:397:16: ( unions | ALL_LITERAL exclusions )
            
            ANTLR3_UINT32 alt85;

            alt85=2;

            switch ( LA(1) ) 
            {
            case TRUE_LITERAL:
            case FALSE_LITERAL:
            case TRUE_SMALL_LITERAL:
            case FALSE_SMALL_LITERAL:
            case L_BRACE:
            case MINUS:
            case MIN_LITERAL:
            case SIZE_LITERAL:
            case PATTERN_LITERAL:
            case IDENTIFIER:
            case NUMBER:
            case BSTRING:
            	{
            		alt85=1;
            	}
                break;
            case ALL_LITERAL:
            	{
            		alt85=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 85;
                EXCEPTION->state        = 0;


                goto ruleelementSetSpecEx;
            }

            switch (alt85) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:397:18: unions
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_unions_in_elementSetSpec5142);
        	        unions220=unions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleelementSetSpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unions220.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:397:27: ALL_LITERAL exclusions
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        ALL_LITERAL221 = (pANTLR3_COMMON_TOKEN) MATCHT(ALL_LITERAL, &FOLLOW_ALL_LITERAL_in_elementSetSpec5146); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleelementSetSpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        ALL_LITERAL221_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ALL_LITERAL221));
        	        ADAPTOR->addChild(ADAPTOR, root_0, ALL_LITERAL221_tree);
        	        }
        	        FOLLOWPUSH(FOLLOW_exclusions_in_elementSetSpec5148);
        	        exclusions222=exclusions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleelementSetSpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, exclusions222.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleelementSetSpecEx; /* Prevent compiler warnings */
    ruleelementSetSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(67, elementSetSpec_StartIndex); }

    return retval;
}
/* $ANTLR end elementSetSpec */

/** 
 * $ANTLR start unions
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:399:1: unions : ( intersections ) ( unionMark intersections )* ;
 */
static asn1Parser_unions_return
unions(pasn1Parser ctx)
{   
    asn1Parser_unions_return retval;
    ANTLR3_UINT32 unions_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_intersections_return intersections223;
    #undef	RETURN_TYPE_intersections223
    #define	RETURN_TYPE_intersections223 asn1Parser_intersections_return

    asn1Parser_unionMark_return unionMark224;
    #undef	RETURN_TYPE_unionMark224
    #define	RETURN_TYPE_unionMark224 asn1Parser_unionMark_return

    asn1Parser_intersections_return intersections225;
    #undef	RETURN_TYPE_intersections225
    #define	RETURN_TYPE_intersections225 asn1Parser_intersections_return


    /* Initialize rule variables
     */
    unions_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(68)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    intersections223.tree = NULL;

    unionMark224.tree = NULL;

    intersections225.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:399:8: ( ( intersections ) ( unionMark intersections )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:399:12: ( intersections ) ( unionMark intersections )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:399:12: ( intersections )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:399:13: intersections
            {
                FOLLOWPUSH(FOLLOW_intersections_in_unions5160);
                intersections223=intersections(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleunionsEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, intersections223.tree);

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:399:28: ( unionMark intersections )*

            for (;;)
            {
                int alt86=2;
                switch ( LA(1) ) 
                {
                case PIPE:
                case UNION_LITERAL:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA86_2 = LA(2);
                		    if ( (synpred104_asn1(ctx)) ) 
                		    {
                		        alt86=1;
                		    }

                		}
                	}
                    break;

                }

                switch (alt86) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:399:29: unionMark intersections
            	    {
            	        FOLLOWPUSH(FOLLOW_unionMark_in_unions5164);
            	        unionMark224=unionMark(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unionMark224.tree);
            	        FOLLOWPUSH(FOLLOW_intersections_in_unions5166);
            	        intersections225=intersections(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, intersections225.tree);

            	    }
            	    break;

            	default:
            	    goto loop86;	/* break out of the loop */
            	    break;
                }
            }
            loop86: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleunionsEx; /* Prevent compiler warnings */
    ruleunionsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(68, unions_StartIndex); }

    return retval;
}
/* $ANTLR end unions */

/** 
 * $ANTLR start exclusions
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:401:1: exclusions : EXCEPT_LITERAL elements ;
 */
static asn1Parser_exclusions_return
exclusions(pasn1Parser ctx)
{   
    asn1Parser_exclusions_return retval;
    ANTLR3_UINT32 exclusions_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EXCEPT_LITERAL226;
    asn1Parser_elements_return elements227;
    #undef	RETURN_TYPE_elements227
    #define	RETURN_TYPE_elements227 asn1Parser_elements_return

    pANTLR3_BASE_TREE EXCEPT_LITERAL226_tree;

    /* Initialize rule variables
     */
    exclusions_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(69)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    EXCEPT_LITERAL226       = NULL;
    elements227.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    EXCEPT_LITERAL226_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:401:12: ( EXCEPT_LITERAL elements )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:401:14: EXCEPT_LITERAL elements
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            EXCEPT_LITERAL226 = (pANTLR3_COMMON_TOKEN) MATCHT(EXCEPT_LITERAL, &FOLLOW_EXCEPT_LITERAL_in_exclusions5176); 
            if  (HASEXCEPTION())
            {
                goto ruleexclusionsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            EXCEPT_LITERAL226_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EXCEPT_LITERAL226));
            ADAPTOR->addChild(ADAPTOR, root_0, EXCEPT_LITERAL226_tree);
            }
            FOLLOWPUSH(FOLLOW_elements_in_exclusions5178);
            elements227=elements(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexclusionsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, elements227.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexclusionsEx; /* Prevent compiler warnings */
    ruleexclusionsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(69, exclusions_StartIndex); }

    return retval;
}
/* $ANTLR end exclusions */

/** 
 * $ANTLR start intersections
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:403:1: intersections : ( intersectionElements ) ( intersectionMark intersectionElements )* ;
 */
static asn1Parser_intersections_return
intersections(pasn1Parser ctx)
{   
    asn1Parser_intersections_return retval;
    ANTLR3_UINT32 intersections_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_intersectionElements_return intersectionElements228;
    #undef	RETURN_TYPE_intersectionElements228
    #define	RETURN_TYPE_intersectionElements228 asn1Parser_intersectionElements_return

    asn1Parser_intersectionMark_return intersectionMark229;
    #undef	RETURN_TYPE_intersectionMark229
    #define	RETURN_TYPE_intersectionMark229 asn1Parser_intersectionMark_return

    asn1Parser_intersectionElements_return intersectionElements230;
    #undef	RETURN_TYPE_intersectionElements230
    #define	RETURN_TYPE_intersectionElements230 asn1Parser_intersectionElements_return


    /* Initialize rule variables
     */
    intersections_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(70)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    intersectionElements228.tree = NULL;

    intersectionMark229.tree = NULL;

    intersectionElements230.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:403:15: ( ( intersectionElements ) ( intersectionMark intersectionElements )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:403:17: ( intersectionElements ) ( intersectionMark intersectionElements )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:403:17: ( intersectionElements )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:403:18: intersectionElements
            {
                FOLLOWPUSH(FOLLOW_intersectionElements_in_intersections5188);
                intersectionElements228=intersectionElements(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleintersectionsEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, intersectionElements228.tree);

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:403:40: ( intersectionMark intersectionElements )*

            for (;;)
            {
                int alt87=2;
                switch ( LA(1) ) 
                {
                case POWER:
                case INTERSECTION_LITERAL:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA87_2 = LA(2);
                		    if ( (synpred105_asn1(ctx)) ) 
                		    {
                		        alt87=1;
                		    }

                		}
                	}
                    break;

                }

                switch (alt87) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:403:41: intersectionMark intersectionElements
            	    {
            	        FOLLOWPUSH(FOLLOW_intersectionMark_in_intersections5192);
            	        intersectionMark229=intersectionMark(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintersectionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, intersectionMark229.tree);
            	        FOLLOWPUSH(FOLLOW_intersectionElements_in_intersections5194);
            	        intersectionElements230=intersectionElements(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintersectionsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, intersectionElements230.tree);

            	    }
            	    break;

            	default:
            	    goto loop87;	/* break out of the loop */
            	    break;
                }
            }
            loop87: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleintersectionsEx; /* Prevent compiler warnings */
    ruleintersectionsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(70, intersections_StartIndex); }

    return retval;
}
/* $ANTLR end intersections */

/** 
 * $ANTLR start unionMark
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:405:1: unionMark : ( PIPE | UNION_LITERAL );
 */
static asn1Parser_unionMark_return
unionMark(pasn1Parser ctx)
{   
    asn1Parser_unionMark_return retval;
    ANTLR3_UINT32 unionMark_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set231;

    pANTLR3_BASE_TREE set231_tree;

    /* Initialize rule variables
     */
    unionMark_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(71)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    set231       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set231_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:405:12: ( PIPE | UNION_LITERAL )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set231=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= PIPE) && (LA(1) <= UNION_LITERAL)) )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set231)));
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_unionMark0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_unionMark0);    goto ruleunionMarkEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleunionMarkEx; /* Prevent compiler warnings */
    ruleunionMarkEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(71, unionMark_StartIndex); }

    return retval;
}
/* $ANTLR end unionMark */

/** 
 * $ANTLR start intersectionMark
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:408:1: intersectionMark : ( POWER | INTERSECTION_LITERAL );
 */
static asn1Parser_intersectionMark_return
intersectionMark(pasn1Parser ctx)
{   
    asn1Parser_intersectionMark_return retval;
    ANTLR3_UINT32 intersectionMark_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set232;

    pANTLR3_BASE_TREE set232_tree;

    /* Initialize rule variables
     */
    intersectionMark_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(72)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    set232       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set232_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:408:19: ( POWER | INTERSECTION_LITERAL )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set232=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( LA(1) == POWER || LA(1) == INTERSECTION_LITERAL )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set232)));
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_intersectionMark0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_intersectionMark0);    goto ruleintersectionMarkEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleintersectionMarkEx; /* Prevent compiler warnings */
    ruleintersectionMarkEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(72, intersectionMark_StartIndex); }

    return retval;
}
/* $ANTLR end intersectionMark */

/** 
 * $ANTLR start elements
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:411:1: elements : subtypeElements ;
 */
static asn1Parser_elements_return
elements(pasn1Parser ctx)
{   
    asn1Parser_elements_return retval;
    ANTLR3_UINT32 elements_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_subtypeElements_return subtypeElements233;
    #undef	RETURN_TYPE_subtypeElements233
    #define	RETURN_TYPE_subtypeElements233 asn1Parser_subtypeElements_return


    /* Initialize rule variables
     */
    elements_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(73)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    subtypeElements233.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:411:11: ( subtypeElements )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:411:13: subtypeElements
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_subtypeElements_in_elements5247);
            subtypeElements233=subtypeElements(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleelementsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, subtypeElements233.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleelementsEx; /* Prevent compiler warnings */
    ruleelementsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(73, elements_StartIndex); }

    return retval;
}
/* $ANTLR end elements */

/** 
 * $ANTLR start objectSetElements
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:415:1: objectSetElements : ( object | definedObject );
 */
static asn1Parser_objectSetElements_return
objectSetElements(pasn1Parser ctx)
{   
    asn1Parser_objectSetElements_return retval;
    ANTLR3_UINT32 objectSetElements_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_object_return object234;
    #undef	RETURN_TYPE_object234
    #define	RETURN_TYPE_object234 asn1Parser_object_return

    asn1Parser_definedObject_return definedObject235;
    #undef	RETURN_TYPE_definedObject235
    #define	RETURN_TYPE_definedObject235 asn1Parser_definedObject_return


    /* Initialize rule variables
     */
    objectSetElements_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(74)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    object234.tree = NULL;

    definedObject235.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:415:19: ( object | definedObject )
            
            ANTLR3_UINT32 alt88;

            alt88=2;

            switch ( LA(1) ) 
            {
            case IDENTIFIER:
            	{

            		{
            		    int LA88_1 = LA(2);
            		    if ( (synpred108_asn1(ctx)) ) 
            		    {
            		        alt88=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt88=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 88;
            		        EXCEPTION->state        = 1;


            		        goto ruleobjectSetElementsEx;
            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 88;
                EXCEPTION->state        = 0;


                goto ruleobjectSetElementsEx;
            }

            switch (alt88) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:416:5: object
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_object_in_objectSetElements5263);
        	        object234=object(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectSetElementsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, object234.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:416:14: definedObject
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_definedObject_in_objectSetElements5267);
        	        definedObject235=definedObject(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectSetElementsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedObject235.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectSetElementsEx; /* Prevent compiler warnings */
    ruleobjectSetElementsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(74, objectSetElements_StartIndex); }

    return retval;
}
/* $ANTLR end objectSetElements */

/** 
 * $ANTLR start intersectionElements
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:420:1: intersectionElements : elements ( exclusions )? ;
 */
static asn1Parser_intersectionElements_return
intersectionElements(pasn1Parser ctx)
{   
    asn1Parser_intersectionElements_return retval;
    ANTLR3_UINT32 intersectionElements_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_elements_return elements236;
    #undef	RETURN_TYPE_elements236
    #define	RETURN_TYPE_elements236 asn1Parser_elements_return

    asn1Parser_exclusions_return exclusions237;
    #undef	RETURN_TYPE_exclusions237
    #define	RETURN_TYPE_exclusions237 asn1Parser_exclusions_return


    /* Initialize rule variables
     */
    intersectionElements_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(75)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    elements236.tree = NULL;

    exclusions237.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:420:22: ( elements ( exclusions )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:420:24: elements ( exclusions )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_elements_in_intersectionElements5279);
            elements236=elements(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleintersectionElementsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, elements236.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:420:33: ( exclusions )?
            {
                int alt89=2;
                switch ( LA(1) ) 
                {
                    case EXCEPT_LITERAL:
                    	{
                    		{
                    		    int LA89_1 = LA(2);
                    		    if ( (synpred109_asn1(ctx)) ) 
                    		    {
                    		        alt89=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt89) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:420:34: exclusions
            	    {
            	        FOLLOWPUSH(FOLLOW_exclusions_in_intersectionElements5282);
            	        exclusions237=exclusions(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintersectionElementsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, exclusions237.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleintersectionElementsEx; /* Prevent compiler warnings */
    ruleintersectionElementsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(75, intersectionElements_StartIndex); }

    return retval;
}
/* $ANTLR end intersectionElements */

/** 
 * $ANTLR start subtypeElements
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:422:1: subtypeElements : ( ( ( value | MIN_LITERAL ) ( LESS_THAN )? DOUBLE_DOT ( LESS_THAN )? ( value | MAX_LITERAL ) ) | sizeConstraint | ( PATTERN_LITERAL value ) | value );
 */
static asn1Parser_subtypeElements_return
subtypeElements(pasn1Parser ctx)
{   
    asn1Parser_subtypeElements_return retval;
    ANTLR3_UINT32 subtypeElements_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    MIN_LITERAL239;
    pANTLR3_COMMON_TOKEN    LESS_THAN240;
    pANTLR3_COMMON_TOKEN    DOUBLE_DOT241;
    pANTLR3_COMMON_TOKEN    LESS_THAN242;
    pANTLR3_COMMON_TOKEN    MAX_LITERAL244;
    pANTLR3_COMMON_TOKEN    PATTERN_LITERAL246;
    asn1Parser_value_return value238;
    #undef	RETURN_TYPE_value238
    #define	RETURN_TYPE_value238 asn1Parser_value_return

    asn1Parser_value_return value243;
    #undef	RETURN_TYPE_value243
    #define	RETURN_TYPE_value243 asn1Parser_value_return

    asn1Parser_sizeConstraint_return sizeConstraint245;
    #undef	RETURN_TYPE_sizeConstraint245
    #define	RETURN_TYPE_sizeConstraint245 asn1Parser_sizeConstraint_return

    asn1Parser_value_return value247;
    #undef	RETURN_TYPE_value247
    #define	RETURN_TYPE_value247 asn1Parser_value_return

    asn1Parser_value_return value248;
    #undef	RETURN_TYPE_value248
    #define	RETURN_TYPE_value248 asn1Parser_value_return

    pANTLR3_BASE_TREE MIN_LITERAL239_tree;
    pANTLR3_BASE_TREE LESS_THAN240_tree;
    pANTLR3_BASE_TREE DOUBLE_DOT241_tree;
    pANTLR3_BASE_TREE LESS_THAN242_tree;
    pANTLR3_BASE_TREE MAX_LITERAL244_tree;
    pANTLR3_BASE_TREE PATTERN_LITERAL246_tree;

    /* Initialize rule variables
     */
    subtypeElements_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(76)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    MIN_LITERAL239       = NULL;
    LESS_THAN240       = NULL;
    DOUBLE_DOT241       = NULL;
    LESS_THAN242       = NULL;
    MAX_LITERAL244       = NULL;
    PATTERN_LITERAL246       = NULL;
    value238.tree = NULL;

    value243.tree = NULL;

    sizeConstraint245.tree = NULL;

    value247.tree = NULL;

    value248.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    MIN_LITERAL239_tree   = NULL;
    LESS_THAN240_tree   = NULL;
    DOUBLE_DOT241_tree   = NULL;
    LESS_THAN242_tree   = NULL;
    MAX_LITERAL244_tree   = NULL;
    PATTERN_LITERAL246_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:422:17: ( ( ( value | MIN_LITERAL ) ( LESS_THAN )? DOUBLE_DOT ( LESS_THAN )? ( value | MAX_LITERAL ) ) | sizeConstraint | ( PATTERN_LITERAL value ) | value )
            
            ANTLR3_UINT32 alt94;

            alt94=4;

            switch ( LA(1) ) 
            {
            case IDENTIFIER:
            	{

            		{
            		    int LA94_1 = LA(2);
            		    if ( (synpred114_asn1(ctx)) ) 
            		    {
            		        alt94=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt94=4;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 94;
            		        EXCEPTION->state        = 1;


            		        goto rulesubtypeElementsEx;
            		    }
            		}
            	}
                break;
            case MINUS:
            	{

            		{
            		    int LA94_2 = LA(2);
            		    if ( (synpred114_asn1(ctx)) ) 
            		    {
            		        alt94=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt94=4;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 94;
            		        EXCEPTION->state        = 2;


            		        goto rulesubtypeElementsEx;
            		    }
            		}
            	}
                break;
            case NUMBER:
            	{

            		{
            		    int LA94_3 = LA(2);
            		    if ( (synpred114_asn1(ctx)) ) 
            		    {
            		        alt94=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt94=4;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 94;
            		        EXCEPTION->state        = 3;


            		        goto rulesubtypeElementsEx;
            		    }
            		}
            	}
                break;
            case L_BRACE:
            	{

            		{
            		    int LA94_4 = LA(2);
            		    if ( (synpred114_asn1(ctx)) ) 
            		    {
            		        alt94=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt94=4;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 94;
            		        EXCEPTION->state        = 4;


            		        goto rulesubtypeElementsEx;
            		    }
            		}
            	}
                break;
            case TRUE_LITERAL:
            case FALSE_LITERAL:
            case TRUE_SMALL_LITERAL:
            case FALSE_SMALL_LITERAL:
            	{

            		{
            		    int LA94_5 = LA(2);
            		    if ( (synpred114_asn1(ctx)) ) 
            		    {
            		        alt94=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt94=4;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 94;
            		        EXCEPTION->state        = 5;


            		        goto rulesubtypeElementsEx;
            		    }
            		}
            	}
                break;
            case BSTRING:
            	{

            		{
            		    int LA94_6 = LA(2);
            		    if ( (synpred114_asn1(ctx)) ) 
            		    {
            		        alt94=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt94=4;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 94;
            		        EXCEPTION->state        = 6;


            		        goto rulesubtypeElementsEx;
            		    }
            		}
            	}
                break;
            case MIN_LITERAL:
            	{
            		alt94=1;
            	}
                break;
            case SIZE_LITERAL:
            	{
            		alt94=2;
            	}
                break;
            case PATTERN_LITERAL:
            	{
            		alt94=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 94;
                EXCEPTION->state        = 0;


                goto rulesubtypeElementsEx;
            }

            switch (alt94) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:3: ( ( value | MIN_LITERAL ) ( LESS_THAN )? DOUBLE_DOT ( LESS_THAN )? ( value | MAX_LITERAL ) )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:3: ( ( value | MIN_LITERAL ) ( LESS_THAN )? DOUBLE_DOT ( LESS_THAN )? ( value | MAX_LITERAL ) )
        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:4: ( value | MIN_LITERAL ) ( LESS_THAN )? DOUBLE_DOT ( LESS_THAN )? ( value | MAX_LITERAL )
        	        {

        	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:4: ( value | MIN_LITERAL )
        	            {
        	                int alt90=2;
        	                switch ( LA(1) ) 
        	                {
        	                case TRUE_LITERAL:
        	                case FALSE_LITERAL:
        	                case TRUE_SMALL_LITERAL:
        	                case FALSE_SMALL_LITERAL:
        	                case L_BRACE:
        	                case MINUS:
        	                case IDENTIFIER:
        	                case NUMBER:
        	                case BSTRING:
        	                	{
        	                		alt90=1;
        	                	}
        	                    break;
        	                case MIN_LITERAL:
        	                	{
        	                		alt90=2;
        	                	}
        	                    break;

        	                default:
        	                    if (BACKTRACKING>0)
        	                    {
        	                        FAILEDFLAG = ANTLR3_TRUE;
        	                        return retval;
        	                    }
        	                    CONSTRUCTEX();
        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                    EXCEPTION->message      = (void *)"";
        	                    EXCEPTION->decisionNum  = 90;
        	                    EXCEPTION->state        = 0;


        	                    goto rulesubtypeElementsEx;
        	                }

        	                switch (alt90) 
        	                {
        	            	case 1:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:5: value
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_value_in_subtypeElements5300);
        	            	        value238=value(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulesubtypeElementsEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value238.tree);

        	            	    }
        	            	    break;
        	            	case 2:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:13: MIN_LITERAL
        	            	    {
        	            	        MIN_LITERAL239 = (pANTLR3_COMMON_TOKEN) MATCHT(MIN_LITERAL, &FOLLOW_MIN_LITERAL_in_subtypeElements5304); 
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulesubtypeElementsEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) {
        	            	        MIN_LITERAL239_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, MIN_LITERAL239));
        	            	        ADAPTOR->addChild(ADAPTOR, root_0, MIN_LITERAL239_tree);
        	            	        }

        	            	    }
        	            	    break;

        	                }
        	            }

        	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:26: ( LESS_THAN )?
        	            {
        	                int alt91=2;
        	                switch ( LA(1) ) 
        	                {
        	                    case LESS_THAN:
        	                    	{
        	                    		alt91=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt91) 
        	                {
        	            	case 1:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: LESS_THAN
        	            	    {
        	            	        LESS_THAN240 = (pANTLR3_COMMON_TOKEN) MATCHT(LESS_THAN, &FOLLOW_LESS_THAN_in_subtypeElements5307); 
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulesubtypeElementsEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) {
        	            	        LESS_THAN240_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LESS_THAN240));
        	            	        ADAPTOR->addChild(ADAPTOR, root_0, LESS_THAN240_tree);
        	            	        }

        	            	    }
        	            	    break;

        	                }
        	            }
        	            DOUBLE_DOT241 = (pANTLR3_COMMON_TOKEN) MATCHT(DOUBLE_DOT, &FOLLOW_DOUBLE_DOT_in_subtypeElements5311); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesubtypeElementsEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }
        	            if ( BACKTRACKING==0 ) {
        	            DOUBLE_DOT241_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOUBLE_DOT241));
        	            ADAPTOR->addChild(ADAPTOR, root_0, DOUBLE_DOT241_tree);
        	            }

        	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:49: ( LESS_THAN )?
        	            {
        	                int alt92=2;
        	                switch ( LA(1) ) 
        	                {
        	                    case LESS_THAN:
        	                    	{
        	                    		alt92=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt92) 
        	                {
        	            	case 1:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: LESS_THAN
        	            	    {
        	            	        LESS_THAN242 = (pANTLR3_COMMON_TOKEN) MATCHT(LESS_THAN, &FOLLOW_LESS_THAN_in_subtypeElements5313); 
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulesubtypeElementsEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) {
        	            	        LESS_THAN242_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LESS_THAN242));
        	            	        ADAPTOR->addChild(ADAPTOR, root_0, LESS_THAN242_tree);
        	            	        }

        	            	    }
        	            	    break;

        	                }
        	            }

        	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:61: ( value | MAX_LITERAL )
        	            {
        	                int alt93=2;
        	                switch ( LA(1) ) 
        	                {
        	                case TRUE_LITERAL:
        	                case FALSE_LITERAL:
        	                case TRUE_SMALL_LITERAL:
        	                case FALSE_SMALL_LITERAL:
        	                case L_BRACE:
        	                case MINUS:
        	                case IDENTIFIER:
        	                case NUMBER:
        	                case BSTRING:
        	                	{
        	                		alt93=1;
        	                	}
        	                    break;
        	                case MAX_LITERAL:
        	                	{
        	                		alt93=2;
        	                	}
        	                    break;

        	                default:
        	                    if (BACKTRACKING>0)
        	                    {
        	                        FAILEDFLAG = ANTLR3_TRUE;
        	                        return retval;
        	                    }
        	                    CONSTRUCTEX();
        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                    EXCEPTION->message      = (void *)"";
        	                    EXCEPTION->decisionNum  = 93;
        	                    EXCEPTION->state        = 0;


        	                    goto rulesubtypeElementsEx;
        	                }

        	                switch (alt93) 
        	                {
        	            	case 1:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:62: value
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_value_in_subtypeElements5318);
        	            	        value243=value(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulesubtypeElementsEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value243.tree);

        	            	    }
        	            	    break;
        	            	case 2:
        	            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:70: MAX_LITERAL
        	            	    {
        	            	        MAX_LITERAL244 = (pANTLR3_COMMON_TOKEN) MATCHT(MAX_LITERAL, &FOLLOW_MAX_LITERAL_in_subtypeElements5322); 
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulesubtypeElementsEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) {
        	            	        MAX_LITERAL244_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, MAX_LITERAL244));
        	            	        ADAPTOR->addChild(ADAPTOR, root_0, MAX_LITERAL244_tree);
        	            	        }

        	            	    }
        	            	    break;

        	                }
        	            }

        	        }


        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:424:4: sizeConstraint
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_sizeConstraint_in_subtypeElements5330);
        	        sizeConstraint245=sizeConstraint(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesubtypeElementsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, sizeConstraint245.tree);

        	    }
        	    break;
        	case 3:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:425:4: ( PATTERN_LITERAL value )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:425:4: ( PATTERN_LITERAL value )
        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:425:5: PATTERN_LITERAL value
        	        {
        	            PATTERN_LITERAL246 = (pANTLR3_COMMON_TOKEN) MATCHT(PATTERN_LITERAL, &FOLLOW_PATTERN_LITERAL_in_subtypeElements5336); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesubtypeElementsEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }
        	            if ( BACKTRACKING==0 ) {
        	            PATTERN_LITERAL246_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PATTERN_LITERAL246));
        	            ADAPTOR->addChild(ADAPTOR, root_0, PATTERN_LITERAL246_tree);
        	            }
        	            FOLLOWPUSH(FOLLOW_value_in_subtypeElements5338);
        	            value247=value(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesubtypeElementsEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }
        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value247.tree);

        	        }


        	    }
        	    break;
        	case 4:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:426:4: value
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_value_in_subtypeElements5344);
        	        value248=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesubtypeElementsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value248.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulesubtypeElementsEx; /* Prevent compiler warnings */
    rulesubtypeElementsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(76, subtypeElements_StartIndex); }

    return retval;
}
/* $ANTLR end subtypeElements */

/** 
 * $ANTLR start variableTypeValueSetFieldSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:430:1: variableTypeValueSetFieldSpec : AMPERSAND IDENTIFIER fieldName ( valueSetOptionalitySpec )? ;
 */
static asn1Parser_variableTypeValueSetFieldSpec_return
variableTypeValueSetFieldSpec(pasn1Parser ctx)
{   
    asn1Parser_variableTypeValueSetFieldSpec_return retval;
    ANTLR3_UINT32 variableTypeValueSetFieldSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AMPERSAND249;
    pANTLR3_COMMON_TOKEN    IDENTIFIER250;
    asn1Parser_fieldName_return fieldName251;
    #undef	RETURN_TYPE_fieldName251
    #define	RETURN_TYPE_fieldName251 asn1Parser_fieldName_return

    asn1Parser_valueSetOptionalitySpec_return valueSetOptionalitySpec252;
    #undef	RETURN_TYPE_valueSetOptionalitySpec252
    #define	RETURN_TYPE_valueSetOptionalitySpec252 asn1Parser_valueSetOptionalitySpec_return

    pANTLR3_BASE_TREE AMPERSAND249_tree;
    pANTLR3_BASE_TREE IDENTIFIER250_tree;

    /* Initialize rule variables
     */
    variableTypeValueSetFieldSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(77)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    AMPERSAND249       = NULL;
    IDENTIFIER250       = NULL;
    fieldName251.tree = NULL;

    valueSetOptionalitySpec252.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    AMPERSAND249_tree   = NULL;
    IDENTIFIER250_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:430:31: ( AMPERSAND IDENTIFIER fieldName ( valueSetOptionalitySpec )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:430:33: AMPERSAND IDENTIFIER fieldName ( valueSetOptionalitySpec )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            AMPERSAND249 = (pANTLR3_COMMON_TOKEN) MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_variableTypeValueSetFieldSpec5355); 
            if  (HASEXCEPTION())
            {
                goto rulevariableTypeValueSetFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            AMPERSAND249_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AMPERSAND249));
            ADAPTOR->addChild(ADAPTOR, root_0, AMPERSAND249_tree);
            }
            IDENTIFIER250 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_variableTypeValueSetFieldSpec5357); 
            if  (HASEXCEPTION())
            {
                goto rulevariableTypeValueSetFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER250_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER250));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER250_tree);
            }
            FOLLOWPUSH(FOLLOW_fieldName_in_variableTypeValueSetFieldSpec5362);
            fieldName251=fieldName(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevariableTypeValueSetFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fieldName251.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:430:67: ( valueSetOptionalitySpec )?
            {
                int alt95=2;
                switch ( LA(1) ) 
                {
                    case OPTIONAL_LITERAL:
                    case DEFAULT_LITERAL:
                    	{
                    		alt95=1;
                    	}
                        break;
                }

                switch (alt95) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: valueSetOptionalitySpec
            	    {
            	        FOLLOWPUSH(FOLLOW_valueSetOptionalitySpec_in_variableTypeValueSetFieldSpec5364);
            	        valueSetOptionalitySpec252=valueSetOptionalitySpec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableTypeValueSetFieldSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, valueSetOptionalitySpec252.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableTypeValueSetFieldSpecEx; /* Prevent compiler warnings */
    rulevariableTypeValueSetFieldSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(77, variableTypeValueSetFieldSpec_StartIndex); }

    return retval;
}
/* $ANTLR end variableTypeValueSetFieldSpec */

/** 
 * $ANTLR start objectFieldSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:432:1: objectFieldSpec : AMPERSAND IDENTIFIER definedObjectClass ( objectOptionalitySpec )? ;
 */
static asn1Parser_objectFieldSpec_return
objectFieldSpec(pasn1Parser ctx)
{   
    asn1Parser_objectFieldSpec_return retval;
    ANTLR3_UINT32 objectFieldSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AMPERSAND253;
    pANTLR3_COMMON_TOKEN    IDENTIFIER254;
    asn1Parser_definedObjectClass_return definedObjectClass255;
    #undef	RETURN_TYPE_definedObjectClass255
    #define	RETURN_TYPE_definedObjectClass255 asn1Parser_definedObjectClass_return

    asn1Parser_objectOptionalitySpec_return objectOptionalitySpec256;
    #undef	RETURN_TYPE_objectOptionalitySpec256
    #define	RETURN_TYPE_objectOptionalitySpec256 asn1Parser_objectOptionalitySpec_return

    pANTLR3_BASE_TREE AMPERSAND253_tree;
    pANTLR3_BASE_TREE IDENTIFIER254_tree;

    /* Initialize rule variables
     */
    objectFieldSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(78)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    AMPERSAND253       = NULL;
    IDENTIFIER254       = NULL;
    definedObjectClass255.tree = NULL;

    objectOptionalitySpec256.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    AMPERSAND253_tree   = NULL;
    IDENTIFIER254_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:432:17: ( AMPERSAND IDENTIFIER definedObjectClass ( objectOptionalitySpec )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:432:19: AMPERSAND IDENTIFIER definedObjectClass ( objectOptionalitySpec )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            AMPERSAND253 = (pANTLR3_COMMON_TOKEN) MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_objectFieldSpec5374); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            AMPERSAND253_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AMPERSAND253));
            ADAPTOR->addChild(ADAPTOR, root_0, AMPERSAND253_tree);
            }
            IDENTIFIER254 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_objectFieldSpec5376); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER254_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER254));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER254_tree);
            }
            FOLLOWPUSH(FOLLOW_definedObjectClass_in_objectFieldSpec5378);
            definedObjectClass255=definedObjectClass(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobjectFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedObjectClass255.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:432:59: ( objectOptionalitySpec )?
            {
                int alt96=2;
                switch ( LA(1) ) 
                {
                    case OPTIONAL_LITERAL:
                    case DEFAULT_LITERAL:
                    	{
                    		alt96=1;
                    	}
                        break;
                }

                switch (alt96) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: objectOptionalitySpec
            	    {
            	        FOLLOWPUSH(FOLLOW_objectOptionalitySpec_in_objectFieldSpec5380);
            	        objectOptionalitySpec256=objectOptionalitySpec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobjectFieldSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectOptionalitySpec256.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectFieldSpecEx; /* Prevent compiler warnings */
    ruleobjectFieldSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(78, objectFieldSpec_StartIndex); }

    return retval;
}
/* $ANTLR end objectFieldSpec */

/** 
 * $ANTLR start objectOptionalitySpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:434:1: objectOptionalitySpec : ( OPTIONAL_LITERAL | DEFAULT_LITERAL object );
 */
static asn1Parser_objectOptionalitySpec_return
objectOptionalitySpec(pasn1Parser ctx)
{   
    asn1Parser_objectOptionalitySpec_return retval;
    ANTLR3_UINT32 objectOptionalitySpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OPTIONAL_LITERAL257;
    pANTLR3_COMMON_TOKEN    DEFAULT_LITERAL258;
    asn1Parser_object_return object259;
    #undef	RETURN_TYPE_object259
    #define	RETURN_TYPE_object259 asn1Parser_object_return

    pANTLR3_BASE_TREE OPTIONAL_LITERAL257_tree;
    pANTLR3_BASE_TREE DEFAULT_LITERAL258_tree;

    /* Initialize rule variables
     */
    objectOptionalitySpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(79)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    OPTIONAL_LITERAL257       = NULL;
    DEFAULT_LITERAL258       = NULL;
    object259.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    OPTIONAL_LITERAL257_tree   = NULL;
    DEFAULT_LITERAL258_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:434:23: ( OPTIONAL_LITERAL | DEFAULT_LITERAL object )
            
            ANTLR3_UINT32 alt97;

            alt97=2;

            switch ( LA(1) ) 
            {
            case OPTIONAL_LITERAL:
            	{
            		alt97=1;
            	}
                break;
            case DEFAULT_LITERAL:
            	{
            		alt97=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 97;
                EXCEPTION->state        = 0;


                goto ruleobjectOptionalitySpecEx;
            }

            switch (alt97) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:434:25: OPTIONAL_LITERAL
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        OPTIONAL_LITERAL257 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTIONAL_LITERAL, &FOLLOW_OPTIONAL_LITERAL_in_objectOptionalitySpec5390); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectOptionalitySpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        OPTIONAL_LITERAL257_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OPTIONAL_LITERAL257));
        	        ADAPTOR->addChild(ADAPTOR, root_0, OPTIONAL_LITERAL257_tree);
        	        }

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:434:44: DEFAULT_LITERAL object
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        DEFAULT_LITERAL258 = (pANTLR3_COMMON_TOKEN) MATCHT(DEFAULT_LITERAL, &FOLLOW_DEFAULT_LITERAL_in_objectOptionalitySpec5394); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectOptionalitySpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        DEFAULT_LITERAL258_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DEFAULT_LITERAL258));
        	        ADAPTOR->addChild(ADAPTOR, root_0, DEFAULT_LITERAL258_tree);
        	        }
        	        FOLLOWPUSH(FOLLOW_object_in_objectOptionalitySpec5396);
        	        object259=object(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectOptionalitySpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, object259.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectOptionalitySpecEx; /* Prevent compiler warnings */
    ruleobjectOptionalitySpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(79, objectOptionalitySpec_StartIndex); }

    return retval;
}
/* $ANTLR end objectOptionalitySpec */

/** 
 * $ANTLR start objectSetFieldSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:436:1: objectSetFieldSpec : AMPERSAND IDENTIFIER definedObjectClass ( objectSetOptionalitySpec )? ;
 */
static asn1Parser_objectSetFieldSpec_return
objectSetFieldSpec(pasn1Parser ctx)
{   
    asn1Parser_objectSetFieldSpec_return retval;
    ANTLR3_UINT32 objectSetFieldSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AMPERSAND260;
    pANTLR3_COMMON_TOKEN    IDENTIFIER261;
    asn1Parser_definedObjectClass_return definedObjectClass262;
    #undef	RETURN_TYPE_definedObjectClass262
    #define	RETURN_TYPE_definedObjectClass262 asn1Parser_definedObjectClass_return

    asn1Parser_objectSetOptionalitySpec_return objectSetOptionalitySpec263;
    #undef	RETURN_TYPE_objectSetOptionalitySpec263
    #define	RETURN_TYPE_objectSetOptionalitySpec263 asn1Parser_objectSetOptionalitySpec_return

    pANTLR3_BASE_TREE AMPERSAND260_tree;
    pANTLR3_BASE_TREE IDENTIFIER261_tree;

    /* Initialize rule variables
     */
    objectSetFieldSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(80)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    AMPERSAND260       = NULL;
    IDENTIFIER261       = NULL;
    definedObjectClass262.tree = NULL;

    objectSetOptionalitySpec263.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    AMPERSAND260_tree   = NULL;
    IDENTIFIER261_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:436:20: ( AMPERSAND IDENTIFIER definedObjectClass ( objectSetOptionalitySpec )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:436:22: AMPERSAND IDENTIFIER definedObjectClass ( objectSetOptionalitySpec )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            AMPERSAND260 = (pANTLR3_COMMON_TOKEN) MATCHT(AMPERSAND, &FOLLOW_AMPERSAND_in_objectSetFieldSpec5405); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectSetFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            AMPERSAND260_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AMPERSAND260));
            ADAPTOR->addChild(ADAPTOR, root_0, AMPERSAND260_tree);
            }
            IDENTIFIER261 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_objectSetFieldSpec5407); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectSetFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER261_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER261));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER261_tree);
            }
            FOLLOWPUSH(FOLLOW_definedObjectClass_in_objectSetFieldSpec5409);
            definedObjectClass262=definedObjectClass(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobjectSetFieldSpecEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedObjectClass262.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:436:62: ( objectSetOptionalitySpec )?
            {
                int alt98=2;
                switch ( LA(1) ) 
                {
                    case OPTIONAL_LITERAL:
                    case DEFAULT_LITERAL:
                    	{
                    		alt98=1;
                    	}
                        break;
                }

                switch (alt98) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: objectSetOptionalitySpec
            	    {
            	        FOLLOWPUSH(FOLLOW_objectSetOptionalitySpec_in_objectSetFieldSpec5411);
            	        objectSetOptionalitySpec263=objectSetOptionalitySpec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobjectSetFieldSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectSetOptionalitySpec263.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectSetFieldSpecEx; /* Prevent compiler warnings */
    ruleobjectSetFieldSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(80, objectSetFieldSpec_StartIndex); }

    return retval;
}
/* $ANTLR end objectSetFieldSpec */

/** 
 * $ANTLR start objectSetOptionalitySpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:438:1: objectSetOptionalitySpec : ( OPTIONAL_LITERAL | DEFAULT_LITERAL objectSet );
 */
static asn1Parser_objectSetOptionalitySpec_return
objectSetOptionalitySpec(pasn1Parser ctx)
{   
    asn1Parser_objectSetOptionalitySpec_return retval;
    ANTLR3_UINT32 objectSetOptionalitySpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OPTIONAL_LITERAL264;
    pANTLR3_COMMON_TOKEN    DEFAULT_LITERAL265;
    asn1Parser_objectSet_return objectSet266;
    #undef	RETURN_TYPE_objectSet266
    #define	RETURN_TYPE_objectSet266 asn1Parser_objectSet_return

    pANTLR3_BASE_TREE OPTIONAL_LITERAL264_tree;
    pANTLR3_BASE_TREE DEFAULT_LITERAL265_tree;

    /* Initialize rule variables
     */
    objectSetOptionalitySpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(81)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    OPTIONAL_LITERAL264       = NULL;
    DEFAULT_LITERAL265       = NULL;
    objectSet266.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    OPTIONAL_LITERAL264_tree   = NULL;
    DEFAULT_LITERAL265_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:438:26: ( OPTIONAL_LITERAL | DEFAULT_LITERAL objectSet )
            
            ANTLR3_UINT32 alt99;

            alt99=2;

            switch ( LA(1) ) 
            {
            case OPTIONAL_LITERAL:
            	{
            		alt99=1;
            	}
                break;
            case DEFAULT_LITERAL:
            	{
            		alt99=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 99;
                EXCEPTION->state        = 0;


                goto ruleobjectSetOptionalitySpecEx;
            }

            switch (alt99) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:438:28: OPTIONAL_LITERAL
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        OPTIONAL_LITERAL264 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTIONAL_LITERAL, &FOLLOW_OPTIONAL_LITERAL_in_objectSetOptionalitySpec5422); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectSetOptionalitySpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        OPTIONAL_LITERAL264_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OPTIONAL_LITERAL264));
        	        ADAPTOR->addChild(ADAPTOR, root_0, OPTIONAL_LITERAL264_tree);
        	        }

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:438:47: DEFAULT_LITERAL objectSet
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        DEFAULT_LITERAL265 = (pANTLR3_COMMON_TOKEN) MATCHT(DEFAULT_LITERAL, &FOLLOW_DEFAULT_LITERAL_in_objectSetOptionalitySpec5426); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectSetOptionalitySpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        DEFAULT_LITERAL265_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DEFAULT_LITERAL265));
        	        ADAPTOR->addChild(ADAPTOR, root_0, DEFAULT_LITERAL265_tree);
        	        }
        	        FOLLOWPUSH(FOLLOW_objectSet_in_objectSetOptionalitySpec5428);
        	        objectSet266=objectSet(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjectSetOptionalitySpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectSet266.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectSetOptionalitySpecEx; /* Prevent compiler warnings */
    ruleobjectSetOptionalitySpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(81, objectSetOptionalitySpec_StartIndex); }

    return retval;
}
/* $ANTLR end objectSetOptionalitySpec */

/** 
 * $ANTLR start typeAssignment
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:441:1: typeAssignment : ASSIGN_OP type ;
 */
static asn1Parser_typeAssignment_return
typeAssignment(pasn1Parser ctx)
{   
    asn1Parser_typeAssignment_return retval;
    ANTLR3_UINT32 typeAssignment_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ASSIGN_OP267;
    asn1Parser_type_return type268;
    #undef	RETURN_TYPE_type268
    #define	RETURN_TYPE_type268 asn1Parser_type_return

    pANTLR3_BASE_TREE ASSIGN_OP267_tree;

    /* Initialize rule variables
     */
    typeAssignment_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(82)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    ASSIGN_OP267       = NULL;
    type268.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    ASSIGN_OP267_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:441:16: ( ASSIGN_OP type )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:442:7: ASSIGN_OP type
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            ASSIGN_OP267 = (pANTLR3_COMMON_TOKEN) MATCHT(ASSIGN_OP, &FOLLOW_ASSIGN_OP_in_typeAssignment5446); 
            if  (HASEXCEPTION())
            {
                goto ruletypeAssignmentEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_type_in_typeAssignment5455);
            type268=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletypeAssignmentEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type268.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletypeAssignmentEx; /* Prevent compiler warnings */
    ruletypeAssignmentEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(82, typeAssignment_StartIndex); }

    return retval;
}
/* $ANTLR end typeAssignment */

/** 
 * $ANTLR start valueAssignment
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:447:1: valueAssignment : type ASSIGN_OP value -> ^( type value ) ;
 */
static asn1Parser_valueAssignment_return
valueAssignment(pasn1Parser ctx)
{   
    asn1Parser_valueAssignment_return retval;
    ANTLR3_UINT32 valueAssignment_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ASSIGN_OP270;
    asn1Parser_type_return type269;
    #undef	RETURN_TYPE_type269
    #define	RETURN_TYPE_type269 asn1Parser_type_return

    asn1Parser_value_return value271;
    #undef	RETURN_TYPE_value271
    #define	RETURN_TYPE_value271 asn1Parser_value_return

    pANTLR3_BASE_TREE ASSIGN_OP270_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ASSIGN_OP;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_value;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_type;
    /* Initialize rule variables
     */
    valueAssignment_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(83)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    ASSIGN_OP270       = NULL;
    type269.tree = NULL;

    value271.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    ASSIGN_OP270_tree   = NULL;

    stream_ASSIGN_OP   = NULL;
    #define CREATE_stream_ASSIGN_OP  if (stream_ASSIGN_OP == NULL) {stream_ASSIGN_OP = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ASSIGN_OP"); } 
    stream_value   = NULL;
    #define CREATE_stream_value  if (stream_value == NULL) {stream_value = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule value"); }
    stream_type   = NULL;
    #define CREATE_stream_type  if (stream_type == NULL) {stream_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule type"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:447:17: ( type ASSIGN_OP value -> ^( type value ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:449:7: type ASSIGN_OP value
        {
            FOLLOWPUSH(FOLLOW_type_in_valueAssignment5482);
            type269=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevalueAssignmentEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_type; stream_type->add(stream_type, type269.tree, NULL); }
            ASSIGN_OP270 = (pANTLR3_COMMON_TOKEN) MATCHT(ASSIGN_OP, &FOLLOW_ASSIGN_OP_in_valueAssignment5492); 
            if  (HASEXCEPTION())
            {
                goto rulevalueAssignmentEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_ASSIGN_OP; stream_ASSIGN_OP->add(stream_ASSIGN_OP, ASSIGN_OP270, NULL); }

            FOLLOWPUSH(FOLLOW_value_in_valueAssignment5502);
            value271=value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevalueAssignmentEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_value; stream_value->add(stream_value, value271.tree, NULL); }

             
            /* AST REWRITE
             * elements          : type, value
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 452:8: -> ^( type value )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:452:11: ^( type value )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_type == NULL ? NULL : stream_type->nextNode(stream_type), root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_value == NULL ? NULL : stream_value->nextTree(stream_value));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevalueAssignmentEx; /* Prevent compiler warnings */
    rulevalueAssignmentEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_ASSIGN_OP != NULL) stream_ASSIGN_OP->free(stream_ASSIGN_OP);
        if (stream_value != NULL) stream_value->free(stream_value);
        if (stream_type != NULL) stream_type->free(stream_type);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(83, valueAssignment_StartIndex); }

    return retval;
}
/* $ANTLR end valueAssignment */

/** 
 * $ANTLR start extraTagDescriptors
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:454:1: extraTagDescriptors : ( L_BRACKET (id= UNIVERSAL_LITERAL | id= APPLICATION_LITERAL | id= PRIVATE_LITERAL )* num= NUMBER R_BRACKET ) (im= IMPLICIT_LITERAL )* (ex= EXPLICIT_LITERAL )* -> ^( TAG_DESCRIPTOR ( $id)? ( $im)? ( $ex)? $num) ;
 */
static asn1Parser_extraTagDescriptors_return
extraTagDescriptors(pasn1Parser ctx)
{   
    asn1Parser_extraTagDescriptors_return retval;
    ANTLR3_UINT32 extraTagDescriptors_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    id;
    pANTLR3_COMMON_TOKEN    num;
    pANTLR3_COMMON_TOKEN    im;
    pANTLR3_COMMON_TOKEN    ex;
    pANTLR3_COMMON_TOKEN    L_BRACKET272;
    pANTLR3_COMMON_TOKEN    R_BRACKET273;

    pANTLR3_BASE_TREE id_tree;
    pANTLR3_BASE_TREE num_tree;
    pANTLR3_BASE_TREE im_tree;
    pANTLR3_BASE_TREE ex_tree;
    pANTLR3_BASE_TREE L_BRACKET272_tree;
    pANTLR3_BASE_TREE R_BRACKET273_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_PRIVATE_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_BRACKET;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_EXPLICIT_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IMPLICIT_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_BRACKET;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_APPLICATION_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_UNIVERSAL_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NUMBER;

    /* Initialize rule variables
     */
    extraTagDescriptors_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(84)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    id       = NULL;
    num       = NULL;
    im       = NULL;
    ex       = NULL;
    L_BRACKET272       = NULL;
    R_BRACKET273       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    id_tree   = NULL;
    num_tree   = NULL;
    im_tree   = NULL;
    ex_tree   = NULL;
    L_BRACKET272_tree   = NULL;
    R_BRACKET273_tree   = NULL;

    stream_PRIVATE_LITERAL   = NULL;
    #define CREATE_stream_PRIVATE_LITERAL  if (stream_PRIVATE_LITERAL == NULL) {stream_PRIVATE_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token PRIVATE_LITERAL"); } 
    stream_L_BRACKET   = NULL;
    #define CREATE_stream_L_BRACKET  if (stream_L_BRACKET == NULL) {stream_L_BRACKET = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_BRACKET"); } 
    stream_EXPLICIT_LITERAL   = NULL;
    #define CREATE_stream_EXPLICIT_LITERAL  if (stream_EXPLICIT_LITERAL == NULL) {stream_EXPLICIT_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token EXPLICIT_LITERAL"); } 
    stream_IMPLICIT_LITERAL   = NULL;
    #define CREATE_stream_IMPLICIT_LITERAL  if (stream_IMPLICIT_LITERAL == NULL) {stream_IMPLICIT_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IMPLICIT_LITERAL"); } 
    stream_R_BRACKET   = NULL;
    #define CREATE_stream_R_BRACKET  if (stream_R_BRACKET == NULL) {stream_R_BRACKET = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_BRACKET"); } 
    stream_APPLICATION_LITERAL   = NULL;
    #define CREATE_stream_APPLICATION_LITERAL  if (stream_APPLICATION_LITERAL == NULL) {stream_APPLICATION_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token APPLICATION_LITERAL"); } 
    stream_UNIVERSAL_LITERAL   = NULL;
    #define CREATE_stream_UNIVERSAL_LITERAL  if (stream_UNIVERSAL_LITERAL == NULL) {stream_UNIVERSAL_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token UNIVERSAL_LITERAL"); } 
    stream_NUMBER   = NULL;
    #define CREATE_stream_NUMBER  if (stream_NUMBER == NULL) {stream_NUMBER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token NUMBER"); } 

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:455:2: ( ( L_BRACKET (id= UNIVERSAL_LITERAL | id= APPLICATION_LITERAL | id= PRIVATE_LITERAL )* num= NUMBER R_BRACKET ) (im= IMPLICIT_LITERAL )* (ex= EXPLICIT_LITERAL )* -> ^( TAG_DESCRIPTOR ( $id)? ( $im)? ( $ex)? $num) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:455:4: ( L_BRACKET (id= UNIVERSAL_LITERAL | id= APPLICATION_LITERAL | id= PRIVATE_LITERAL )* num= NUMBER R_BRACKET ) (im= IMPLICIT_LITERAL )* (ex= EXPLICIT_LITERAL )*
        {
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:455:4: ( L_BRACKET (id= UNIVERSAL_LITERAL | id= APPLICATION_LITERAL | id= PRIVATE_LITERAL )* num= NUMBER R_BRACKET )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:455:5: L_BRACKET (id= UNIVERSAL_LITERAL | id= APPLICATION_LITERAL | id= PRIVATE_LITERAL )* num= NUMBER R_BRACKET
            {
                L_BRACKET272 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACKET, &FOLLOW_L_BRACKET_in_extraTagDescriptors5528); 
                if  (HASEXCEPTION())
                {
                    goto ruleextraTagDescriptorsEx;
                }
                if (HASFAILED())
                {
                    return retval;
                } 
                if ( BACKTRACKING==0 ) { CREATE_stream_L_BRACKET; stream_L_BRACKET->add(stream_L_BRACKET, L_BRACKET272, NULL); }


                // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:455:15: (id= UNIVERSAL_LITERAL | id= APPLICATION_LITERAL | id= PRIVATE_LITERAL )*

                for (;;)
                {
                    int alt100=4;
                    switch ( LA(1) ) 
                    {
                    case UNIVERSAL_LITERAL:
                    	{
                    		alt100=1;
                    	}
                        break;
                    case APPLICATION_LITERAL:
                    	{
                    		alt100=2;
                    	}
                        break;
                    case PRIVATE_LITERAL:
                    	{
                    		alt100=3;
                    	}
                        break;

                    }

                    switch (alt100) 
                    {
                	case 1:
                	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:455:16: id= UNIVERSAL_LITERAL
                	    {
                	        id = (pANTLR3_COMMON_TOKEN) MATCHT(UNIVERSAL_LITERAL, &FOLLOW_UNIVERSAL_LITERAL_in_extraTagDescriptors5533); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleextraTagDescriptorsEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        } 
                	        if ( BACKTRACKING==0 ) { CREATE_stream_UNIVERSAL_LITERAL; stream_UNIVERSAL_LITERAL->add(stream_UNIVERSAL_LITERAL, id, NULL); }


                	    }
                	    break;
                	case 2:
                	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:455:39: id= APPLICATION_LITERAL
                	    {
                	        id = (pANTLR3_COMMON_TOKEN) MATCHT(APPLICATION_LITERAL, &FOLLOW_APPLICATION_LITERAL_in_extraTagDescriptors5539); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleextraTagDescriptorsEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        } 
                	        if ( BACKTRACKING==0 ) { CREATE_stream_APPLICATION_LITERAL; stream_APPLICATION_LITERAL->add(stream_APPLICATION_LITERAL, id, NULL); }


                	    }
                	    break;
                	case 3:
                	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:455:64: id= PRIVATE_LITERAL
                	    {
                	        id = (pANTLR3_COMMON_TOKEN) MATCHT(PRIVATE_LITERAL, &FOLLOW_PRIVATE_LITERAL_in_extraTagDescriptors5545); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleextraTagDescriptorsEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        } 
                	        if ( BACKTRACKING==0 ) { CREATE_stream_PRIVATE_LITERAL; stream_PRIVATE_LITERAL->add(stream_PRIVATE_LITERAL, id, NULL); }


                	    }
                	    break;

                	default:
                	    goto loop100;	/* break out of the loop */
                	    break;
                    }
                }
                loop100: ; /* Jump out to here if this rule does not match */

                num = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_extraTagDescriptors5551); 
                if  (HASEXCEPTION())
                {
                    goto ruleextraTagDescriptorsEx;
                }
                if (HASFAILED())
                {
                    return retval;
                } 
                if ( BACKTRACKING==0 ) { CREATE_stream_NUMBER; stream_NUMBER->add(stream_NUMBER, num, NULL); }

                R_BRACKET273 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACKET, &FOLLOW_R_BRACKET_in_extraTagDescriptors5553); 
                if  (HASEXCEPTION())
                {
                    goto ruleextraTagDescriptorsEx;
                }
                if (HASFAILED())
                {
                    return retval;
                } 
                if ( BACKTRACKING==0 ) { CREATE_stream_R_BRACKET; stream_R_BRACKET->add(stream_R_BRACKET, R_BRACKET273, NULL); }


            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:455:109: (im= IMPLICIT_LITERAL )*

            for (;;)
            {
                int alt101=2;
                switch ( LA(1) ) 
                {
                case IMPLICIT_LITERAL:
                	{
                		alt101=1;
                	}
                    break;

                }

                switch (alt101) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: im= IMPLICIT_LITERAL
            	    {
            	        im = (pANTLR3_COMMON_TOKEN) MATCHT(IMPLICIT_LITERAL, &FOLLOW_IMPLICIT_LITERAL_in_extraTagDescriptors5558); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextraTagDescriptorsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_IMPLICIT_LITERAL; stream_IMPLICIT_LITERAL->add(stream_IMPLICIT_LITERAL, im, NULL); }


            	    }
            	    break;

            	default:
            	    goto loop101;	/* break out of the loop */
            	    break;
                }
            }
            loop101: ; /* Jump out to here if this rule does not match */


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:455:130: (ex= EXPLICIT_LITERAL )*

            for (;;)
            {
                int alt102=2;
                switch ( LA(1) ) 
                {
                case EXPLICIT_LITERAL:
                	{
                		alt102=1;
                	}
                    break;

                }

                switch (alt102) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: ex= EXPLICIT_LITERAL
            	    {
            	        ex = (pANTLR3_COMMON_TOKEN) MATCHT(EXPLICIT_LITERAL, &FOLLOW_EXPLICIT_LITERAL_in_extraTagDescriptors5563); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextraTagDescriptorsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_EXPLICIT_LITERAL; stream_EXPLICIT_LITERAL->add(stream_EXPLICIT_LITERAL, ex, NULL); }


            	    }
            	    break;

            	default:
            	    goto loop102;	/* break out of the loop */
            	    break;
                }
            }
            loop102: ; /* Jump out to here if this rule does not match */


             
            /* AST REWRITE
             * elements          : num, ex, im, id
             * token labels      : id, ex, num, im
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_id;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ex;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_num;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_im;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_id=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token id", id);
            	stream_ex=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token ex", ex);
            	stream_num=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token num", num);
            	stream_im=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token im", im);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 456:2: -> ^( TAG_DESCRIPTOR ( $id)? ( $im)? ( $ex)? $num)
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:456:5: ^( TAG_DESCRIPTOR ( $id)? ( $im)? ( $ex)? $num)
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TAG_DESCRIPTOR, (pANTLR3_UINT8)"TAG_DESCRIPTOR"), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:456:22: ( $id)?
            	        {
            	        	if ( (stream_id != NULL && stream_id->hasNext(stream_id))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_id == NULL ? NULL : stream_id->nextNode(stream_id));

            	        	}
            	        	if ( stream_id != NULL) stream_id->reset(stream_id);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:456:27: ( $im)?
            	        {
            	        	if ( (stream_im != NULL && stream_im->hasNext(stream_im))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_im == NULL ? NULL : stream_im->nextNode(stream_im));

            	        	}
            	        	if ( stream_im != NULL) stream_im->reset(stream_im);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:456:32: ( $ex)?
            	        {
            	        	if ( (stream_ex != NULL && stream_ex->hasNext(stream_ex))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_ex == NULL ? NULL : stream_ex->nextNode(stream_ex));

            	        	}
            	        	if ( stream_ex != NULL) stream_ex->reset(stream_ex);

            	        }
            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_num == NULL ? NULL : stream_num->nextNode(stream_num));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_id != NULL) stream_id->free(stream_id); 
            	if (stream_ex != NULL) stream_ex->free(stream_ex); 
            	if (stream_num != NULL) stream_num->free(stream_num); 
            	if (stream_im != NULL) stream_im->free(stream_im); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextraTagDescriptorsEx; /* Prevent compiler warnings */
    ruleextraTagDescriptorsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_PRIVATE_LITERAL != NULL) stream_PRIVATE_LITERAL->free(stream_PRIVATE_LITERAL);
        if (stream_L_BRACKET != NULL) stream_L_BRACKET->free(stream_L_BRACKET);
        if (stream_EXPLICIT_LITERAL != NULL) stream_EXPLICIT_LITERAL->free(stream_EXPLICIT_LITERAL);
        if (stream_IMPLICIT_LITERAL != NULL) stream_IMPLICIT_LITERAL->free(stream_IMPLICIT_LITERAL);
        if (stream_R_BRACKET != NULL) stream_R_BRACKET->free(stream_R_BRACKET);
        if (stream_APPLICATION_LITERAL != NULL) stream_APPLICATION_LITERAL->free(stream_APPLICATION_LITERAL);
        if (stream_UNIVERSAL_LITERAL != NULL) stream_UNIVERSAL_LITERAL->free(stream_UNIVERSAL_LITERAL);
        if (stream_NUMBER != NULL) stream_NUMBER->free(stream_NUMBER);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(84, extraTagDescriptors_StartIndex); }

    return retval;
}
/* $ANTLR end extraTagDescriptors */

/** 
 * $ANTLR start type
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:459:1: type : (et= extraTagDescriptors )* (tp= builtinType | tp2= referencedType ) -> ^( NODE_INFO ( $et)? ( $tp)? ( $tp2)? ) ;
 */
static asn1Parser_type_return
type(pasn1Parser ctx)
{   
    asn1Parser_type_return retval;
    ANTLR3_UINT32 type_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_extraTagDescriptors_return et;
    #undef	RETURN_TYPE_et
    #define	RETURN_TYPE_et asn1Parser_extraTagDescriptors_return

    asn1Parser_builtinType_return tp;
    #undef	RETURN_TYPE_tp
    #define	RETURN_TYPE_tp asn1Parser_builtinType_return

    asn1Parser_referencedType_return tp2;
    #undef	RETURN_TYPE_tp2
    #define	RETURN_TYPE_tp2 asn1Parser_referencedType_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_extraTagDescriptors;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_builtinType;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_referencedType;
    /* Initialize rule variables
     */
    type_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(85)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    et.tree = NULL;

    tp.tree = NULL;

    tp2.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_extraTagDescriptors   = NULL;
    #define CREATE_stream_extraTagDescriptors  if (stream_extraTagDescriptors == NULL) {stream_extraTagDescriptors = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule extraTagDescriptors"); }
    stream_builtinType   = NULL;
    #define CREATE_stream_builtinType  if (stream_builtinType == NULL) {stream_builtinType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule builtinType"); }
    stream_referencedType   = NULL;
    #define CREATE_stream_referencedType  if (stream_referencedType == NULL) {stream_referencedType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule referencedType"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:459:6: ( (et= extraTagDescriptors )* (tp= builtinType | tp2= referencedType ) -> ^( NODE_INFO ( $et)? ( $tp)? ( $tp2)? ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:459:8: (et= extraTagDescriptors )* (tp= builtinType | tp2= referencedType )
        {

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:459:10: (et= extraTagDescriptors )*

            for (;;)
            {
                int alt103=2;
                switch ( LA(1) ) 
                {
                case L_BRACKET:
                	{
                		alt103=1;
                	}
                    break;

                }

                switch (alt103) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: et= extraTagDescriptors
            	    {
            	        FOLLOWPUSH(FOLLOW_extraTagDescriptors_in_type5599);
            	        et=extraTagDescriptors(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_extraTagDescriptors; stream_extraTagDescriptors->add(stream_extraTagDescriptors, et.tree, NULL); }

            	    }
            	    break;

            	default:
            	    goto loop103;	/* break out of the loop */
            	    break;
                }
            }
            loop103: ; /* Jump out to here if this rule does not match */


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:459:32: (tp= builtinType | tp2= referencedType )
            {
                int alt104=2;
                switch ( LA(1) ) 
                {
                case BOOLEAN_LITERAL:
                case INTEGER_LITERAL:
                case IA5_STRING_LITERAL:
                case ENUMERATED_LITERAL:
                case BIT_LITERAL:
                case OCTET_LITERAL:
                case NULL_LITERAL:
                case SEQUENCE_LITERAL:
                case SET_LITERAL:
                case TYPE_IDENTIFIER_LITERAL:
                case ABSTRACT_SYNTAX_LITERAL:
                case CHOICE_LITERAL:
                case OBJECT_LITERAL:
                	{
                		alt104=1;
                	}
                    break;
                case IDENTIFIER:
                	{
                		switch ( LA(2) ) 
                		{
                		case DOT:
                			{
                				switch ( LA(3) ) 
                				{
                				case IDENTIFIER:
                					{
                						switch ( LA(4) ) 
                						{
                						case DOT:
                						case L_PARAN:
                							{
                								alt104=1;
                							}
                						    break;
                						case EOF:
                						case ASSIGN_OP:
                						case L_BRACE:
                						case R_BRACE:
                						case COMMA:
                						case R_PARAN:
                						case OPTIONAL_LITERAL:
                						case DEFAULT_LITERAL:
                						case OF_LITERAL:
                						case EXCLAM:
                						case EXCEPT_LITERAL:
                						case POWER:
                						case PIPE:
                						case UNION_LITERAL:
                						case INTERSECTION_LITERAL:
                						case UNIQUE_LITERAL:
                						case END_LITERAL:
                						case DOUBLE_R_BRACKET:
                						case COLON:
                						case ENCODED_LITERAL:
                						case IDENTIFIER:
                						case EXTENSTIONENDMARKER:
                							{
                								alt104=2;
                							}
                						    break;

                						default:
                						    if (BACKTRACKING>0)
                						    {
                						        FAILEDFLAG = ANTLR3_TRUE;
                						        return retval;
                						    }
                						    CONSTRUCTEX();
                						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                						    EXCEPTION->message      = (void *)"";
                						    EXCEPTION->decisionNum  = 104;
                						    EXCEPTION->state        = 5;


                						    goto ruletypeEx;
                						}

                					}
                				    break;
                				case AMPERSAND:
                					{
                						alt104=1;
                					}
                				    break;

                				default:
                				    if (BACKTRACKING>0)
                				    {
                				        FAILEDFLAG = ANTLR3_TRUE;
                				        return retval;
                				    }
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 104;
                				    EXCEPTION->state        = 3;


                				    goto ruletypeEx;
                				}

                			}
                		    break;
                		case EOF:
                		case ASSIGN_OP:
                		case L_BRACE:
                		case R_BRACE:
                		case COMMA:
                		case R_PARAN:
                		case OPTIONAL_LITERAL:
                		case DEFAULT_LITERAL:
                		case OF_LITERAL:
                		case EXCLAM:
                		case EXCEPT_LITERAL:
                		case POWER:
                		case PIPE:
                		case UNION_LITERAL:
                		case INTERSECTION_LITERAL:
                		case UNIQUE_LITERAL:
                		case END_LITERAL:
                		case DOUBLE_R_BRACKET:
                		case COLON:
                		case ENCODED_LITERAL:
                		case IDENTIFIER:
                		case EXTENSTIONENDMARKER:
                			{
                				alt104=2;
                			}
                		    break;
                		case L_PARAN:
                			{
                				alt104=1;
                			}
                		    break;

                		default:
                		    if (BACKTRACKING>0)
                		    {
                		        FAILEDFLAG = ANTLR3_TRUE;
                		        return retval;
                		    }
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 104;
                		    EXCEPTION->state        = 2;


                		    goto ruletypeEx;
                		}

                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 104;
                    EXCEPTION->state        = 0;


                    goto ruletypeEx;
                }

                switch (alt104) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:459:33: tp= builtinType
            	    {
            	        FOLLOWPUSH(FOLLOW_builtinType_in_type5605);
            	        tp=builtinType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_builtinType; stream_builtinType->add(stream_builtinType, tp.tree, NULL); }

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:459:50: tp2= referencedType
            	    {
            	        FOLLOWPUSH(FOLLOW_referencedType_in_type5611);
            	        tp2=referencedType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_referencedType; stream_referencedType->add(stream_referencedType, tp2.tree, NULL); }

            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : tp2, tp, et
             * token labels      : 
             * rule labels       : retval, tp, tp2, et
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_tp;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_tp2;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_et;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_tp=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token tp", tp.tree != NULL ? tp.tree : NULL);
            	stream_tp2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token tp2", tp2.tree != NULL ? tp2.tree : NULL);
            	stream_et=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token et", et.tree != NULL ? et.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 460:1: -> ^( NODE_INFO ( $et)? ( $tp)? ( $tp2)? )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:460:4: ^( NODE_INFO ( $et)? ( $tp)? ( $tp2)? )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NODE_INFO, (pANTLR3_UINT8)"NODE_INFO"), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:460:16: ( $et)?
            	        {
            	        	if ( (stream_et != NULL && stream_et->hasNext(stream_et))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_et == NULL ? NULL : stream_et->nextTree(stream_et));

            	        	}
            	        	if ( stream_et != NULL) stream_et->reset(stream_et);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:460:21: ( $tp)?
            	        {
            	        	if ( (stream_tp != NULL && stream_tp->hasNext(stream_tp))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_tp == NULL ? NULL : stream_tp->nextTree(stream_tp));

            	        	}
            	        	if ( stream_tp != NULL) stream_tp->reset(stream_tp);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:460:26: ( $tp2)?
            	        {
            	        	if ( (stream_tp2 != NULL && stream_tp2->hasNext(stream_tp2))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_tp2 == NULL ? NULL : stream_tp2->nextTree(stream_tp2));

            	        	}
            	        	if ( stream_tp2 != NULL) stream_tp2->reset(stream_tp2);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_tp != NULL) stream_tp->free(stream_tp);
            	if (stream_tp2 != NULL) stream_tp2->free(stream_tp2);
            	if (stream_et != NULL) stream_et->free(stream_et);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletypeEx; /* Prevent compiler warnings */
    ruletypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_extraTagDescriptors != NULL) stream_extraTagDescriptors->free(stream_extraTagDescriptors);
        if (stream_builtinType != NULL) stream_builtinType->free(stream_builtinType);
        if (stream_referencedType != NULL) stream_referencedType->free(stream_referencedType);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(85, type_StartIndex); }

    return retval;
}
/* $ANTLR end type */

/** 
 * $ANTLR start builtinType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:462:1: builtinType : ( octetStringType | ia5stringType | booleanType | nullType | bitStringType | choiceType | enumeratedType | integerType | sequenceType | sequenceOfType | setType | setOfType | objectidentifiertype | objectClassFieldType );
 */
static asn1Parser_builtinType_return
builtinType(pasn1Parser ctx)
{   
    asn1Parser_builtinType_return retval;
    ANTLR3_UINT32 builtinType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_octetStringType_return octetStringType274;
    #undef	RETURN_TYPE_octetStringType274
    #define	RETURN_TYPE_octetStringType274 asn1Parser_octetStringType_return

    asn1Parser_ia5stringType_return ia5stringType275;
    #undef	RETURN_TYPE_ia5stringType275
    #define	RETURN_TYPE_ia5stringType275 asn1Parser_ia5stringType_return

    asn1Parser_booleanType_return booleanType276;
    #undef	RETURN_TYPE_booleanType276
    #define	RETURN_TYPE_booleanType276 asn1Parser_booleanType_return

    asn1Parser_nullType_return nullType277;
    #undef	RETURN_TYPE_nullType277
    #define	RETURN_TYPE_nullType277 asn1Parser_nullType_return

    asn1Parser_bitStringType_return bitStringType278;
    #undef	RETURN_TYPE_bitStringType278
    #define	RETURN_TYPE_bitStringType278 asn1Parser_bitStringType_return

    asn1Parser_choiceType_return choiceType279;
    #undef	RETURN_TYPE_choiceType279
    #define	RETURN_TYPE_choiceType279 asn1Parser_choiceType_return

    asn1Parser_enumeratedType_return enumeratedType280;
    #undef	RETURN_TYPE_enumeratedType280
    #define	RETURN_TYPE_enumeratedType280 asn1Parser_enumeratedType_return

    asn1Parser_integerType_return integerType281;
    #undef	RETURN_TYPE_integerType281
    #define	RETURN_TYPE_integerType281 asn1Parser_integerType_return

    asn1Parser_sequenceType_return sequenceType282;
    #undef	RETURN_TYPE_sequenceType282
    #define	RETURN_TYPE_sequenceType282 asn1Parser_sequenceType_return

    asn1Parser_sequenceOfType_return sequenceOfType283;
    #undef	RETURN_TYPE_sequenceOfType283
    #define	RETURN_TYPE_sequenceOfType283 asn1Parser_sequenceOfType_return

    asn1Parser_setType_return setType284;
    #undef	RETURN_TYPE_setType284
    #define	RETURN_TYPE_setType284 asn1Parser_setType_return

    asn1Parser_setOfType_return setOfType285;
    #undef	RETURN_TYPE_setOfType285
    #define	RETURN_TYPE_setOfType285 asn1Parser_setOfType_return

    asn1Parser_objectidentifiertype_return objectidentifiertype286;
    #undef	RETURN_TYPE_objectidentifiertype286
    #define	RETURN_TYPE_objectidentifiertype286 asn1Parser_objectidentifiertype_return

    asn1Parser_objectClassFieldType_return objectClassFieldType287;
    #undef	RETURN_TYPE_objectClassFieldType287
    #define	RETURN_TYPE_objectClassFieldType287 asn1Parser_objectClassFieldType_return


    /* Initialize rule variables
     */
    builtinType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(86)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    octetStringType274.tree = NULL;

    ia5stringType275.tree = NULL;

    booleanType276.tree = NULL;

    nullType277.tree = NULL;

    bitStringType278.tree = NULL;

    choiceType279.tree = NULL;

    enumeratedType280.tree = NULL;

    integerType281.tree = NULL;

    sequenceType282.tree = NULL;

    sequenceOfType283.tree = NULL;

    setType284.tree = NULL;

    setOfType285.tree = NULL;

    objectidentifiertype286.tree = NULL;

    objectClassFieldType287.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:462:13: ( octetStringType | ia5stringType | booleanType | nullType | bitStringType | choiceType | enumeratedType | integerType | sequenceType | sequenceOfType | setType | setOfType | objectidentifiertype | objectClassFieldType )
            
            ANTLR3_UINT32 alt105;

            alt105=14;

            switch ( LA(1) ) 
            {
            case OCTET_LITERAL:
            	{
            		alt105=1;
            	}
                break;
            case IA5_STRING_LITERAL:
            	{
            		alt105=2;
            	}
                break;
            case BOOLEAN_LITERAL:
            	{
            		alt105=3;
            	}
                break;
            case NULL_LITERAL:
            	{
            		alt105=4;
            	}
                break;
            case BIT_LITERAL:
            	{
            		alt105=5;
            	}
                break;
            case CHOICE_LITERAL:
            	{
            		alt105=6;
            	}
                break;
            case ENUMERATED_LITERAL:
            	{
            		alt105=7;
            	}
                break;
            case INTEGER_LITERAL:
            	{
            		alt105=8;
            	}
                break;
            case SEQUENCE_LITERAL:
            	{

            		{
            		    int LA105_9 = LA(2);
            		    if ( (synpred137_asn1(ctx)) ) 
            		    {
            		        alt105=9;
            		    }
            		    else if ( (synpred138_asn1(ctx)) ) 
            		    {
            		        alt105=10;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 105;
            		        EXCEPTION->state        = 9;


            		        goto rulebuiltinTypeEx;
            		    }
            		}
            	}
                break;
            case SET_LITERAL:
            	{

            		{
            		    int LA105_10 = LA(2);
            		    if ( (synpred139_asn1(ctx)) ) 
            		    {
            		        alt105=11;
            		    }
            		    else if ( (synpred140_asn1(ctx)) ) 
            		    {
            		        alt105=12;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 105;
            		        EXCEPTION->state        = 10;


            		        goto rulebuiltinTypeEx;
            		    }
            		}
            	}
                break;
            case OBJECT_LITERAL:
            	{
            		alt105=13;
            	}
                break;
            case TYPE_IDENTIFIER_LITERAL:
            case ABSTRACT_SYNTAX_LITERAL:
            case IDENTIFIER:
            	{
            		alt105=14;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 105;
                EXCEPTION->state        = 0;


                goto rulebuiltinTypeEx;
            }

            switch (alt105) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:463:4: octetStringType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_octetStringType_in_builtinType5643);
        	        octetStringType274=octetStringType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, octetStringType274.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:464:4: ia5stringType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_ia5stringType_in_builtinType5649);
        	        ia5stringType275=ia5stringType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, ia5stringType275.tree);

        	    }
        	    break;
        	case 3:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:465:4: booleanType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_booleanType_in_builtinType5654);
        	        booleanType276=booleanType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, booleanType276.tree);

        	    }
        	    break;
        	case 4:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:466:4: nullType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_nullType_in_builtinType5659);
        	        nullType277=nullType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, nullType277.tree);

        	    }
        	    break;
        	case 5:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:467:4: bitStringType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_bitStringType_in_builtinType5664);
        	        bitStringType278=bitStringType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, bitStringType278.tree);

        	    }
        	    break;
        	case 6:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:468:4: choiceType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_choiceType_in_builtinType5669);
        	        choiceType279=choiceType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, choiceType279.tree);

        	    }
        	    break;
        	case 7:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:469:4: enumeratedType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_enumeratedType_in_builtinType5675);
        	        enumeratedType280=enumeratedType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, enumeratedType280.tree);

        	    }
        	    break;
        	case 8:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:470:4: integerType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_integerType_in_builtinType5681);
        	        integerType281=integerType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, integerType281.tree);

        	    }
        	    break;
        	case 9:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:471:4: sequenceType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_sequenceType_in_builtinType5687);
        	        sequenceType282=sequenceType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, sequenceType282.tree);

        	    }
        	    break;
        	case 10:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:472:4: sequenceOfType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_sequenceOfType_in_builtinType5693);
        	        sequenceOfType283=sequenceOfType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, sequenceOfType283.tree);

        	    }
        	    break;
        	case 11:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:473:4: setType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_setType_in_builtinType5699);
        	        setType284=setType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, setType284.tree);

        	    }
        	    break;
        	case 12:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:474:4: setOfType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_setOfType_in_builtinType5705);
        	        setOfType285=setOfType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, setOfType285.tree);

        	    }
        	    break;
        	case 13:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:475:4: objectidentifiertype
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_objectidentifiertype_in_builtinType5711);
        	        objectidentifiertype286=objectidentifiertype(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectidentifiertype286.tree);

        	    }
        	    break;
        	case 14:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:476:4: objectClassFieldType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_objectClassFieldType_in_builtinType5717);
        	        objectClassFieldType287=objectClassFieldType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinTypeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectClassFieldType287.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulebuiltinTypeEx; /* Prevent compiler warnings */
    rulebuiltinTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(86, builtinType_StartIndex); }

    return retval;
}
/* $ANTLR end builtinType */

/** 
 * $ANTLR start objectClassFieldType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:480:1: objectClassFieldType : definedObjectClass DOT fieldName ;
 */
static asn1Parser_objectClassFieldType_return
objectClassFieldType(pasn1Parser ctx)
{   
    asn1Parser_objectClassFieldType_return retval;
    ANTLR3_UINT32 objectClassFieldType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DOT289;
    asn1Parser_definedObjectClass_return definedObjectClass288;
    #undef	RETURN_TYPE_definedObjectClass288
    #define	RETURN_TYPE_definedObjectClass288 asn1Parser_definedObjectClass_return

    asn1Parser_fieldName_return fieldName290;
    #undef	RETURN_TYPE_fieldName290
    #define	RETURN_TYPE_fieldName290 asn1Parser_fieldName_return

    pANTLR3_BASE_TREE DOT289_tree;

    /* Initialize rule variables
     */
    objectClassFieldType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(87)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    DOT289       = NULL;
    definedObjectClass288.tree = NULL;

    fieldName290.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    DOT289_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:480:22: ( definedObjectClass DOT fieldName )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:480:24: definedObjectClass DOT fieldName
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_definedObjectClass_in_objectClassFieldType5728);
            definedObjectClass288=definedObjectClass(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobjectClassFieldTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedObjectClass288.tree);
            DOT289 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_objectClassFieldType5730); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectClassFieldTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            DOT289_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT289));
            ADAPTOR->addChild(ADAPTOR, root_0, DOT289_tree);
            }
            FOLLOWPUSH(FOLLOW_fieldName_in_objectClassFieldType5732);
            fieldName290=fieldName(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobjectClassFieldTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fieldName290.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectClassFieldTypeEx; /* Prevent compiler warnings */
    ruleobjectClassFieldTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(87, objectClassFieldType_StartIndex); }

    return retval;
}
/* $ANTLR end objectClassFieldType */

/** 
 * $ANTLR start setType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:484:1: setType : SET_LITERAL L_BRACE ( extensionAndException optionalExtensionMarker | componentTypeLists )? R_BRACE ;
 */
static asn1Parser_setType_return
setType(pasn1Parser ctx)
{   
    asn1Parser_setType_return retval;
    ANTLR3_UINT32 setType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SET_LITERAL291;
    pANTLR3_COMMON_TOKEN    L_BRACE292;
    pANTLR3_COMMON_TOKEN    R_BRACE296;
    asn1Parser_extensionAndException_return extensionAndException293;
    #undef	RETURN_TYPE_extensionAndException293
    #define	RETURN_TYPE_extensionAndException293 asn1Parser_extensionAndException_return

    asn1Parser_optionalExtensionMarker_return optionalExtensionMarker294;
    #undef	RETURN_TYPE_optionalExtensionMarker294
    #define	RETURN_TYPE_optionalExtensionMarker294 asn1Parser_optionalExtensionMarker_return

    asn1Parser_componentTypeLists_return componentTypeLists295;
    #undef	RETURN_TYPE_componentTypeLists295
    #define	RETURN_TYPE_componentTypeLists295 asn1Parser_componentTypeLists_return

    pANTLR3_BASE_TREE SET_LITERAL291_tree;
    pANTLR3_BASE_TREE L_BRACE292_tree;
    pANTLR3_BASE_TREE R_BRACE296_tree;

    /* Initialize rule variables
     */
    setType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(88)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    SET_LITERAL291       = NULL;
    L_BRACE292       = NULL;
    R_BRACE296       = NULL;
    extensionAndException293.tree = NULL;

    optionalExtensionMarker294.tree = NULL;

    componentTypeLists295.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    SET_LITERAL291_tree   = NULL;
    L_BRACE292_tree   = NULL;
    R_BRACE296_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:484:9: ( SET_LITERAL L_BRACE ( extensionAndException optionalExtensionMarker | componentTypeLists )? R_BRACE )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:484:12: SET_LITERAL L_BRACE ( extensionAndException optionalExtensionMarker | componentTypeLists )? R_BRACE
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            SET_LITERAL291 = (pANTLR3_COMMON_TOKEN) MATCHT(SET_LITERAL, &FOLLOW_SET_LITERAL_in_setType5745); 
            if  (HASEXCEPTION())
            {
                goto rulesetTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            SET_LITERAL291_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SET_LITERAL291));
            ADAPTOR->addChild(ADAPTOR, root_0, SET_LITERAL291_tree);
            }
            L_BRACE292 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_setType5748); 
            if  (HASEXCEPTION())
            {
                goto rulesetTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            L_BRACE292_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, L_BRACE292));
            ADAPTOR->addChild(ADAPTOR, root_0, L_BRACE292_tree);
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:484:34: ( extensionAndException optionalExtensionMarker | componentTypeLists )?
            {
                int alt106=3;
                switch ( LA(1) ) 
                {
                    case ELLIPSIS:
                    	{
                    		{
                    		    int LA106_1 = LA(2);
                    		    if ( (synpred142_asn1(ctx)) ) 
                    		    {
                    		        alt106=1;
                    		    }
                    		    else if ( (synpred143_asn1(ctx)) ) 
                    		    {
                    		        alt106=2;
                    		    }
                    		}
                    	}
                        break;
                    case COMPONENTS_LITERAL:
                    case IDENTIFIER:
                    	{
                    		alt106=2;
                    	}
                        break;
                }

                switch (alt106) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:484:35: extensionAndException optionalExtensionMarker
            	    {
            	        FOLLOWPUSH(FOLLOW_extensionAndException_in_setType5752);
            	        extensionAndException293=extensionAndException(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesetTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAndException293.tree);
            	        FOLLOWPUSH(FOLLOW_optionalExtensionMarker_in_setType5755);
            	        optionalExtensionMarker294=optionalExtensionMarker(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesetTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, optionalExtensionMarker294.tree);

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:484:85: componentTypeLists
            	    {
            	        FOLLOWPUSH(FOLLOW_componentTypeLists_in_setType5760);
            	        componentTypeLists295=componentTypeLists(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesetTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, componentTypeLists295.tree);

            	    }
            	    break;

                }
            }
            R_BRACE296 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_setType5764); 
            if  (HASEXCEPTION())
            {
                goto rulesetTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            R_BRACE296_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, R_BRACE296));
            ADAPTOR->addChild(ADAPTOR, root_0, R_BRACE296_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesetTypeEx; /* Prevent compiler warnings */
    rulesetTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(88, setType_StartIndex); }

    return retval;
}
/* $ANTLR end setType */

/** 
 * $ANTLR start setOfType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:1: setOfType : SET_LITERAL ( constraint | sizeConstraint )? OF_LITERAL ( type | namedType ) ;
 */
static asn1Parser_setOfType_return
setOfType(pasn1Parser ctx)
{   
    asn1Parser_setOfType_return retval;
    ANTLR3_UINT32 setOfType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SET_LITERAL297;
    pANTLR3_COMMON_TOKEN    OF_LITERAL300;
    asn1Parser_constraint_return constraint298;
    #undef	RETURN_TYPE_constraint298
    #define	RETURN_TYPE_constraint298 asn1Parser_constraint_return

    asn1Parser_sizeConstraint_return sizeConstraint299;
    #undef	RETURN_TYPE_sizeConstraint299
    #define	RETURN_TYPE_sizeConstraint299 asn1Parser_sizeConstraint_return

    asn1Parser_type_return type301;
    #undef	RETURN_TYPE_type301
    #define	RETURN_TYPE_type301 asn1Parser_type_return

    asn1Parser_namedType_return namedType302;
    #undef	RETURN_TYPE_namedType302
    #define	RETURN_TYPE_namedType302 asn1Parser_namedType_return

    pANTLR3_BASE_TREE SET_LITERAL297_tree;
    pANTLR3_BASE_TREE OF_LITERAL300_tree;

    /* Initialize rule variables
     */
    setOfType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(89)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    SET_LITERAL297       = NULL;
    OF_LITERAL300       = NULL;
    constraint298.tree = NULL;

    sizeConstraint299.tree = NULL;

    type301.tree = NULL;

    namedType302.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    SET_LITERAL297_tree   = NULL;
    OF_LITERAL300_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:14: ( SET_LITERAL ( constraint | sizeConstraint )? OF_LITERAL ( type | namedType ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:16: SET_LITERAL ( constraint | sizeConstraint )? OF_LITERAL ( type | namedType )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            SET_LITERAL297 = (pANTLR3_COMMON_TOKEN) MATCHT(SET_LITERAL, &FOLLOW_SET_LITERAL_in_setOfType5779); 
            if  (HASEXCEPTION())
            {
                goto rulesetOfTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            SET_LITERAL297_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SET_LITERAL297));
            ADAPTOR->addChild(ADAPTOR, root_0, SET_LITERAL297_tree);
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:28: ( constraint | sizeConstraint )?
            {
                int alt107=3;
                switch ( LA(1) ) 
                {
                    case TRUE_LITERAL:
                    case FALSE_LITERAL:
                    case TRUE_SMALL_LITERAL:
                    case FALSE_SMALL_LITERAL:
                    case L_BRACE:
                    case L_PARAN:
                    case MINUS:
                    case CONTAINING_LITERAL:
                    case ALL_LITERAL:
                    case MIN_LITERAL:
                    case PATTERN_LITERAL:
                    case CONSTRAINED_LITERAL:
                    case ENCODED_LITERAL:
                    case IDENTIFIER:
                    case NUMBER:
                    case BSTRING:
                    	{
                    		alt107=1;
                    	}
                        break;
                    case SIZE_LITERAL:
                    	{
                    		{
                    		    int LA107_12 = LA(2);
                    		    if ( (synpred144_asn1(ctx)) ) 
                    		    {
                    		        alt107=1;
                    		    }
                    		    else if ( (synpred145_asn1(ctx)) ) 
                    		    {
                    		        alt107=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt107) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:29: constraint
            	    {
            	        FOLLOWPUSH(FOLLOW_constraint_in_setOfType5782);
            	        constraint298=constraint(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesetOfTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, constraint298.tree);

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:42: sizeConstraint
            	    {
            	        FOLLOWPUSH(FOLLOW_sizeConstraint_in_setOfType5786);
            	        sizeConstraint299=sizeConstraint(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesetOfTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, sizeConstraint299.tree);

            	    }
            	    break;

                }
            }
            OF_LITERAL300 = (pANTLR3_COMMON_TOKEN) MATCHT(OF_LITERAL, &FOLLOW_OF_LITERAL_in_setOfType5790); 
            if  (HASEXCEPTION())
            {
                goto rulesetOfTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            OF_LITERAL300_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OF_LITERAL300));
            ADAPTOR->addChild(ADAPTOR, root_0, OF_LITERAL300_tree);
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:70: ( type | namedType )
            {
                int alt108=2;
                switch ( LA(1) ) 
                {
                case BOOLEAN_LITERAL:
                case INTEGER_LITERAL:
                case IA5_STRING_LITERAL:
                case ENUMERATED_LITERAL:
                case BIT_LITERAL:
                case OCTET_LITERAL:
                case NULL_LITERAL:
                case SEQUENCE_LITERAL:
                case SET_LITERAL:
                case TYPE_IDENTIFIER_LITERAL:
                case ABSTRACT_SYNTAX_LITERAL:
                case L_BRACKET:
                case CHOICE_LITERAL:
                case OBJECT_LITERAL:
                	{
                		alt108=1;
                	}
                    break;
                case IDENTIFIER:
                	{
                		switch ( LA(2) ) 
                		{
                		case EOF:
                		case ASSIGN_OP:
                		case DOT:
                		case L_BRACE:
                		case R_BRACE:
                		case COMMA:
                		case L_PARAN:
                		case R_PARAN:
                		case OPTIONAL_LITERAL:
                		case DEFAULT_LITERAL:
                		case OF_LITERAL:
                		case EXCLAM:
                		case EXCEPT_LITERAL:
                		case POWER:
                		case PIPE:
                		case UNION_LITERAL:
                		case INTERSECTION_LITERAL:
                		case UNIQUE_LITERAL:
                		case END_LITERAL:
                		case DOUBLE_R_BRACKET:
                		case COLON:
                		case ENCODED_LITERAL:
                		case EXTENSTIONENDMARKER:
                			{
                				alt108=1;
                			}
                		    break;
                		case BOOLEAN_LITERAL:
                		case INTEGER_LITERAL:
                		case IA5_STRING_LITERAL:
                		case ENUMERATED_LITERAL:
                		case BIT_LITERAL:
                		case OCTET_LITERAL:
                		case NULL_LITERAL:
                		case SEQUENCE_LITERAL:
                		case SET_LITERAL:
                		case TYPE_IDENTIFIER_LITERAL:
                		case ABSTRACT_SYNTAX_LITERAL:
                		case L_BRACKET:
                		case CHOICE_LITERAL:
                		case OBJECT_LITERAL:
                			{
                				alt108=2;
                			}
                		    break;
                		case IDENTIFIER:
                			{

                				{
                				    int LA108_4 = LA(3);
                				    if ( (synpred146_asn1(ctx)) ) 
                				    {
                				        alt108=1;
                				    }
                				    else if ( (ANTLR3_TRUE) ) 
                				    {
                				        alt108=2;
                				    }
                				    else 
                				    {
                				        if (BACKTRACKING>0)
                				        {
                				            FAILEDFLAG = ANTLR3_TRUE;
                				            return retval;
                				        }
                				    
                				        CONSTRUCTEX();
                				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				        EXCEPTION->message      = (void *)"";
                				        EXCEPTION->decisionNum  = 108;
                				        EXCEPTION->state        = 4;


                				        goto rulesetOfTypeEx;
                				    }
                				}
                			}
                		    break;

                		default:
                		    if (BACKTRACKING>0)
                		    {
                		        FAILEDFLAG = ANTLR3_TRUE;
                		        return retval;
                		    }
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 108;
                		    EXCEPTION->state        = 2;


                		    goto rulesetOfTypeEx;
                		}

                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 108;
                    EXCEPTION->state        = 0;


                    goto rulesetOfTypeEx;
                }

                switch (alt108) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:71: type
            	    {
            	        FOLLOWPUSH(FOLLOW_type_in_setOfType5793);
            	        type301=type(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesetOfTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type301.tree);

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:78: namedType
            	    {
            	        FOLLOWPUSH(FOLLOW_namedType_in_setOfType5797);
            	        namedType302=namedType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesetOfTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, namedType302.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesetOfTypeEx; /* Prevent compiler warnings */
    rulesetOfTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(89, setOfType_StartIndex); }

    return retval;
}
/* $ANTLR end setOfType */

/** 
 * $ANTLR start referencedType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:490:1: referencedType : dt= definedType -> ^( $dt) ;
 */
static asn1Parser_referencedType_return
referencedType(pasn1Parser ctx)
{   
    asn1Parser_referencedType_return retval;
    ANTLR3_UINT32 referencedType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_definedType_return dt;
    #undef	RETURN_TYPE_dt
    #define	RETURN_TYPE_dt asn1Parser_definedType_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_definedType;
    /* Initialize rule variables
     */
    referencedType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(90)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    dt.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_definedType   = NULL;
    #define CREATE_stream_definedType  if (stream_definedType == NULL) {stream_definedType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule definedType"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:490:16: (dt= definedType -> ^( $dt) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:491:3: dt= definedType
        {
            FOLLOWPUSH(FOLLOW_definedType_in_referencedType5811);
            dt=definedType(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulereferencedTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_definedType; stream_definedType->add(stream_definedType, dt.tree, NULL); }

             
            /* AST REWRITE
             * elements          : dt
             * token labels      : 
             * rule labels       : dt, retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_dt;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_dt=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token dt", dt.tree != NULL ? dt.tree : NULL);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 495:1: -> ^( $dt)
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:495:4: ^( $dt)
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_dt == NULL ? NULL : stream_dt->nextNode(stream_dt), root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_dt != NULL) stream_dt->free(stream_dt);
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulereferencedTypeEx; /* Prevent compiler warnings */
    rulereferencedTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_definedType != NULL) stream_definedType->free(stream_definedType);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(90, referencedType_StartIndex); }

    return retval;
}
/* $ANTLR end referencedType */

/** 
 * $ANTLR start definedType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:497:1: definedType : id= IDENTIFIER ( DOT IDENTIFIER )? (pl= actualParameterList )? -> ^( $id ( $pl)? ) ;
 */
static asn1Parser_definedType_return
definedType(pasn1Parser ctx)
{   
    asn1Parser_definedType_return retval;
    ANTLR3_UINT32 definedType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    id;
    pANTLR3_COMMON_TOKEN    DOT303;
    pANTLR3_COMMON_TOKEN    IDENTIFIER304;
    asn1Parser_actualParameterList_return pl;
    #undef	RETURN_TYPE_pl
    #define	RETURN_TYPE_pl asn1Parser_actualParameterList_return

    pANTLR3_BASE_TREE id_tree;
    pANTLR3_BASE_TREE DOT303_tree;
    pANTLR3_BASE_TREE IDENTIFIER304_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_DOT;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_actualParameterList;
    /* Initialize rule variables
     */
    definedType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(91)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    id       = NULL;
    DOT303       = NULL;
    IDENTIFIER304       = NULL;
    pl.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    id_tree   = NULL;
    DOT303_tree   = NULL;
    IDENTIFIER304_tree   = NULL;

    stream_DOT   = NULL;
    #define CREATE_stream_DOT  if (stream_DOT == NULL) {stream_DOT = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token DOT"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_actualParameterList   = NULL;
    #define CREATE_stream_actualParameterList  if (stream_actualParameterList == NULL) {stream_actualParameterList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule actualParameterList"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:497:13: (id= IDENTIFIER ( DOT IDENTIFIER )? (pl= actualParameterList )? -> ^( $id ( $pl)? ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:498:1: id= IDENTIFIER ( DOT IDENTIFIER )? (pl= actualParameterList )?
        {
            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_definedType5833); 
            if  (HASEXCEPTION())
            {
                goto ruledefinedTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, id, NULL); }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:498:15: ( DOT IDENTIFIER )?
            {
                int alt109=2;
                switch ( LA(1) ) 
                {
                    case DOT:
                    	{
                    		alt109=1;
                    	}
                        break;
                }

                switch (alt109) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:498:16: DOT IDENTIFIER
            	    {
            	        DOT303 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_definedType5836); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledefinedTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_DOT; stream_DOT->add(stream_DOT, DOT303, NULL); }

            	        IDENTIFIER304 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_definedType5838); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledefinedTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, IDENTIFIER304, NULL); }


            	    }
            	    break;

                }
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:498:35: (pl= actualParameterList )?
            {
                int alt110=2;
                switch ( LA(1) ) 
                {
                    case L_BRACE:
                    	{
                    		{
                    		    int LA110_1 = LA(2);
                    		    if ( (synpred148_asn1(ctx)) ) 
                    		    {
                    		        alt110=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt110) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: pl= actualParameterList
            	    {
            	        FOLLOWPUSH(FOLLOW_actualParameterList_in_definedType5844);
            	        pl=actualParameterList(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledefinedTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_actualParameterList; stream_actualParameterList->add(stream_actualParameterList, pl.tree, NULL); }

            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : id, pl
             * token labels      : id
             * rule labels       : retval, pl
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_id;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_pl;

            	stream_id=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token id", id);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_pl=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token pl", pl.tree != NULL ? pl.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 498:57: -> ^( $id ( $pl)? )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:498:60: ^( $id ( $pl)? )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRootToken(ADAPTOR, stream_id == NULL ? NULL : stream_id->nextToken(stream_id), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:498:66: ( $pl)?
            	        {
            	        	if ( (stream_pl != NULL && stream_pl->hasNext(stream_pl))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_pl == NULL ? NULL : stream_pl->nextTree(stream_pl));

            	        	}
            	        	if ( stream_pl != NULL) stream_pl->reset(stream_pl);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_id != NULL) stream_id->free(stream_id); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_pl != NULL) stream_pl->free(stream_pl);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledefinedTypeEx; /* Prevent compiler warnings */
    ruledefinedTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_DOT != NULL) stream_DOT->free(stream_DOT);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_actualParameterList != NULL) stream_actualParameterList->free(stream_actualParameterList);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(91, definedType_StartIndex); }

    return retval;
}
/* $ANTLR end definedType */

/** 
 * $ANTLR start constraint
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:502:1: constraint : ( L_PARAN constraintSpec exceptionSpec R_PARAN | constraintSpec exceptionSpec );
 */
static asn1Parser_constraint_return
constraint(pasn1Parser ctx)
{   
    asn1Parser_constraint_return retval;
    ANTLR3_UINT32 constraint_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    L_PARAN305;
    pANTLR3_COMMON_TOKEN    R_PARAN308;
    asn1Parser_constraintSpec_return constraintSpec306;
    #undef	RETURN_TYPE_constraintSpec306
    #define	RETURN_TYPE_constraintSpec306 asn1Parser_constraintSpec_return

    asn1Parser_exceptionSpec_return exceptionSpec307;
    #undef	RETURN_TYPE_exceptionSpec307
    #define	RETURN_TYPE_exceptionSpec307 asn1Parser_exceptionSpec_return

    asn1Parser_constraintSpec_return constraintSpec309;
    #undef	RETURN_TYPE_constraintSpec309
    #define	RETURN_TYPE_constraintSpec309 asn1Parser_constraintSpec_return

    asn1Parser_exceptionSpec_return exceptionSpec310;
    #undef	RETURN_TYPE_exceptionSpec310
    #define	RETURN_TYPE_exceptionSpec310 asn1Parser_exceptionSpec_return

    pANTLR3_BASE_TREE L_PARAN305_tree;
    pANTLR3_BASE_TREE R_PARAN308_tree;

    /* Initialize rule variables
     */
    constraint_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(92)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    L_PARAN305       = NULL;
    R_PARAN308       = NULL;
    constraintSpec306.tree = NULL;

    exceptionSpec307.tree = NULL;

    constraintSpec309.tree = NULL;

    exceptionSpec310.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    L_PARAN305_tree   = NULL;
    R_PARAN308_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:502:12: ( L_PARAN constraintSpec exceptionSpec R_PARAN | constraintSpec exceptionSpec )
            
            ANTLR3_UINT32 alt111;

            alt111=2;

            switch ( LA(1) ) 
            {
            case L_PARAN:
            	{
            		alt111=1;
            	}
                break;
            case TRUE_LITERAL:
            case FALSE_LITERAL:
            case TRUE_SMALL_LITERAL:
            case FALSE_SMALL_LITERAL:
            case L_BRACE:
            case MINUS:
            case CONTAINING_LITERAL:
            case ALL_LITERAL:
            case MIN_LITERAL:
            case SIZE_LITERAL:
            case PATTERN_LITERAL:
            case CONSTRAINED_LITERAL:
            case ENCODED_LITERAL:
            case IDENTIFIER:
            case NUMBER:
            case BSTRING:
            	{
            		alt111=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 111;
                EXCEPTION->state        = 0;


                goto ruleconstraintEx;
            }

            switch (alt111) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:502:14: L_PARAN constraintSpec exceptionSpec R_PARAN
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        L_PARAN305 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_constraint5867); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        FOLLOWPUSH(FOLLOW_constraintSpec_in_constraint5870);
        	        constraintSpec306=constraintSpec(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, constraintSpec306.tree);
        	        FOLLOWPUSH(FOLLOW_exceptionSpec_in_constraint5873);
        	        exceptionSpec307=exceptionSpec(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, exceptionSpec307.tree);
        	        R_PARAN308 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_constraint5875); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:503:7: constraintSpec exceptionSpec
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_constraintSpec_in_constraint5884);
        	        constraintSpec309=constraintSpec(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, constraintSpec309.tree);
        	        FOLLOWPUSH(FOLLOW_exceptionSpec_in_constraint5887);
        	        exceptionSpec310=exceptionSpec(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, exceptionSpec310.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstraintEx; /* Prevent compiler warnings */
    ruleconstraintEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(92, constraint_StartIndex); }

    return retval;
}
/* $ANTLR end constraint */

/** 
 * $ANTLR start constraintSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:507:1: constraintSpec : ( generalConstraint | subtypeConstraint );
 */
static asn1Parser_constraintSpec_return
constraintSpec(pasn1Parser ctx)
{   
    asn1Parser_constraintSpec_return retval;
    ANTLR3_UINT32 constraintSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_generalConstraint_return generalConstraint311;
    #undef	RETURN_TYPE_generalConstraint311
    #define	RETURN_TYPE_generalConstraint311 asn1Parser_generalConstraint_return

    asn1Parser_subtypeConstraint_return subtypeConstraint312;
    #undef	RETURN_TYPE_subtypeConstraint312
    #define	RETURN_TYPE_subtypeConstraint312 asn1Parser_subtypeConstraint_return


    /* Initialize rule variables
     */
    constraintSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(93)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    generalConstraint311.tree = NULL;

    subtypeConstraint312.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:507:16: ( generalConstraint | subtypeConstraint )
            
            ANTLR3_UINT32 alt112;

            alt112=2;

            switch ( LA(1) ) 
            {
            case CONTAINING_LITERAL:
            case CONSTRAINED_LITERAL:
            case ENCODED_LITERAL:
            	{
            		alt112=1;
            	}
                break;
            case L_BRACE:
            	{
            		switch ( LA(2) ) 
            		{
            		case NUMBER:
            			{
            				alt112=2;
            			}
            		    break;
            		case IDENTIFIER:
            			{
            				switch ( LA(3) ) 
            				{
            				case L_BRACE:
            				case L_PARAN:
            				case IDENTIFIER:
            				case NUMBER:
            					{
            						alt112=2;
            					}
            				    break;
            				case R_BRACE:
            					{

            						{
            						    int LA112_5 = LA(4);
            						    if ( (synpred150_asn1(ctx)) ) 
            						    {
            						        alt112=1;
            						    }
            						    else if ( (ANTLR3_TRUE) ) 
            						    {
            						        alt112=2;
            						    }
            						    else 
            						    {
            						        if (BACKTRACKING>0)
            						        {
            						            FAILEDFLAG = ANTLR3_TRUE;
            						            return retval;
            						        }
            						    
            						        CONSTRUCTEX();
            						        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						        EXCEPTION->message      = (void *)"";
            						        EXCEPTION->decisionNum  = 112;
            						        EXCEPTION->state        = 5;


            						        goto ruleconstraintSpecEx;
            						    }
            						}
            					}
            				    break;
            				case DOT:
            					{
            						switch ( LA(4) ) 
            						{
            						case IDENTIFIER:
            							{
            								switch ( LA(5) ) 
            								{
            								case R_BRACE:
            									{

            										{
            										    int LA112_5 = LA(6);
            										    if ( (synpred150_asn1(ctx)) ) 
            										    {
            										        alt112=1;
            										    }
            										    else if ( (ANTLR3_TRUE) ) 
            										    {
            										        alt112=2;
            										    }
            										    else 
            										    {
            										        if (BACKTRACKING>0)
            										        {
            										            FAILEDFLAG = ANTLR3_TRUE;
            										            return retval;
            										        }
            										    
            										        CONSTRUCTEX();
            										        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            										        EXCEPTION->message      = (void *)"";
            										        EXCEPTION->decisionNum  = 112;
            										        EXCEPTION->state        = 5;


            										        goto ruleconstraintSpecEx;
            										    }
            										}
            									}
            								    break;
            								case L_BRACE:
            								case IDENTIFIER:
            								case NUMBER:
            									{
            										alt112=2;
            									}
            								    break;

            								default:
            								    if (BACKTRACKING>0)
            								    {
            								        FAILEDFLAG = ANTLR3_TRUE;
            								        return retval;
            								    }
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 112;
            								    EXCEPTION->state        = 7;


            								    goto ruleconstraintSpecEx;
            								}

            							}
            						    break;

            						default:
            						    if (BACKTRACKING>0)
            						    {
            						        FAILEDFLAG = ANTLR3_TRUE;
            						        return retval;
            						    }
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 112;
            						    EXCEPTION->state        = 6;


            						    goto ruleconstraintSpecEx;
            						}

            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return retval;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 112;
            				    EXCEPTION->state        = 4;


            				    goto ruleconstraintSpecEx;
            				}

            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 112;
            		    EXCEPTION->state        = 2;


            		    goto ruleconstraintSpecEx;
            		}

            	}
                break;
            case TRUE_LITERAL:
            case FALSE_LITERAL:
            case TRUE_SMALL_LITERAL:
            case FALSE_SMALL_LITERAL:
            case MINUS:
            case ALL_LITERAL:
            case MIN_LITERAL:
            case SIZE_LITERAL:
            case PATTERN_LITERAL:
            case IDENTIFIER:
            case NUMBER:
            case BSTRING:
            	{
            		alt112=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 112;
                EXCEPTION->state        = 0;


                goto ruleconstraintSpecEx;
            }

            switch (alt112) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:507:18: generalConstraint
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_generalConstraint_in_constraintSpec5897);
        	        generalConstraint311=generalConstraint(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstraintSpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, generalConstraint311.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:507:38: subtypeConstraint
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_subtypeConstraint_in_constraintSpec5901);
        	        subtypeConstraint312=subtypeConstraint(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleconstraintSpecEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, subtypeConstraint312.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstraintSpecEx; /* Prevent compiler warnings */
    ruleconstraintSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(93, constraintSpec_StartIndex); }

    return retval;
}
/* $ANTLR end constraintSpec */

/** 
 * $ANTLR start userDefinedConstraint
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:509:1: userDefinedConstraint : CONSTRAINED_LITERAL BY_LITERAL L_BRACE userDefinedConstraintParameter ( COMMA userDefinedConstraintParameter )* R_BRACE ;
 */
static asn1Parser_userDefinedConstraint_return
userDefinedConstraint(pasn1Parser ctx)
{   
    asn1Parser_userDefinedConstraint_return retval;
    ANTLR3_UINT32 userDefinedConstraint_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    CONSTRAINED_LITERAL313;
    pANTLR3_COMMON_TOKEN    BY_LITERAL314;
    pANTLR3_COMMON_TOKEN    L_BRACE315;
    pANTLR3_COMMON_TOKEN    COMMA317;
    pANTLR3_COMMON_TOKEN    R_BRACE319;
    asn1Parser_userDefinedConstraintParameter_return userDefinedConstraintParameter316;
    #undef	RETURN_TYPE_userDefinedConstraintParameter316
    #define	RETURN_TYPE_userDefinedConstraintParameter316 asn1Parser_userDefinedConstraintParameter_return

    asn1Parser_userDefinedConstraintParameter_return userDefinedConstraintParameter318;
    #undef	RETURN_TYPE_userDefinedConstraintParameter318
    #define	RETURN_TYPE_userDefinedConstraintParameter318 asn1Parser_userDefinedConstraintParameter_return

    pANTLR3_BASE_TREE CONSTRAINED_LITERAL313_tree;
    pANTLR3_BASE_TREE BY_LITERAL314_tree;
    pANTLR3_BASE_TREE L_BRACE315_tree;
    pANTLR3_BASE_TREE COMMA317_tree;
    pANTLR3_BASE_TREE R_BRACE319_tree;

    /* Initialize rule variables
     */
    userDefinedConstraint_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(94)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    CONSTRAINED_LITERAL313       = NULL;
    BY_LITERAL314       = NULL;
    L_BRACE315       = NULL;
    COMMA317       = NULL;
    R_BRACE319       = NULL;
    userDefinedConstraintParameter316.tree = NULL;

    userDefinedConstraintParameter318.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    CONSTRAINED_LITERAL313_tree   = NULL;
    BY_LITERAL314_tree   = NULL;
    L_BRACE315_tree   = NULL;
    COMMA317_tree   = NULL;
    R_BRACE319_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:509:23: ( CONSTRAINED_LITERAL BY_LITERAL L_BRACE userDefinedConstraintParameter ( COMMA userDefinedConstraintParameter )* R_BRACE )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:509:25: CONSTRAINED_LITERAL BY_LITERAL L_BRACE userDefinedConstraintParameter ( COMMA userDefinedConstraintParameter )* R_BRACE
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            CONSTRAINED_LITERAL313 = (pANTLR3_COMMON_TOKEN) MATCHT(CONSTRAINED_LITERAL, &FOLLOW_CONSTRAINED_LITERAL_in_userDefinedConstraint5911); 
            if  (HASEXCEPTION())
            {
                goto ruleuserDefinedConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            CONSTRAINED_LITERAL313_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CONSTRAINED_LITERAL313));
            ADAPTOR->addChild(ADAPTOR, root_0, CONSTRAINED_LITERAL313_tree);
            }
            BY_LITERAL314 = (pANTLR3_COMMON_TOKEN) MATCHT(BY_LITERAL, &FOLLOW_BY_LITERAL_in_userDefinedConstraint5913); 
            if  (HASEXCEPTION())
            {
                goto ruleuserDefinedConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            BY_LITERAL314_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BY_LITERAL314));
            ADAPTOR->addChild(ADAPTOR, root_0, BY_LITERAL314_tree);
            }
            L_BRACE315 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_userDefinedConstraint5915); 
            if  (HASEXCEPTION())
            {
                goto ruleuserDefinedConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            L_BRACE315_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, L_BRACE315));
            ADAPTOR->addChild(ADAPTOR, root_0, L_BRACE315_tree);
            }
            FOLLOWPUSH(FOLLOW_userDefinedConstraintParameter_in_userDefinedConstraint5917);
            userDefinedConstraintParameter316=userDefinedConstraintParameter(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuserDefinedConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, userDefinedConstraintParameter316.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:509:95: ( COMMA userDefinedConstraintParameter )*

            for (;;)
            {
                int alt113=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt113=1;
                	}
                    break;

                }

                switch (alt113) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:509:96: COMMA userDefinedConstraintParameter
            	    {
            	        COMMA317 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_userDefinedConstraint5920); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuserDefinedConstraintEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        COMMA317_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA317));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA317_tree);
            	        }
            	        FOLLOWPUSH(FOLLOW_userDefinedConstraintParameter_in_userDefinedConstraint5922);
            	        userDefinedConstraintParameter318=userDefinedConstraintParameter(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuserDefinedConstraintEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, userDefinedConstraintParameter318.tree);

            	    }
            	    break;

            	default:
            	    goto loop113;	/* break out of the loop */
            	    break;
                }
            }
            loop113: ; /* Jump out to here if this rule does not match */

            R_BRACE319 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_userDefinedConstraint5926); 
            if  (HASEXCEPTION())
            {
                goto ruleuserDefinedConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            R_BRACE319_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, R_BRACE319));
            ADAPTOR->addChild(ADAPTOR, root_0, R_BRACE319_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuserDefinedConstraintEx; /* Prevent compiler warnings */
    ruleuserDefinedConstraintEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(94, userDefinedConstraint_StartIndex); }

    return retval;
}
/* $ANTLR end userDefinedConstraint */

/** 
 * $ANTLR start generalConstraint
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:512:1: generalConstraint : ( userDefinedConstraint | tableConstraint | contentsConstraint );
 */
static asn1Parser_generalConstraint_return
generalConstraint(pasn1Parser ctx)
{   
    asn1Parser_generalConstraint_return retval;
    ANTLR3_UINT32 generalConstraint_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_userDefinedConstraint_return userDefinedConstraint320;
    #undef	RETURN_TYPE_userDefinedConstraint320
    #define	RETURN_TYPE_userDefinedConstraint320 asn1Parser_userDefinedConstraint_return

    asn1Parser_tableConstraint_return tableConstraint321;
    #undef	RETURN_TYPE_tableConstraint321
    #define	RETURN_TYPE_tableConstraint321 asn1Parser_tableConstraint_return

    asn1Parser_contentsConstraint_return contentsConstraint322;
    #undef	RETURN_TYPE_contentsConstraint322
    #define	RETURN_TYPE_contentsConstraint322 asn1Parser_contentsConstraint_return


    /* Initialize rule variables
     */
    generalConstraint_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(95)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    userDefinedConstraint320.tree = NULL;

    tableConstraint321.tree = NULL;

    contentsConstraint322.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:512:19: ( userDefinedConstraint | tableConstraint | contentsConstraint )
            
            ANTLR3_UINT32 alt114;

            alt114=3;

            switch ( LA(1) ) 
            {
            case CONSTRAINED_LITERAL:
            	{
            		alt114=1;
            	}
                break;
            case L_BRACE:
            	{
            		alt114=2;
            	}
                break;
            case CONTAINING_LITERAL:
            case ENCODED_LITERAL:
            	{
            		alt114=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 114;
                EXCEPTION->state        = 0;


                goto rulegeneralConstraintEx;
            }

            switch (alt114) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:512:22: userDefinedConstraint
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_userDefinedConstraint_in_generalConstraint5937);
        	        userDefinedConstraint320=userDefinedConstraint(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, userDefinedConstraint320.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:512:46: tableConstraint
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_tableConstraint_in_generalConstraint5941);
        	        tableConstraint321=tableConstraint(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, tableConstraint321.tree);

        	    }
        	    break;
        	case 3:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:512:64: contentsConstraint
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_contentsConstraint_in_generalConstraint5945);
        	        contentsConstraint322=contentsConstraint(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, contentsConstraint322.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulegeneralConstraintEx; /* Prevent compiler warnings */
    rulegeneralConstraintEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(95, generalConstraint_StartIndex); }

    return retval;
}
/* $ANTLR end generalConstraint */

/** 
 * $ANTLR start userDefinedConstraintParameter
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:514:1: userDefinedConstraintParameter : governor ( COLON value | valueSet | object | objectSet )? ;
 */
static asn1Parser_userDefinedConstraintParameter_return
userDefinedConstraintParameter(pasn1Parser ctx)
{   
    asn1Parser_userDefinedConstraintParameter_return retval;
    ANTLR3_UINT32 userDefinedConstraintParameter_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COLON324;
    asn1Parser_governor_return governor323;
    #undef	RETURN_TYPE_governor323
    #define	RETURN_TYPE_governor323 asn1Parser_governor_return

    asn1Parser_value_return value325;
    #undef	RETURN_TYPE_value325
    #define	RETURN_TYPE_value325 asn1Parser_value_return

    asn1Parser_valueSet_return valueSet326;
    #undef	RETURN_TYPE_valueSet326
    #define	RETURN_TYPE_valueSet326 asn1Parser_valueSet_return

    asn1Parser_object_return object327;
    #undef	RETURN_TYPE_object327
    #define	RETURN_TYPE_object327 asn1Parser_object_return

    asn1Parser_objectSet_return objectSet328;
    #undef	RETURN_TYPE_objectSet328
    #define	RETURN_TYPE_objectSet328 asn1Parser_objectSet_return

    pANTLR3_BASE_TREE COLON324_tree;

    /* Initialize rule variables
     */
    userDefinedConstraintParameter_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(96)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COLON324       = NULL;
    governor323.tree = NULL;

    value325.tree = NULL;

    valueSet326.tree = NULL;

    object327.tree = NULL;

    objectSet328.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COLON324_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:514:32: ( governor ( COLON value | valueSet | object | objectSet )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:515:2: governor ( COLON value | valueSet | object | objectSet )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_governor_in_userDefinedConstraintParameter5956);
            governor323=governor(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuserDefinedConstraintParameterEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, governor323.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:515:11: ( COLON value | valueSet | object | objectSet )?
            {
                int alt115=5;
                switch ( LA(1) ) 
                {
                    case COLON:
                    	{
                    		alt115=1;
                    	}
                        break;
                    case L_BRACE:
                    	{
                    		{
                    		    int LA115_2 = LA(2);
                    		    if ( (synpred155_asn1(ctx)) ) 
                    		    {
                    		        alt115=2;
                    		    }
                    		    else if ( (synpred157_asn1(ctx)) ) 
                    		    {
                    		        alt115=4;
                    		    }
                    		}
                    	}
                        break;
                    case IDENTIFIER:
                    	{
                    		alt115=3;
                    	}
                        break;
                }

                switch (alt115) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:515:12: COLON value
            	    {
            	        COLON324 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_userDefinedConstraintParameter5959); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuserDefinedConstraintParameterEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        COLON324_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON324));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COLON324_tree);
            	        }
            	        FOLLOWPUSH(FOLLOW_value_in_userDefinedConstraintParameter5965);
            	        value325=value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuserDefinedConstraintParameterEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value325.tree);

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:517:6: valueSet
            	    {
            	        FOLLOWPUSH(FOLLOW_valueSet_in_userDefinedConstraintParameter5973);
            	        valueSet326=valueSet(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuserDefinedConstraintParameterEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, valueSet326.tree);

            	    }
            	    break;
            	case 3:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:518:6: object
            	    {
            	        FOLLOWPUSH(FOLLOW_object_in_userDefinedConstraintParameter5980);
            	        object327=object(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuserDefinedConstraintParameterEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, object327.tree);

            	    }
            	    break;
            	case 4:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:519:6: objectSet
            	    {
            	        FOLLOWPUSH(FOLLOW_objectSet_in_userDefinedConstraintParameter5987);
            	        objectSet328=objectSet(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuserDefinedConstraintParameterEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectSet328.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuserDefinedConstraintParameterEx; /* Prevent compiler warnings */
    ruleuserDefinedConstraintParameterEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(96, userDefinedConstraintParameter_StartIndex); }

    return retval;
}
/* $ANTLR end userDefinedConstraintParameter */

/** 
 * $ANTLR start tableConstraint
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:523:1: tableConstraint : componentRelationConstraint ;
 */
static asn1Parser_tableConstraint_return
tableConstraint(pasn1Parser ctx)
{   
    asn1Parser_tableConstraint_return retval;
    ANTLR3_UINT32 tableConstraint_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_componentRelationConstraint_return componentRelationConstraint329;
    #undef	RETURN_TYPE_componentRelationConstraint329
    #define	RETURN_TYPE_componentRelationConstraint329 asn1Parser_componentRelationConstraint_return


    /* Initialize rule variables
     */
    tableConstraint_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(97)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    componentRelationConstraint329.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:523:17: ( componentRelationConstraint )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:523:47: componentRelationConstraint
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_componentRelationConstraint_in_tableConstraint6004);
            componentRelationConstraint329=componentRelationConstraint(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletableConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, componentRelationConstraint329.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletableConstraintEx; /* Prevent compiler warnings */
    ruletableConstraintEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(97, tableConstraint_StartIndex); }

    return retval;
}
/* $ANTLR end tableConstraint */

/** 
 * $ANTLR start simpleTableConstraint
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:525:1: simpleTableConstraint : objectSet ;
 */
static asn1Parser_simpleTableConstraint_return
simpleTableConstraint(pasn1Parser ctx)
{   
    asn1Parser_simpleTableConstraint_return retval;
    ANTLR3_UINT32 simpleTableConstraint_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_objectSet_return objectSet330;
    #undef	RETURN_TYPE_objectSet330
    #define	RETURN_TYPE_objectSet330 asn1Parser_objectSet_return


    /* Initialize rule variables
     */
    simpleTableConstraint_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(98)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    objectSet330.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:525:23: ( objectSet )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:525:25: objectSet
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_objectSet_in_simpleTableConstraint6013);
            objectSet330=objectSet(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesimpleTableConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectSet330.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesimpleTableConstraintEx; /* Prevent compiler warnings */
    rulesimpleTableConstraintEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(98, simpleTableConstraint_StartIndex); }

    return retval;
}
/* $ANTLR end simpleTableConstraint */

/** 
 * $ANTLR start contentsConstraint
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:529:1: contentsConstraint : ( CONTAINING_LITERAL type | ENCODED_LITERAL BY_LITERAL value | CONTAINING_LITERAL type ENCODED_LITERAL BY_LITERAL value );
 */
static asn1Parser_contentsConstraint_return
contentsConstraint(pasn1Parser ctx)
{   
    asn1Parser_contentsConstraint_return retval;
    ANTLR3_UINT32 contentsConstraint_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    CONTAINING_LITERAL331;
    pANTLR3_COMMON_TOKEN    ENCODED_LITERAL333;
    pANTLR3_COMMON_TOKEN    BY_LITERAL334;
    pANTLR3_COMMON_TOKEN    CONTAINING_LITERAL336;
    pANTLR3_COMMON_TOKEN    ENCODED_LITERAL338;
    pANTLR3_COMMON_TOKEN    BY_LITERAL339;
    asn1Parser_type_return type332;
    #undef	RETURN_TYPE_type332
    #define	RETURN_TYPE_type332 asn1Parser_type_return

    asn1Parser_value_return value335;
    #undef	RETURN_TYPE_value335
    #define	RETURN_TYPE_value335 asn1Parser_value_return

    asn1Parser_type_return type337;
    #undef	RETURN_TYPE_type337
    #define	RETURN_TYPE_type337 asn1Parser_type_return

    asn1Parser_value_return value340;
    #undef	RETURN_TYPE_value340
    #define	RETURN_TYPE_value340 asn1Parser_value_return

    pANTLR3_BASE_TREE CONTAINING_LITERAL331_tree;
    pANTLR3_BASE_TREE ENCODED_LITERAL333_tree;
    pANTLR3_BASE_TREE BY_LITERAL334_tree;
    pANTLR3_BASE_TREE CONTAINING_LITERAL336_tree;
    pANTLR3_BASE_TREE ENCODED_LITERAL338_tree;
    pANTLR3_BASE_TREE BY_LITERAL339_tree;

    /* Initialize rule variables
     */
    contentsConstraint_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(99)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    CONTAINING_LITERAL331       = NULL;
    ENCODED_LITERAL333       = NULL;
    BY_LITERAL334       = NULL;
    CONTAINING_LITERAL336       = NULL;
    ENCODED_LITERAL338       = NULL;
    BY_LITERAL339       = NULL;
    type332.tree = NULL;

    value335.tree = NULL;

    type337.tree = NULL;

    value340.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    CONTAINING_LITERAL331_tree   = NULL;
    ENCODED_LITERAL333_tree   = NULL;
    BY_LITERAL334_tree   = NULL;
    CONTAINING_LITERAL336_tree   = NULL;
    ENCODED_LITERAL338_tree   = NULL;
    BY_LITERAL339_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:529:20: ( CONTAINING_LITERAL type | ENCODED_LITERAL BY_LITERAL value | CONTAINING_LITERAL type ENCODED_LITERAL BY_LITERAL value )
            
            ANTLR3_UINT32 alt116;

            alt116=3;

            switch ( LA(1) ) 
            {
            case CONTAINING_LITERAL:
            	{

            		{
            		    int LA116_1 = LA(2);
            		    if ( (synpred158_asn1(ctx)) ) 
            		    {
            		        alt116=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt116=3;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 116;
            		        EXCEPTION->state        = 1;


            		        goto rulecontentsConstraintEx;
            		    }
            		}
            	}
                break;
            case ENCODED_LITERAL:
            	{
            		alt116=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 116;
                EXCEPTION->state        = 0;


                goto rulecontentsConstraintEx;
            }

            switch (alt116) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:530:4: CONTAINING_LITERAL type
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        CONTAINING_LITERAL331 = (pANTLR3_COMMON_TOKEN) MATCHT(CONTAINING_LITERAL, &FOLLOW_CONTAINING_LITERAL_in_contentsConstraint6028); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecontentsConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        CONTAINING_LITERAL331_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CONTAINING_LITERAL331));
        	        ADAPTOR->addChild(ADAPTOR, root_0, CONTAINING_LITERAL331_tree);
        	        }
        	        FOLLOWPUSH(FOLLOW_type_in_contentsConstraint6030);
        	        type332=type(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecontentsConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type332.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:531:5: ENCODED_LITERAL BY_LITERAL value
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        ENCODED_LITERAL333 = (pANTLR3_COMMON_TOKEN) MATCHT(ENCODED_LITERAL, &FOLLOW_ENCODED_LITERAL_in_contentsConstraint6037); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecontentsConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        ENCODED_LITERAL333_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ENCODED_LITERAL333));
        	        ADAPTOR->addChild(ADAPTOR, root_0, ENCODED_LITERAL333_tree);
        	        }
        	        BY_LITERAL334 = (pANTLR3_COMMON_TOKEN) MATCHT(BY_LITERAL, &FOLLOW_BY_LITERAL_in_contentsConstraint6039); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecontentsConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        BY_LITERAL334_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BY_LITERAL334));
        	        ADAPTOR->addChild(ADAPTOR, root_0, BY_LITERAL334_tree);
        	        }
        	        FOLLOWPUSH(FOLLOW_value_in_contentsConstraint6041);
        	        value335=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecontentsConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value335.tree);

        	    }
        	    break;
        	case 3:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:532:5: CONTAINING_LITERAL type ENCODED_LITERAL BY_LITERAL value
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        CONTAINING_LITERAL336 = (pANTLR3_COMMON_TOKEN) MATCHT(CONTAINING_LITERAL, &FOLLOW_CONTAINING_LITERAL_in_contentsConstraint6048); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecontentsConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        CONTAINING_LITERAL336_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CONTAINING_LITERAL336));
        	        ADAPTOR->addChild(ADAPTOR, root_0, CONTAINING_LITERAL336_tree);
        	        }
        	        FOLLOWPUSH(FOLLOW_type_in_contentsConstraint6050);
        	        type337=type(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecontentsConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type337.tree);
        	        ENCODED_LITERAL338 = (pANTLR3_COMMON_TOKEN) MATCHT(ENCODED_LITERAL, &FOLLOW_ENCODED_LITERAL_in_contentsConstraint6052); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecontentsConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        ENCODED_LITERAL338_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ENCODED_LITERAL338));
        	        ADAPTOR->addChild(ADAPTOR, root_0, ENCODED_LITERAL338_tree);
        	        }
        	        BY_LITERAL339 = (pANTLR3_COMMON_TOKEN) MATCHT(BY_LITERAL, &FOLLOW_BY_LITERAL_in_contentsConstraint6054); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecontentsConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        BY_LITERAL339_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BY_LITERAL339));
        	        ADAPTOR->addChild(ADAPTOR, root_0, BY_LITERAL339_tree);
        	        }
        	        FOLLOWPUSH(FOLLOW_value_in_contentsConstraint6056);
        	        value340=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecontentsConstraintEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value340.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecontentsConstraintEx; /* Prevent compiler warnings */
    rulecontentsConstraintEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(99, contentsConstraint_StartIndex); }

    return retval;
}
/* $ANTLR end contentsConstraint */

/** 
 * $ANTLR start subtypeConstraint
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:536:1: subtypeConstraint : elementSetSpecs ;
 */
static asn1Parser_subtypeConstraint_return
subtypeConstraint(pasn1Parser ctx)
{   
    asn1Parser_subtypeConstraint_return retval;
    ANTLR3_UINT32 subtypeConstraint_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_elementSetSpecs_return elementSetSpecs341;
    #undef	RETURN_TYPE_elementSetSpecs341
    #define	RETURN_TYPE_elementSetSpecs341 asn1Parser_elementSetSpecs_return


    /* Initialize rule variables
     */
    subtypeConstraint_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(100)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    elementSetSpecs341.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:536:19: ( elementSetSpecs )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:537:1: elementSetSpecs
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_elementSetSpecs_in_subtypeConstraint6068);
            elementSetSpecs341=elementSetSpecs(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubtypeConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, elementSetSpecs341.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesubtypeConstraintEx; /* Prevent compiler warnings */
    rulesubtypeConstraintEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(100, subtypeConstraint_StartIndex); }

    return retval;
}
/* $ANTLR end subtypeConstraint */

/** 
 * $ANTLR start value
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:542:1: value : bt= builtinValue -> ^( VALUE_NODE ( $bt)? ) ;
 */
static asn1Parser_value_return
value(pasn1Parser ctx)
{   
    asn1Parser_value_return retval;
    ANTLR3_UINT32 value_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_builtinValue_return bt;
    #undef	RETURN_TYPE_bt
    #define	RETURN_TYPE_bt asn1Parser_builtinValue_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_builtinValue;
    /* Initialize rule variables
     */
    value_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(101)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    bt.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_builtinValue   = NULL;
    #define CREATE_stream_builtinValue  if (stream_builtinValue == NULL) {stream_builtinValue = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule builtinValue"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:542:8: (bt= builtinValue -> ^( VALUE_NODE ( $bt)? ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:542:12: bt= builtinValue
        {
            FOLLOWPUSH(FOLLOW_builtinValue_in_value6085);
            bt=builtinValue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevalueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_builtinValue; stream_builtinValue->add(stream_builtinValue, bt.tree, NULL); }

             
            /* AST REWRITE
             * elements          : bt
             * token labels      : 
             * rule labels       : retval, bt
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_bt;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_bt=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token bt", bt.tree != NULL ? bt.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 543:1: -> ^( VALUE_NODE ( $bt)? )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:543:4: ^( VALUE_NODE ( $bt)? )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, VALUE_NODE, (pANTLR3_UINT8)"VALUE_NODE"), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:543:17: ( $bt)?
            	        {
            	        	if ( (stream_bt != NULL && stream_bt->hasNext(stream_bt))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_bt == NULL ? NULL : stream_bt->nextTree(stream_bt));

            	        	}
            	        	if ( stream_bt != NULL) stream_bt->reset(stream_bt);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_bt != NULL) stream_bt->free(stream_bt);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevalueEx; /* Prevent compiler warnings */
    rulevalueEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_builtinValue != NULL) stream_builtinValue->free(stream_builtinValue);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(101, value_StartIndex); }

    return retval;
}
/* $ANTLR end value */

/** 
 * $ANTLR start builtinValue
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:545:1: builtinValue : ( enumeratedValue | integerValue | choiceValue | objectIdentifierValue | booleanValue | bitValue );
 */
static asn1Parser_builtinValue_return
builtinValue(pasn1Parser ctx)
{   
    asn1Parser_builtinValue_return retval;
    ANTLR3_UINT32 builtinValue_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_enumeratedValue_return enumeratedValue342;
    #undef	RETURN_TYPE_enumeratedValue342
    #define	RETURN_TYPE_enumeratedValue342 asn1Parser_enumeratedValue_return

    asn1Parser_integerValue_return integerValue343;
    #undef	RETURN_TYPE_integerValue343
    #define	RETURN_TYPE_integerValue343 asn1Parser_integerValue_return

    asn1Parser_choiceValue_return choiceValue344;
    #undef	RETURN_TYPE_choiceValue344
    #define	RETURN_TYPE_choiceValue344 asn1Parser_choiceValue_return

    asn1Parser_objectIdentifierValue_return objectIdentifierValue345;
    #undef	RETURN_TYPE_objectIdentifierValue345
    #define	RETURN_TYPE_objectIdentifierValue345 asn1Parser_objectIdentifierValue_return

    asn1Parser_booleanValue_return booleanValue346;
    #undef	RETURN_TYPE_booleanValue346
    #define	RETURN_TYPE_booleanValue346 asn1Parser_booleanValue_return

    asn1Parser_bitValue_return bitValue347;
    #undef	RETURN_TYPE_bitValue347
    #define	RETURN_TYPE_bitValue347 asn1Parser_bitValue_return


    /* Initialize rule variables
     */
    builtinValue_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(102)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    enumeratedValue342.tree = NULL;

    integerValue343.tree = NULL;

    choiceValue344.tree = NULL;

    objectIdentifierValue345.tree = NULL;

    booleanValue346.tree = NULL;

    bitValue347.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:545:14: ( enumeratedValue | integerValue | choiceValue | objectIdentifierValue | booleanValue | bitValue )
            
            ANTLR3_UINT32 alt117;

            alt117=6;

            switch ( LA(1) ) 
            {
            case IDENTIFIER:
            	{

            		{
            		    int LA117_1 = LA(2);
            		    if ( (LA117_1 == COLON) ) 
            		    {
            		        alt117=3;
            		    }
            		    else if ( (synpred160_asn1(ctx)) ) 
            		    {
            		        alt117=1;
            		    }
            		    else if ( (synpred161_asn1(ctx)) ) 
            		    {
            		        alt117=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 117;
            		        EXCEPTION->state        = 1;


            		        goto rulebuiltinValueEx;
            		    }
            		}
            	}
                break;
            case MINUS:
            case NUMBER:
            	{
            		alt117=2;
            	}
                break;
            case L_BRACE:
            	{
            		alt117=4;
            	}
                break;
            case TRUE_LITERAL:
            case FALSE_LITERAL:
            case TRUE_SMALL_LITERAL:
            case FALSE_SMALL_LITERAL:
            	{
            		alt117=5;
            	}
                break;
            case BSTRING:
            	{
            		alt117=6;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 117;
                EXCEPTION->state        = 0;


                goto rulebuiltinValueEx;
            }

            switch (alt117) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:546:3: enumeratedValue
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_enumeratedValue_in_builtinValue6107);
        	        enumeratedValue342=enumeratedValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinValueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, enumeratedValue342.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:547:4: integerValue
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_integerValue_in_builtinValue6112);
        	        integerValue343=integerValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinValueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, integerValue343.tree);

        	    }
        	    break;
        	case 3:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:548:4: choiceValue
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_choiceValue_in_builtinValue6117);
        	        choiceValue344=choiceValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinValueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, choiceValue344.tree);

        	    }
        	    break;
        	case 4:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:549:4: objectIdentifierValue
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_objectIdentifierValue_in_builtinValue6122);
        	        objectIdentifierValue345=objectIdentifierValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinValueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objectIdentifierValue345.tree);

        	    }
        	    break;
        	case 5:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:550:4: booleanValue
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_booleanValue_in_builtinValue6127);
        	        booleanValue346=booleanValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinValueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, booleanValue346.tree);

        	    }
        	    break;
        	case 6:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:551:4: bitValue
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_bitValue_in_builtinValue6132);
        	        bitValue347=bitValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinValueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, bitValue347.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulebuiltinValueEx; /* Prevent compiler warnings */
    rulebuiltinValueEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(102, builtinValue_StartIndex); }

    return retval;
}
/* $ANTLR end builtinValue */

/** 
 * $ANTLR start objectIdentifierValue
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:555:1: objectIdentifierValue : L_BRACE objIdComponentsList R_BRACE ;
 */
static asn1Parser_objectIdentifierValue_return
objectIdentifierValue(pasn1Parser ctx)
{   
    asn1Parser_objectIdentifierValue_return retval;
    ANTLR3_UINT32 objectIdentifierValue_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    L_BRACE348;
    pANTLR3_COMMON_TOKEN    R_BRACE350;
    asn1Parser_objIdComponentsList_return objIdComponentsList349;
    #undef	RETURN_TYPE_objIdComponentsList349
    #define	RETURN_TYPE_objIdComponentsList349 asn1Parser_objIdComponentsList_return

    pANTLR3_BASE_TREE L_BRACE348_tree;
    pANTLR3_BASE_TREE R_BRACE350_tree;

    /* Initialize rule variables
     */
    objectIdentifierValue_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(103)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    L_BRACE348       = NULL;
    R_BRACE350       = NULL;
    objIdComponentsList349.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    L_BRACE348_tree   = NULL;
    R_BRACE350_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:555:23: ( L_BRACE objIdComponentsList R_BRACE )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:555:25: L_BRACE objIdComponentsList R_BRACE
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            L_BRACE348 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_objectIdentifierValue6145); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectIdentifierValueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_objIdComponentsList_in_objectIdentifierValue6150);
            objIdComponentsList349=objIdComponentsList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleobjectIdentifierValueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objIdComponentsList349.tree);
            R_BRACE350 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_objectIdentifierValue6152); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectIdentifierValueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectIdentifierValueEx; /* Prevent compiler warnings */
    ruleobjectIdentifierValueEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(103, objectIdentifierValue_StartIndex); }

    return retval;
}
/* $ANTLR end objectIdentifierValue */

/** 
 * $ANTLR start objIdComponentsList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:557:1: objIdComponentsList : ( objIdComponents ) ( objIdComponents )* ;
 */
static asn1Parser_objIdComponentsList_return
objIdComponentsList(pasn1Parser ctx)
{   
    asn1Parser_objIdComponentsList_return retval;
    ANTLR3_UINT32 objIdComponentsList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_objIdComponents_return objIdComponents351;
    #undef	RETURN_TYPE_objIdComponents351
    #define	RETURN_TYPE_objIdComponents351 asn1Parser_objIdComponents_return

    asn1Parser_objIdComponents_return objIdComponents352;
    #undef	RETURN_TYPE_objIdComponents352
    #define	RETURN_TYPE_objIdComponents352 asn1Parser_objIdComponents_return


    /* Initialize rule variables
     */
    objIdComponentsList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(104)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    objIdComponents351.tree = NULL;

    objIdComponents352.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:558:2: ( ( objIdComponents ) ( objIdComponents )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:558:5: ( objIdComponents ) ( objIdComponents )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:558:5: ( objIdComponents )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:558:6: objIdComponents
            {
                FOLLOWPUSH(FOLLOW_objIdComponents_in_objIdComponentsList6167);
                objIdComponents351=objIdComponents(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleobjIdComponentsListEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objIdComponents351.tree);

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:558:23: ( objIdComponents )*

            for (;;)
            {
                int alt118=2;
                switch ( LA(1) ) 
                {
                case IDENTIFIER:
                case NUMBER:
                	{
                		alt118=1;
                	}
                    break;

                }

                switch (alt118) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:558:24: objIdComponents
            	    {
            	        FOLLOWPUSH(FOLLOW_objIdComponents_in_objIdComponentsList6171);
            	        objIdComponents352=objIdComponents(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleobjIdComponentsListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, objIdComponents352.tree);

            	    }
            	    break;

            	default:
            	    goto loop118;	/* break out of the loop */
            	    break;
                }
            }
            loop118: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjIdComponentsListEx; /* Prevent compiler warnings */
    ruleobjIdComponentsListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(104, objIdComponentsList_StartIndex); }

    return retval;
}
/* $ANTLR end objIdComponentsList */

/** 
 * $ANTLR start objIdComponents
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:560:1: objIdComponents : ( NUMBER | IDENTIFIER ( L_PARAN ( NUMBER | definedValue ) R_PARAN )? | definedValue );
 */
static asn1Parser_objIdComponents_return
objIdComponents(pasn1Parser ctx)
{   
    asn1Parser_objIdComponents_return retval;
    ANTLR3_UINT32 objIdComponents_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    NUMBER353;
    pANTLR3_COMMON_TOKEN    IDENTIFIER354;
    pANTLR3_COMMON_TOKEN    L_PARAN355;
    pANTLR3_COMMON_TOKEN    NUMBER356;
    pANTLR3_COMMON_TOKEN    R_PARAN358;
    asn1Parser_definedValue_return definedValue357;
    #undef	RETURN_TYPE_definedValue357
    #define	RETURN_TYPE_definedValue357 asn1Parser_definedValue_return

    asn1Parser_definedValue_return definedValue359;
    #undef	RETURN_TYPE_definedValue359
    #define	RETURN_TYPE_definedValue359 asn1Parser_definedValue_return

    pANTLR3_BASE_TREE NUMBER353_tree;
    pANTLR3_BASE_TREE IDENTIFIER354_tree;
    pANTLR3_BASE_TREE L_PARAN355_tree;
    pANTLR3_BASE_TREE NUMBER356_tree;
    pANTLR3_BASE_TREE R_PARAN358_tree;

    /* Initialize rule variables
     */
    objIdComponents_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(105)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    NUMBER353       = NULL;
    IDENTIFIER354       = NULL;
    L_PARAN355       = NULL;
    NUMBER356       = NULL;
    R_PARAN358       = NULL;
    definedValue357.tree = NULL;

    definedValue359.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    NUMBER353_tree   = NULL;
    IDENTIFIER354_tree   = NULL;
    L_PARAN355_tree   = NULL;
    NUMBER356_tree   = NULL;
    R_PARAN358_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:560:18: ( NUMBER | IDENTIFIER ( L_PARAN ( NUMBER | definedValue ) R_PARAN )? | definedValue )
            
            ANTLR3_UINT32 alt121;

            alt121=3;

            switch ( LA(1) ) 
            {
            case NUMBER:
            	{
            		alt121=1;
            	}
                break;
            case IDENTIFIER:
            	{

            		{
            		    int LA121_2 = LA(2);
            		    if ( (synpred169_asn1(ctx)) ) 
            		    {
            		        alt121=2;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt121=3;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 121;
            		        EXCEPTION->state        = 2;


            		        goto ruleobjIdComponentsEx;
            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 121;
                EXCEPTION->state        = 0;


                goto ruleobjIdComponentsEx;
            }

            switch (alt121) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:561:7: NUMBER
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        NUMBER353 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_objIdComponents6189); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjIdComponentsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        NUMBER353_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER353));
        	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER353_tree);
        	        }

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:8: IDENTIFIER ( L_PARAN ( NUMBER | definedValue ) R_PARAN )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        IDENTIFIER354 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_objIdComponents6198); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjIdComponentsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        IDENTIFIER354_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER354));
        	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER354_tree);
        	        }

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:19: ( L_PARAN ( NUMBER | definedValue ) R_PARAN )?
        	        {
        	            int alt120=2;
        	            switch ( LA(1) ) 
        	            {
        	                case L_PARAN:
        	                	{
        	                		alt120=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt120) 
        	            {
        	        	case 1:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:20: L_PARAN ( NUMBER | definedValue ) R_PARAN
        	        	    {
        	        	        L_PARAN355 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_objIdComponents6201); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleobjIdComponentsEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) {
        	        	        L_PARAN355_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, L_PARAN355));
        	        	        ADAPTOR->addChild(ADAPTOR, root_0, L_PARAN355_tree);
        	        	        }

        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:28: ( NUMBER | definedValue )
        	        	        {
        	        	            int alt119=2;
        	        	            switch ( LA(1) ) 
        	        	            {
        	        	            case NUMBER:
        	        	            	{
        	        	            		alt119=1;
        	        	            	}
        	        	                break;
        	        	            case IDENTIFIER:
        	        	            	{
        	        	            		alt119=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (BACKTRACKING>0)
        	        	                {
        	        	                    FAILEDFLAG = ANTLR3_TRUE;
        	        	                    return retval;
        	        	                }
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 119;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleobjIdComponentsEx;
        	        	            }

        	        	            switch (alt119) 
        	        	            {
        	        	        	case 1:
        	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:29: NUMBER
        	        	        	    {
        	        	        	        NUMBER356 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_objIdComponents6204); 
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleobjIdComponentsEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }
        	        	        	        if ( BACKTRACKING==0 ) {
        	        	        	        NUMBER356_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER356));
        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER356_tree);
        	        	        	        }

        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:38: definedValue
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_definedValue_in_objIdComponents6208);
        	        	        	        definedValue357=definedValue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleobjIdComponentsEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }
        	        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedValue357.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }
        	        	        R_PARAN358 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_objIdComponents6212); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleobjIdComponentsEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	        if ( BACKTRACKING==0 ) {
        	        	        R_PARAN358_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, R_PARAN358));
        	        	        ADAPTOR->addChild(ADAPTOR, root_0, R_PARAN358_tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:563:8: definedValue
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_definedValue_in_objIdComponents6223);
        	        definedValue359=definedValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleobjIdComponentsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedValue359.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjIdComponentsEx; /* Prevent compiler warnings */
    ruleobjIdComponentsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(105, objIdComponents_StartIndex); }

    return retval;
}
/* $ANTLR end objIdComponents */

/** 
 * $ANTLR start integerValue
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:567:1: integerValue : ( signedNumber | IDENTIFIER );
 */
static asn1Parser_integerValue_return
integerValue(pasn1Parser ctx)
{   
    asn1Parser_integerValue_return retval;
    ANTLR3_UINT32 integerValue_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER361;
    asn1Parser_signedNumber_return signedNumber360;
    #undef	RETURN_TYPE_signedNumber360
    #define	RETURN_TYPE_signedNumber360 asn1Parser_signedNumber_return

    pANTLR3_BASE_TREE IDENTIFIER361_tree;

    /* Initialize rule variables
     */
    integerValue_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(106)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IDENTIFIER361       = NULL;
    signedNumber360.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER361_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:567:14: ( signedNumber | IDENTIFIER )
            
            ANTLR3_UINT32 alt122;

            alt122=2;

            switch ( LA(1) ) 
            {
            case MINUS:
            case NUMBER:
            	{
            		alt122=1;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt122=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 122;
                EXCEPTION->state        = 0;


                goto ruleintegerValueEx;
            }

            switch (alt122) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:567:17: signedNumber
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_signedNumber_in_integerValue6237);
        	        signedNumber360=signedNumber(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleintegerValueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, signedNumber360.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:567:32: IDENTIFIER
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        IDENTIFIER361 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_integerValue6241); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleintegerValueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        IDENTIFIER361_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER361));
        	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER361_tree);
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleintegerValueEx; /* Prevent compiler warnings */
    ruleintegerValueEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(106, integerValue_StartIndex); }

    return retval;
}
/* $ANTLR end integerValue */

/** 
 * $ANTLR start choiceValue
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:570:1: choiceValue : IDENTIFIER COLON value ;
 */
static asn1Parser_choiceValue_return
choiceValue(pasn1Parser ctx)
{   
    asn1Parser_choiceValue_return retval;
    ANTLR3_UINT32 choiceValue_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER362;
    pANTLR3_COMMON_TOKEN    COLON363;
    asn1Parser_value_return value364;
    #undef	RETURN_TYPE_value364
    #define	RETURN_TYPE_value364 asn1Parser_value_return

    pANTLR3_BASE_TREE IDENTIFIER362_tree;
    pANTLR3_BASE_TREE COLON363_tree;

    /* Initialize rule variables
     */
    choiceValue_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(107)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IDENTIFIER362       = NULL;
    COLON363       = NULL;
    value364.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER362_tree   = NULL;
    COLON363_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:570:14: ( IDENTIFIER COLON value )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:570:19: IDENTIFIER COLON value
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER362 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_choiceValue6261); 
            if  (HASEXCEPTION())
            {
                goto rulechoiceValueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER362_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER362));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER362_tree);
            }
            COLON363 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_choiceValue6263); 
            if  (HASEXCEPTION())
            {
                goto rulechoiceValueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            COLON363_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON363));
            ADAPTOR->addChild(ADAPTOR, root_0, COLON363_tree);
            }
            FOLLOWPUSH(FOLLOW_value_in_choiceValue6265);
            value364=value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulechoiceValueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value364.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulechoiceValueEx; /* Prevent compiler warnings */
    rulechoiceValueEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(107, choiceValue_StartIndex); }

    return retval;
}
/* $ANTLR end choiceValue */

/** 
 * $ANTLR start enumeratedValue
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:572:1: enumeratedValue : IDENTIFIER ;
 */
static asn1Parser_enumeratedValue_return
enumeratedValue(pasn1Parser ctx)
{   
    asn1Parser_enumeratedValue_return retval;
    ANTLR3_UINT32 enumeratedValue_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER365;

    pANTLR3_BASE_TREE IDENTIFIER365_tree;

    /* Initialize rule variables
     */
    enumeratedValue_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(108)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IDENTIFIER365       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER365_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:572:18: ( IDENTIFIER )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:572:20: IDENTIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER365 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumeratedValue6275); 
            if  (HASEXCEPTION())
            {
                goto ruleenumeratedValueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER365_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER365));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER365_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleenumeratedValueEx; /* Prevent compiler warnings */
    ruleenumeratedValueEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(108, enumeratedValue_StartIndex); }

    return retval;
}
/* $ANTLR end enumeratedValue */

/** 
 * $ANTLR start signedNumber
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:575:1: signedNumber : ( MINUS )? NUMBER ;
 */
static asn1Parser_signedNumber_return
signedNumber(pasn1Parser ctx)
{   
    asn1Parser_signedNumber_return retval;
    ANTLR3_UINT32 signedNumber_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    MINUS366;
    pANTLR3_COMMON_TOKEN    NUMBER367;

    pANTLR3_BASE_TREE MINUS366_tree;
    pANTLR3_BASE_TREE NUMBER367_tree;

    /* Initialize rule variables
     */
    signedNumber_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(109)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    MINUS366       = NULL;
    NUMBER367       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    MINUS366_tree   = NULL;
    NUMBER367_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:575:14: ( ( MINUS )? NUMBER )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:575:17: ( MINUS )? NUMBER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:575:17: ( MINUS )?
            {
                int alt123=2;
                switch ( LA(1) ) 
                {
                    case MINUS:
                    	{
                    		alt123=1;
                    	}
                        break;
                }

                switch (alt123) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:575:18: MINUS
            	    {
            	        MINUS366 = (pANTLR3_COMMON_TOKEN) MATCHT(MINUS, &FOLLOW_MINUS_in_signedNumber6287); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesignedNumberEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        MINUS366_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, MINUS366));
            	        ADAPTOR->addChild(ADAPTOR, root_0, MINUS366_tree);
            	        }

            	    }
            	    break;

                }
            }
            NUMBER367 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_signedNumber6291); 
            if  (HASEXCEPTION())
            {
                goto rulesignedNumberEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            NUMBER367_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER367));
            ADAPTOR->addChild(ADAPTOR, root_0, NUMBER367_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesignedNumberEx; /* Prevent compiler warnings */
    rulesignedNumberEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(109, signedNumber_StartIndex); }

    return retval;
}
/* $ANTLR end signedNumber */

/** 
 * $ANTLR start choiceType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:577:1: choiceType : CHOICE_LITERAL L_BRACE alternativeTypeLists R_BRACE -> ^( CHOICE_LITERAL alternativeTypeLists ) ;
 */
static asn1Parser_choiceType_return
choiceType(pasn1Parser ctx)
{   
    asn1Parser_choiceType_return retval;
    ANTLR3_UINT32 choiceType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    CHOICE_LITERAL368;
    pANTLR3_COMMON_TOKEN    L_BRACE369;
    pANTLR3_COMMON_TOKEN    R_BRACE371;
    asn1Parser_alternativeTypeLists_return alternativeTypeLists370;
    #undef	RETURN_TYPE_alternativeTypeLists370
    #define	RETURN_TYPE_alternativeTypeLists370 asn1Parser_alternativeTypeLists_return

    pANTLR3_BASE_TREE CHOICE_LITERAL368_tree;
    pANTLR3_BASE_TREE L_BRACE369_tree;
    pANTLR3_BASE_TREE R_BRACE371_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_CHOICE_LITERAL;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_alternativeTypeLists;
    /* Initialize rule variables
     */
    choiceType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(110)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    CHOICE_LITERAL368       = NULL;
    L_BRACE369       = NULL;
    R_BRACE371       = NULL;
    alternativeTypeLists370.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    CHOICE_LITERAL368_tree   = NULL;
    L_BRACE369_tree   = NULL;
    R_BRACE371_tree   = NULL;

    stream_L_BRACE   = NULL;
    #define CREATE_stream_L_BRACE  if (stream_L_BRACE == NULL) {stream_L_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_BRACE"); } 
    stream_R_BRACE   = NULL;
    #define CREATE_stream_R_BRACE  if (stream_R_BRACE == NULL) {stream_R_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_BRACE"); } 
    stream_CHOICE_LITERAL   = NULL;
    #define CREATE_stream_CHOICE_LITERAL  if (stream_CHOICE_LITERAL == NULL) {stream_CHOICE_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token CHOICE_LITERAL"); } 
    stream_alternativeTypeLists   = NULL;
    #define CREATE_stream_alternativeTypeLists  if (stream_alternativeTypeLists == NULL) {stream_alternativeTypeLists = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule alternativeTypeLists"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:577:15: ( CHOICE_LITERAL L_BRACE alternativeTypeLists R_BRACE -> ^( CHOICE_LITERAL alternativeTypeLists ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:577:17: CHOICE_LITERAL L_BRACE alternativeTypeLists R_BRACE
        {
            CHOICE_LITERAL368 = (pANTLR3_COMMON_TOKEN) MATCHT(CHOICE_LITERAL, &FOLLOW_CHOICE_LITERAL_in_choiceType6302); 
            if  (HASEXCEPTION())
            {
                goto rulechoiceTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_CHOICE_LITERAL; stream_CHOICE_LITERAL->add(stream_CHOICE_LITERAL, CHOICE_LITERAL368, NULL); }

            L_BRACE369 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_choiceType6304); 
            if  (HASEXCEPTION())
            {
                goto rulechoiceTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_L_BRACE; stream_L_BRACE->add(stream_L_BRACE, L_BRACE369, NULL); }

            FOLLOWPUSH(FOLLOW_alternativeTypeLists_in_choiceType6306);
            alternativeTypeLists370=alternativeTypeLists(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulechoiceTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_alternativeTypeLists; stream_alternativeTypeLists->add(stream_alternativeTypeLists, alternativeTypeLists370.tree, NULL); }
            R_BRACE371 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_choiceType6308); 
            if  (HASEXCEPTION())
            {
                goto rulechoiceTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_R_BRACE; stream_R_BRACE->add(stream_R_BRACE, R_BRACE371, NULL); }


             
            /* AST REWRITE
             * elements          : alternativeTypeLists, CHOICE_LITERAL
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 577:69: -> ^( CHOICE_LITERAL alternativeTypeLists )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:577:72: ^( CHOICE_LITERAL alternativeTypeLists )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_CHOICE_LITERAL == NULL ? NULL : stream_CHOICE_LITERAL->nextNode(stream_CHOICE_LITERAL), root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_alternativeTypeLists == NULL ? NULL : stream_alternativeTypeLists->nextTree(stream_alternativeTypeLists));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulechoiceTypeEx; /* Prevent compiler warnings */
    rulechoiceTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_L_BRACE != NULL) stream_L_BRACE->free(stream_L_BRACE);
        if (stream_R_BRACE != NULL) stream_R_BRACE->free(stream_R_BRACE);
        if (stream_CHOICE_LITERAL != NULL) stream_CHOICE_LITERAL->free(stream_CHOICE_LITERAL);
        if (stream_alternativeTypeLists != NULL) stream_alternativeTypeLists->free(stream_alternativeTypeLists);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(110, choiceType_StartIndex); }

    return retval;
}
/* $ANTLR end choiceType */

/** 
 * $ANTLR start alternativeTypeLists
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:579:1: alternativeTypeLists : rootAlternativeTypeList ( COMMA extensionAndException extensionAdditionAlternatives optionalExtensionMarker )? ;
 */
static asn1Parser_alternativeTypeLists_return
alternativeTypeLists(pasn1Parser ctx)
{   
    asn1Parser_alternativeTypeLists_return retval;
    ANTLR3_UINT32 alternativeTypeLists_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA373;
    asn1Parser_rootAlternativeTypeList_return rootAlternativeTypeList372;
    #undef	RETURN_TYPE_rootAlternativeTypeList372
    #define	RETURN_TYPE_rootAlternativeTypeList372 asn1Parser_rootAlternativeTypeList_return

    asn1Parser_extensionAndException_return extensionAndException374;
    #undef	RETURN_TYPE_extensionAndException374
    #define	RETURN_TYPE_extensionAndException374 asn1Parser_extensionAndException_return

    asn1Parser_extensionAdditionAlternatives_return extensionAdditionAlternatives375;
    #undef	RETURN_TYPE_extensionAdditionAlternatives375
    #define	RETURN_TYPE_extensionAdditionAlternatives375 asn1Parser_extensionAdditionAlternatives_return

    asn1Parser_optionalExtensionMarker_return optionalExtensionMarker376;
    #undef	RETURN_TYPE_optionalExtensionMarker376
    #define	RETURN_TYPE_optionalExtensionMarker376 asn1Parser_optionalExtensionMarker_return

    pANTLR3_BASE_TREE COMMA373_tree;

    /* Initialize rule variables
     */
    alternativeTypeLists_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(111)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA373       = NULL;
    rootAlternativeTypeList372.tree = NULL;

    extensionAndException374.tree = NULL;

    extensionAdditionAlternatives375.tree = NULL;

    optionalExtensionMarker376.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA373_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:579:22: ( rootAlternativeTypeList ( COMMA extensionAndException extensionAdditionAlternatives optionalExtensionMarker )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:579:26: rootAlternativeTypeList ( COMMA extensionAndException extensionAdditionAlternatives optionalExtensionMarker )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_rootAlternativeTypeList_in_alternativeTypeLists6326);
            rootAlternativeTypeList372=rootAlternativeTypeList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulealternativeTypeListsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rootAlternativeTypeList372.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:579:50: ( COMMA extensionAndException extensionAdditionAlternatives optionalExtensionMarker )?
            {
                int alt124=2;
                switch ( LA(1) ) 
                {
                    case COMMA:
                    	{
                    		alt124=1;
                    	}
                        break;
                }

                switch (alt124) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:579:51: COMMA extensionAndException extensionAdditionAlternatives optionalExtensionMarker
            	    {
            	        COMMA373 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_alternativeTypeLists6329); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealternativeTypeListsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_extensionAndException_in_alternativeTypeLists6336);
            	        extensionAndException374=extensionAndException(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealternativeTypeListsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAndException374.tree);
            	        FOLLOWPUSH(FOLLOW_extensionAdditionAlternatives_in_alternativeTypeLists6339);
            	        extensionAdditionAlternatives375=extensionAdditionAlternatives(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealternativeTypeListsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAdditionAlternatives375.tree);
            	        FOLLOWPUSH(FOLLOW_optionalExtensionMarker_in_alternativeTypeLists6342);
            	        optionalExtensionMarker376=optionalExtensionMarker(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealternativeTypeListsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, optionalExtensionMarker376.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulealternativeTypeListsEx; /* Prevent compiler warnings */
    rulealternativeTypeListsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(111, alternativeTypeLists_StartIndex); }

    return retval;
}
/* $ANTLR end alternativeTypeLists */

/** 
 * $ANTLR start extensionAdditionAlternatives
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:582:1: extensionAdditionAlternatives : ( COMMA extensionAdditionAlternativesList )? ;
 */
static asn1Parser_extensionAdditionAlternatives_return
extensionAdditionAlternatives(pasn1Parser ctx)
{   
    asn1Parser_extensionAdditionAlternatives_return retval;
    ANTLR3_UINT32 extensionAdditionAlternatives_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA377;
    asn1Parser_extensionAdditionAlternativesList_return extensionAdditionAlternativesList378;
    #undef	RETURN_TYPE_extensionAdditionAlternativesList378
    #define	RETURN_TYPE_extensionAdditionAlternativesList378 asn1Parser_extensionAdditionAlternativesList_return

    pANTLR3_BASE_TREE COMMA377_tree;

    /* Initialize rule variables
     */
    extensionAdditionAlternatives_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(112)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA377       = NULL;
    extensionAdditionAlternativesList378.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA377_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:582:32: ( ( COMMA extensionAdditionAlternativesList )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:582:34: ( COMMA extensionAdditionAlternativesList )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:582:34: ( COMMA extensionAdditionAlternativesList )?
            {
                int alt125=2;
                switch ( LA(1) ) 
                {
                    case COMMA:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		    case DOUBLE_L_BRACKET:
                    		    case IDENTIFIER:
                    		    	{
                    		    		alt125=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt125) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:582:35: COMMA extensionAdditionAlternativesList
            	    {
            	        COMMA377 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_extensionAdditionAlternatives6357); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAdditionAlternativesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_extensionAdditionAlternativesList_in_extensionAdditionAlternatives6361);
            	        extensionAdditionAlternativesList378=extensionAdditionAlternativesList(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAdditionAlternativesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAdditionAlternativesList378.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextensionAdditionAlternativesEx; /* Prevent compiler warnings */
    ruleextensionAdditionAlternativesEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(112, extensionAdditionAlternatives_StartIndex); }

    return retval;
}
/* $ANTLR end extensionAdditionAlternatives */

/** 
 * $ANTLR start extensionAdditionAlternativesList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:584:1: extensionAdditionAlternativesList : ( extensionAdditionAlternative ) ( COMMA extensionAdditionAlternative )* ;
 */
static asn1Parser_extensionAdditionAlternativesList_return
extensionAdditionAlternativesList(pasn1Parser ctx)
{   
    asn1Parser_extensionAdditionAlternativesList_return retval;
    ANTLR3_UINT32 extensionAdditionAlternativesList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA380;
    asn1Parser_extensionAdditionAlternative_return extensionAdditionAlternative379;
    #undef	RETURN_TYPE_extensionAdditionAlternative379
    #define	RETURN_TYPE_extensionAdditionAlternative379 asn1Parser_extensionAdditionAlternative_return

    asn1Parser_extensionAdditionAlternative_return extensionAdditionAlternative381;
    #undef	RETURN_TYPE_extensionAdditionAlternative381
    #define	RETURN_TYPE_extensionAdditionAlternative381 asn1Parser_extensionAdditionAlternative_return

    pANTLR3_BASE_TREE COMMA380_tree;

    /* Initialize rule variables
     */
    extensionAdditionAlternativesList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(113)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA380       = NULL;
    extensionAdditionAlternative379.tree = NULL;

    extensionAdditionAlternative381.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA380_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:584:36: ( ( extensionAdditionAlternative ) ( COMMA extensionAdditionAlternative )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:584:38: ( extensionAdditionAlternative ) ( COMMA extensionAdditionAlternative )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:584:38: ( extensionAdditionAlternative )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:584:39: extensionAdditionAlternative
            {
                FOLLOWPUSH(FOLLOW_extensionAdditionAlternative_in_extensionAdditionAlternativesList6375);
                extensionAdditionAlternative379=extensionAdditionAlternative(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleextensionAdditionAlternativesListEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAdditionAlternative379.tree);

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:584:69: ( COMMA extensionAdditionAlternative )*

            for (;;)
            {
                int alt126=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		switch ( LA(2) ) 
                		{
                		case DOUBLE_L_BRACKET:
                		case IDENTIFIER:
                			{
                				alt126=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt126) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:584:70: COMMA extensionAdditionAlternative
            	    {
            	        COMMA380 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_extensionAdditionAlternativesList6379); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAdditionAlternativesListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        COMMA380_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA380));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA380_tree);
            	        }
            	        FOLLOWPUSH(FOLLOW_extensionAdditionAlternative_in_extensionAdditionAlternativesList6382);
            	        extensionAdditionAlternative381=extensionAdditionAlternative(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAdditionAlternativesListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAdditionAlternative381.tree);

            	    }
            	    break;

            	default:
            	    goto loop126;	/* break out of the loop */
            	    break;
                }
            }
            loop126: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextensionAdditionAlternativesListEx; /* Prevent compiler warnings */
    ruleextensionAdditionAlternativesListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(113, extensionAdditionAlternativesList_StartIndex); }

    return retval;
}
/* $ANTLR end extensionAdditionAlternativesList */

/** 
 * $ANTLR start extensionAdditionAlternative
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:586:1: extensionAdditionAlternative : ( extensionAdditionAlternativesGroup | namedType );
 */
static asn1Parser_extensionAdditionAlternative_return
extensionAdditionAlternative(pasn1Parser ctx)
{   
    asn1Parser_extensionAdditionAlternative_return retval;
    ANTLR3_UINT32 extensionAdditionAlternative_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_extensionAdditionAlternativesGroup_return extensionAdditionAlternativesGroup382;
    #undef	RETURN_TYPE_extensionAdditionAlternativesGroup382
    #define	RETURN_TYPE_extensionAdditionAlternativesGroup382 asn1Parser_extensionAdditionAlternativesGroup_return

    asn1Parser_namedType_return namedType383;
    #undef	RETURN_TYPE_namedType383
    #define	RETURN_TYPE_namedType383 asn1Parser_namedType_return


    /* Initialize rule variables
     */
    extensionAdditionAlternative_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(114)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    extensionAdditionAlternativesGroup382.tree = NULL;

    namedType383.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:586:31: ( extensionAdditionAlternativesGroup | namedType )
            
            ANTLR3_UINT32 alt127;

            alt127=2;

            switch ( LA(1) ) 
            {
            case DOUBLE_L_BRACKET:
            	{
            		alt127=1;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt127=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 127;
                EXCEPTION->state        = 0;


                goto ruleextensionAdditionAlternativeEx;
            }

            switch (alt127) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:586:34: extensionAdditionAlternativesGroup
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_extensionAdditionAlternativesGroup_in_extensionAdditionAlternative6395);
        	        extensionAdditionAlternativesGroup382=extensionAdditionAlternativesGroup(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionAdditionAlternativeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, extensionAdditionAlternativesGroup382.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:586:71: namedType
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_namedType_in_extensionAdditionAlternative6399);
        	        namedType383=namedType(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionAdditionAlternativeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, namedType383.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleextensionAdditionAlternativeEx; /* Prevent compiler warnings */
    ruleextensionAdditionAlternativeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(114, extensionAdditionAlternative_StartIndex); }

    return retval;
}
/* $ANTLR end extensionAdditionAlternative */

/** 
 * $ANTLR start extensionAdditionAlternativesGroup
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:588:1: extensionAdditionAlternativesGroup : DOUBLE_L_BRACKET versionNumber alternativeTypeList DOUBLE_R_BRACKET ;
 */
static asn1Parser_extensionAdditionAlternativesGroup_return
extensionAdditionAlternativesGroup(pasn1Parser ctx)
{   
    asn1Parser_extensionAdditionAlternativesGroup_return retval;
    ANTLR3_UINT32 extensionAdditionAlternativesGroup_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DOUBLE_L_BRACKET384;
    pANTLR3_COMMON_TOKEN    DOUBLE_R_BRACKET387;
    asn1Parser_versionNumber_return versionNumber385;
    #undef	RETURN_TYPE_versionNumber385
    #define	RETURN_TYPE_versionNumber385 asn1Parser_versionNumber_return

    asn1Parser_alternativeTypeList_return alternativeTypeList386;
    #undef	RETURN_TYPE_alternativeTypeList386
    #define	RETURN_TYPE_alternativeTypeList386 asn1Parser_alternativeTypeList_return

    pANTLR3_BASE_TREE DOUBLE_L_BRACKET384_tree;
    pANTLR3_BASE_TREE DOUBLE_R_BRACKET387_tree;

    /* Initialize rule variables
     */
    extensionAdditionAlternativesGroup_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(115)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    DOUBLE_L_BRACKET384       = NULL;
    DOUBLE_R_BRACKET387       = NULL;
    versionNumber385.tree = NULL;

    alternativeTypeList386.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    DOUBLE_L_BRACKET384_tree   = NULL;
    DOUBLE_R_BRACKET387_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:588:37: ( DOUBLE_L_BRACKET versionNumber alternativeTypeList DOUBLE_R_BRACKET )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:588:40: DOUBLE_L_BRACKET versionNumber alternativeTypeList DOUBLE_R_BRACKET
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            DOUBLE_L_BRACKET384 = (pANTLR3_COMMON_TOKEN) MATCHT(DOUBLE_L_BRACKET, &FOLLOW_DOUBLE_L_BRACKET_in_extensionAdditionAlternativesGroup6410); 
            if  (HASEXCEPTION())
            {
                goto ruleextensionAdditionAlternativesGroupEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            DOUBLE_L_BRACKET384_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOUBLE_L_BRACKET384));
            ADAPTOR->addChild(ADAPTOR, root_0, DOUBLE_L_BRACKET384_tree);
            }
            FOLLOWPUSH(FOLLOW_versionNumber_in_extensionAdditionAlternativesGroup6413);
            versionNumber385=versionNumber(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionAdditionAlternativesGroupEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, versionNumber385.tree);
            FOLLOWPUSH(FOLLOW_alternativeTypeList_in_extensionAdditionAlternativesGroup6416);
            alternativeTypeList386=alternativeTypeList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionAdditionAlternativesGroupEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alternativeTypeList386.tree);
            DOUBLE_R_BRACKET387 = (pANTLR3_COMMON_TOKEN) MATCHT(DOUBLE_R_BRACKET, &FOLLOW_DOUBLE_R_BRACKET_in_extensionAdditionAlternativesGroup6419); 
            if  (HASEXCEPTION())
            {
                goto ruleextensionAdditionAlternativesGroupEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            DOUBLE_R_BRACKET387_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOUBLE_R_BRACKET387));
            ADAPTOR->addChild(ADAPTOR, root_0, DOUBLE_R_BRACKET387_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextensionAdditionAlternativesGroupEx; /* Prevent compiler warnings */
    ruleextensionAdditionAlternativesGroupEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(115, extensionAdditionAlternativesGroup_StartIndex); }

    return retval;
}
/* $ANTLR end extensionAdditionAlternativesGroup */

/** 
 * $ANTLR start rootAlternativeTypeList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:591:1: rootAlternativeTypeList : alternativeTypeList ;
 */
static asn1Parser_rootAlternativeTypeList_return
rootAlternativeTypeList(pasn1Parser ctx)
{   
    asn1Parser_rootAlternativeTypeList_return retval;
    ANTLR3_UINT32 rootAlternativeTypeList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_alternativeTypeList_return alternativeTypeList388;
    #undef	RETURN_TYPE_alternativeTypeList388
    #define	RETURN_TYPE_alternativeTypeList388 asn1Parser_alternativeTypeList_return


    /* Initialize rule variables
     */
    rootAlternativeTypeList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(116)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    alternativeTypeList388.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:591:26: ( alternativeTypeList )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:591:28: alternativeTypeList
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_alternativeTypeList_in_rootAlternativeTypeList6430);
            alternativeTypeList388=alternativeTypeList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerootAlternativeTypeListEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alternativeTypeList388.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerootAlternativeTypeListEx; /* Prevent compiler warnings */
    rulerootAlternativeTypeListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(116, rootAlternativeTypeList_StartIndex); }

    return retval;
}
/* $ANTLR end rootAlternativeTypeList */

/** 
 * $ANTLR start alternativeTypeList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:593:1: alternativeTypeList : ( namedType ) ( COMMA namedType )* ;
 */
static asn1Parser_alternativeTypeList_return
alternativeTypeList(pasn1Parser ctx)
{   
    asn1Parser_alternativeTypeList_return retval;
    ANTLR3_UINT32 alternativeTypeList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA390;
    asn1Parser_namedType_return namedType389;
    #undef	RETURN_TYPE_namedType389
    #define	RETURN_TYPE_namedType389 asn1Parser_namedType_return

    asn1Parser_namedType_return namedType391;
    #undef	RETURN_TYPE_namedType391
    #define	RETURN_TYPE_namedType391 asn1Parser_namedType_return

    pANTLR3_BASE_TREE COMMA390_tree;

    /* Initialize rule variables
     */
    alternativeTypeList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(117)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA390       = NULL;
    namedType389.tree = NULL;

    namedType391.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA390_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:593:21: ( ( namedType ) ( COMMA namedType )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:593:23: ( namedType ) ( COMMA namedType )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:593:23: ( namedType )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:593:24: namedType
            {
                FOLLOWPUSH(FOLLOW_namedType_in_alternativeTypeList6439);
                namedType389=namedType(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulealternativeTypeListEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, namedType389.tree);

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:593:35: ( COMMA namedType )*

            for (;;)
            {
                int alt128=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		switch ( LA(2) ) 
                		{
                		case IDENTIFIER:
                			{
                				alt128=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt128) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:593:36: COMMA namedType
            	    {
            	        COMMA390 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_alternativeTypeList6443); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealternativeTypeListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_namedType_in_alternativeTypeList6446);
            	        namedType391=namedType(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealternativeTypeListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, namedType391.tree);

            	    }
            	    break;

            	default:
            	    goto loop128;	/* break out of the loop */
            	    break;
                }
            }
            loop128: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulealternativeTypeListEx; /* Prevent compiler warnings */
    rulealternativeTypeListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(117, alternativeTypeList_StartIndex); }

    return retval;
}
/* $ANTLR end alternativeTypeList */

/** 
 * $ANTLR start namedType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:595:1: namedType : id= IDENTIFIER t= type -> ^( NODE_INFO ^( $id $t) ) ;
 */
static asn1Parser_namedType_return
namedType(pasn1Parser ctx)
{   
    asn1Parser_namedType_return retval;
    ANTLR3_UINT32 namedType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    id;
    asn1Parser_type_return t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t asn1Parser_type_return

    pANTLR3_BASE_TREE id_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_type;
    /* Initialize rule variables
     */
    namedType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(118)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    id       = NULL;
    t.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    id_tree   = NULL;

    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_type   = NULL;
    #define CREATE_stream_type  if (stream_type == NULL) {stream_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule type"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:595:11: (id= IDENTIFIER t= type -> ^( NODE_INFO ^( $id $t) ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:595:13: id= IDENTIFIER t= type
        {
            id = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_namedType6459); 
            if  (HASEXCEPTION())
            {
                goto rulenamedTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, id, NULL); }

            FOLLOWPUSH(FOLLOW_type_in_namedType6465);
            t=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenamedTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_type; stream_type->add(stream_type, t.tree, NULL); }

             
            /* AST REWRITE
             * elements          : t, id
             * token labels      : id
             * rule labels       : retval, t
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_id;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_t;

            	stream_id=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token id", id);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_t=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token t", t.tree != NULL ? t.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 595:36: -> ^( NODE_INFO ^( $id $t) )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:595:39: ^( NODE_INFO ^( $id $t) )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NODE_INFO, (pANTLR3_UINT8)"NODE_INFO"), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:595:51: ^( $id $t)
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRootToken(ADAPTOR, stream_id == NULL ? NULL : stream_id->nextToken(stream_id), root_2));

            	            ADAPTOR->addChild(ADAPTOR, root_2, stream_t == NULL ? NULL : stream_t->nextTree(stream_t));

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_id != NULL) stream_id->free(stream_id); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_t != NULL) stream_t->free(stream_t);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenamedTypeEx; /* Prevent compiler warnings */
    rulenamedTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_type != NULL) stream_type->free(stream_type);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(118, namedType_StartIndex); }

    return retval;
}
/* $ANTLR end namedType */

/** 
 * $ANTLR start enumeratedType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:597:1: enumeratedType : ENUMERATED_LITERAL L_BRACE en= enumerations R_BRACE -> ^( ENUMERATED_LITERAL $en) ;
 */
static asn1Parser_enumeratedType_return
enumeratedType(pasn1Parser ctx)
{   
    asn1Parser_enumeratedType_return retval;
    ANTLR3_UINT32 enumeratedType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ENUMERATED_LITERAL392;
    pANTLR3_COMMON_TOKEN    L_BRACE393;
    pANTLR3_COMMON_TOKEN    R_BRACE394;
    asn1Parser_enumerations_return en;
    #undef	RETURN_TYPE_en
    #define	RETURN_TYPE_en asn1Parser_enumerations_return

    pANTLR3_BASE_TREE ENUMERATED_LITERAL392_tree;
    pANTLR3_BASE_TREE L_BRACE393_tree;
    pANTLR3_BASE_TREE R_BRACE394_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ENUMERATED_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_BRACE;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_enumerations;
    /* Initialize rule variables
     */
    enumeratedType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(119)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    ENUMERATED_LITERAL392       = NULL;
    L_BRACE393       = NULL;
    R_BRACE394       = NULL;
    en.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    ENUMERATED_LITERAL392_tree   = NULL;
    L_BRACE393_tree   = NULL;
    R_BRACE394_tree   = NULL;

    stream_L_BRACE   = NULL;
    #define CREATE_stream_L_BRACE  if (stream_L_BRACE == NULL) {stream_L_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_BRACE"); } 
    stream_ENUMERATED_LITERAL   = NULL;
    #define CREATE_stream_ENUMERATED_LITERAL  if (stream_ENUMERATED_LITERAL == NULL) {stream_ENUMERATED_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ENUMERATED_LITERAL"); } 
    stream_R_BRACE   = NULL;
    #define CREATE_stream_R_BRACE  if (stream_R_BRACE == NULL) {stream_R_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_BRACE"); } 
    stream_enumerations   = NULL;
    #define CREATE_stream_enumerations  if (stream_enumerations == NULL) {stream_enumerations = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule enumerations"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:597:16: ( ENUMERATED_LITERAL L_BRACE en= enumerations R_BRACE -> ^( ENUMERATED_LITERAL $en) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:597:18: ENUMERATED_LITERAL L_BRACE en= enumerations R_BRACE
        {
            ENUMERATED_LITERAL392 = (pANTLR3_COMMON_TOKEN) MATCHT(ENUMERATED_LITERAL, &FOLLOW_ENUMERATED_LITERAL_in_enumeratedType6489); 
            if  (HASEXCEPTION())
            {
                goto ruleenumeratedTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_ENUMERATED_LITERAL; stream_ENUMERATED_LITERAL->add(stream_ENUMERATED_LITERAL, ENUMERATED_LITERAL392, NULL); }

            L_BRACE393 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_enumeratedType6491); 
            if  (HASEXCEPTION())
            {
                goto ruleenumeratedTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_L_BRACE; stream_L_BRACE->add(stream_L_BRACE, L_BRACE393, NULL); }

            FOLLOWPUSH(FOLLOW_enumerations_in_enumeratedType6495);
            en=enumerations(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleenumeratedTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_enumerations; stream_enumerations->add(stream_enumerations, en.tree, NULL); }
            R_BRACE394 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_enumeratedType6497); 
            if  (HASEXCEPTION())
            {
                goto ruleenumeratedTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_R_BRACE; stream_R_BRACE->add(stream_R_BRACE, R_BRACE394, NULL); }


             
            /* AST REWRITE
             * elements          : en, ENUMERATED_LITERAL
             * token labels      : 
             * rule labels       : retval, en
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_en;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_en=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token en", en.tree != NULL ? en.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 597:69: -> ^( ENUMERATED_LITERAL $en)
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:597:72: ^( ENUMERATED_LITERAL $en)
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_ENUMERATED_LITERAL == NULL ? NULL : stream_ENUMERATED_LITERAL->nextNode(stream_ENUMERATED_LITERAL), root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_en == NULL ? NULL : stream_en->nextTree(stream_en));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_en != NULL) stream_en->free(stream_en);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleenumeratedTypeEx; /* Prevent compiler warnings */
    ruleenumeratedTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_L_BRACE != NULL) stream_L_BRACE->free(stream_L_BRACE);
        if (stream_ENUMERATED_LITERAL != NULL) stream_ENUMERATED_LITERAL->free(stream_ENUMERATED_LITERAL);
        if (stream_R_BRACE != NULL) stream_R_BRACE->free(stream_R_BRACE);
        if (stream_enumerations != NULL) stream_enumerations->free(stream_enumerations);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(119, enumeratedType_StartIndex); }

    return retval;
}
/* $ANTLR end enumeratedType */

/** 
 * $ANTLR start enumerations
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:599:1: enumerations : rootEnumeration ( COMMA ELLIPSIS exceptionSpec ( COMMA additionalEnumeration )? )? ;
 */
static asn1Parser_enumerations_return
enumerations(pasn1Parser ctx)
{   
    asn1Parser_enumerations_return retval;
    ANTLR3_UINT32 enumerations_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA396;
    pANTLR3_COMMON_TOKEN    ELLIPSIS397;
    pANTLR3_COMMON_TOKEN    COMMA399;
    asn1Parser_rootEnumeration_return rootEnumeration395;
    #undef	RETURN_TYPE_rootEnumeration395
    #define	RETURN_TYPE_rootEnumeration395 asn1Parser_rootEnumeration_return

    asn1Parser_exceptionSpec_return exceptionSpec398;
    #undef	RETURN_TYPE_exceptionSpec398
    #define	RETURN_TYPE_exceptionSpec398 asn1Parser_exceptionSpec_return

    asn1Parser_additionalEnumeration_return additionalEnumeration400;
    #undef	RETURN_TYPE_additionalEnumeration400
    #define	RETURN_TYPE_additionalEnumeration400 asn1Parser_additionalEnumeration_return

    pANTLR3_BASE_TREE COMMA396_tree;
    pANTLR3_BASE_TREE ELLIPSIS397_tree;
    pANTLR3_BASE_TREE COMMA399_tree;

    /* Initialize rule variables
     */
    enumerations_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(120)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA396       = NULL;
    ELLIPSIS397       = NULL;
    COMMA399       = NULL;
    rootEnumeration395.tree = NULL;

    exceptionSpec398.tree = NULL;

    additionalEnumeration400.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA396_tree   = NULL;
    ELLIPSIS397_tree   = NULL;
    COMMA399_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:599:14: ( rootEnumeration ( COMMA ELLIPSIS exceptionSpec ( COMMA additionalEnumeration )? )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:599:15: rootEnumeration ( COMMA ELLIPSIS exceptionSpec ( COMMA additionalEnumeration )? )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_rootEnumeration_in_enumerations6513);
            rootEnumeration395=rootEnumeration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleenumerationsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rootEnumeration395.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:599:31: ( COMMA ELLIPSIS exceptionSpec ( COMMA additionalEnumeration )? )?
            {
                int alt130=2;
                switch ( LA(1) ) 
                {
                    case COMMA:
                    	{
                    		alt130=1;
                    	}
                        break;
                }

                switch (alt130) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:599:32: COMMA ELLIPSIS exceptionSpec ( COMMA additionalEnumeration )?
            	    {
            	        COMMA396 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_enumerations6516); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleenumerationsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        ELLIPSIS397 = (pANTLR3_COMMON_TOKEN) MATCHT(ELLIPSIS, &FOLLOW_ELLIPSIS_in_enumerations6521); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleenumerationsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_exceptionSpec_in_enumerations6524);
            	        exceptionSpec398=exceptionSpec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleenumerationsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, exceptionSpec398.tree);

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:599:65: ( COMMA additionalEnumeration )?
            	        {
            	            int alt129=2;
            	            switch ( LA(1) ) 
            	            {
            	                case COMMA:
            	                	{
            	                		alt129=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt129) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:599:66: COMMA additionalEnumeration
            	        	    {
            	        	        COMMA399 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_enumerations6527); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleenumerationsEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        FOLLOWPUSH(FOLLOW_additionalEnumeration_in_enumerations6532);
            	        	        additionalEnumeration400=additionalEnumeration(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleenumerationsEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, additionalEnumeration400.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleenumerationsEx; /* Prevent compiler warnings */
    ruleenumerationsEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(120, enumerations_StartIndex); }

    return retval;
}
/* $ANTLR end enumerations */

/** 
 * $ANTLR start rootEnumeration
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:601:1: rootEnumeration : enumeration ;
 */
static asn1Parser_rootEnumeration_return
rootEnumeration(pasn1Parser ctx)
{   
    asn1Parser_rootEnumeration_return retval;
    ANTLR3_UINT32 rootEnumeration_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_enumeration_return enumeration401;
    #undef	RETURN_TYPE_enumeration401
    #define	RETURN_TYPE_enumeration401 asn1Parser_enumeration_return


    /* Initialize rule variables
     */
    rootEnumeration_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(121)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    enumeration401.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:601:17: ( enumeration )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:601:19: enumeration
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_enumeration_in_rootEnumeration6546);
            enumeration401=enumeration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerootEnumerationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, enumeration401.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerootEnumerationEx; /* Prevent compiler warnings */
    rulerootEnumerationEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(121, rootEnumeration_StartIndex); }

    return retval;
}
/* $ANTLR end rootEnumeration */

/** 
 * $ANTLR start enumeration
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:603:1: enumeration : enumerationItem ( COMMA enumerationItem )* ;
 */
static asn1Parser_enumeration_return
enumeration(pasn1Parser ctx)
{   
    asn1Parser_enumeration_return retval;
    ANTLR3_UINT32 enumeration_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA403;
    asn1Parser_enumerationItem_return enumerationItem402;
    #undef	RETURN_TYPE_enumerationItem402
    #define	RETURN_TYPE_enumerationItem402 asn1Parser_enumerationItem_return

    asn1Parser_enumerationItem_return enumerationItem404;
    #undef	RETURN_TYPE_enumerationItem404
    #define	RETURN_TYPE_enumerationItem404 asn1Parser_enumerationItem_return

    pANTLR3_BASE_TREE COMMA403_tree;

    /* Initialize rule variables
     */
    enumeration_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(122)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA403       = NULL;
    enumerationItem402.tree = NULL;

    enumerationItem404.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA403_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:603:13: ( enumerationItem ( COMMA enumerationItem )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:603:15: enumerationItem ( COMMA enumerationItem )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_enumerationItem_in_enumeration6554);
            enumerationItem402=enumerationItem(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleenumerationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, enumerationItem402.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:603:31: ( COMMA enumerationItem )*

            for (;;)
            {
                int alt131=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		switch ( LA(2) ) 
                		{
                		case TRUE_LITERAL:
                		case FALSE_LITERAL:
                		case TRUE_SMALL_LITERAL:
                		case FALSE_SMALL_LITERAL:
                		case L_BRACE:
                		case MINUS:
                		case IDENTIFIER:
                		case NUMBER:
                		case BSTRING:
                			{
                				alt131=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt131) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:603:33: COMMA enumerationItem
            	    {
            	        COMMA403 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_enumeration6558); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleenumerationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_enumerationItem_in_enumeration6561);
            	        enumerationItem404=enumerationItem(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleenumerationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, enumerationItem404.tree);

            	    }
            	    break;

            	default:
            	    goto loop131;	/* break out of the loop */
            	    break;
                }
            }
            loop131: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleenumerationEx; /* Prevent compiler warnings */
    ruleenumerationEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(122, enumeration_StartIndex); }

    return retval;
}
/* $ANTLR end enumeration */

/** 
 * $ANTLR start enumerationItem
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:605:1: enumerationItem : ( IDENTIFIER | namedNumber | value );
 */
static asn1Parser_enumerationItem_return
enumerationItem(pasn1Parser ctx)
{   
    asn1Parser_enumerationItem_return retval;
    ANTLR3_UINT32 enumerationItem_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER405;
    asn1Parser_namedNumber_return namedNumber406;
    #undef	RETURN_TYPE_namedNumber406
    #define	RETURN_TYPE_namedNumber406 asn1Parser_namedNumber_return

    asn1Parser_value_return value407;
    #undef	RETURN_TYPE_value407
    #define	RETURN_TYPE_value407 asn1Parser_value_return

    pANTLR3_BASE_TREE IDENTIFIER405_tree;

    /* Initialize rule variables
     */
    enumerationItem_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(123)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IDENTIFIER405       = NULL;
    namedNumber406.tree = NULL;

    value407.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER405_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:605:17: ( IDENTIFIER | namedNumber | value )
            
            ANTLR3_UINT32 alt132;

            alt132=3;

            switch ( LA(1) ) 
            {
            case IDENTIFIER:
            	{

            		{
            		    int LA132_1 = LA(2);
            		    if ( (LA132_1 == L_PARAN) ) 
            		    {
            		        alt132=2;
            		    }
            		    else if ( (synpred180_asn1(ctx)) ) 
            		    {
            		        alt132=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt132=3;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 132;
            		        EXCEPTION->state        = 1;


            		        goto ruleenumerationItemEx;
            		    }
            		}
            	}
                break;
            case TRUE_LITERAL:
            case FALSE_LITERAL:
            case TRUE_SMALL_LITERAL:
            case FALSE_SMALL_LITERAL:
            case L_BRACE:
            case MINUS:
            case NUMBER:
            case BSTRING:
            	{
            		alt132=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 132;
                EXCEPTION->state        = 0;


                goto ruleenumerationItemEx;
            }

            switch (alt132) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:605:19: IDENTIFIER
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        IDENTIFIER405 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumerationItem6571); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleenumerationItemEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        IDENTIFIER405_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER405));
        	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER405_tree);
        	        }

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:605:32: namedNumber
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_namedNumber_in_enumerationItem6575);
        	        namedNumber406=namedNumber(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleenumerationItemEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, namedNumber406.tree);

        	    }
        	    break;
        	case 3:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:605:46: value
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_value_in_enumerationItem6579);
        	        value407=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleenumerationItemEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value407.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleenumerationItemEx; /* Prevent compiler warnings */
    ruleenumerationItemEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(123, enumerationItem_StartIndex); }

    return retval;
}
/* $ANTLR end enumerationItem */

/** 
 * $ANTLR start namedNumber
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:607:1: namedNumber : IDENTIFIER L_PARAN (sn= signedNumber | dv= definedValue ) R_PARAN -> ^( IDENTIFIER ( $sn)? ( $dv)? ) ;
 */
static asn1Parser_namedNumber_return
namedNumber(pasn1Parser ctx)
{   
    asn1Parser_namedNumber_return retval;
    ANTLR3_UINT32 namedNumber_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER408;
    pANTLR3_COMMON_TOKEN    L_PARAN409;
    pANTLR3_COMMON_TOKEN    R_PARAN410;
    asn1Parser_signedNumber_return sn;
    #undef	RETURN_TYPE_sn
    #define	RETURN_TYPE_sn asn1Parser_signedNumber_return

    asn1Parser_definedValue_return dv;
    #undef	RETURN_TYPE_dv
    #define	RETURN_TYPE_dv asn1Parser_definedValue_return

    pANTLR3_BASE_TREE IDENTIFIER408_tree;
    pANTLR3_BASE_TREE L_PARAN409_tree;
    pANTLR3_BASE_TREE R_PARAN410_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_PARAN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_PARAN;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_definedValue;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_signedNumber;
    /* Initialize rule variables
     */
    namedNumber_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(124)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IDENTIFIER408       = NULL;
    L_PARAN409       = NULL;
    R_PARAN410       = NULL;
    sn.tree = NULL;

    dv.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER408_tree   = NULL;
    L_PARAN409_tree   = NULL;
    R_PARAN410_tree   = NULL;

    stream_L_PARAN   = NULL;
    #define CREATE_stream_L_PARAN  if (stream_L_PARAN == NULL) {stream_L_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_PARAN"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_R_PARAN   = NULL;
    #define CREATE_stream_R_PARAN  if (stream_R_PARAN == NULL) {stream_R_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_PARAN"); } 
    stream_definedValue   = NULL;
    #define CREATE_stream_definedValue  if (stream_definedValue == NULL) {stream_definedValue = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule definedValue"); }
    stream_signedNumber   = NULL;
    #define CREATE_stream_signedNumber  if (stream_signedNumber == NULL) {stream_signedNumber = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule signedNumber"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:607:13: ( IDENTIFIER L_PARAN (sn= signedNumber | dv= definedValue ) R_PARAN -> ^( IDENTIFIER ( $sn)? ( $dv)? ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:607:17: IDENTIFIER L_PARAN (sn= signedNumber | dv= definedValue ) R_PARAN
        {
            IDENTIFIER408 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_namedNumber6589); 
            if  (HASEXCEPTION())
            {
                goto rulenamedNumberEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, IDENTIFIER408, NULL); }

            L_PARAN409 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_namedNumber6591); 
            if  (HASEXCEPTION())
            {
                goto rulenamedNumberEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_L_PARAN; stream_L_PARAN->add(stream_L_PARAN, L_PARAN409, NULL); }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:607:36: (sn= signedNumber | dv= definedValue )
            {
                int alt133=2;
                switch ( LA(1) ) 
                {
                case MINUS:
                case NUMBER:
                	{
                		alt133=1;
                	}
                    break;
                case IDENTIFIER:
                	{
                		alt133=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 133;
                    EXCEPTION->state        = 0;


                    goto rulenamedNumberEx;
                }

                switch (alt133) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:607:37: sn= signedNumber
            	    {
            	        FOLLOWPUSH(FOLLOW_signedNumber_in_namedNumber6596);
            	        sn=signedNumber(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenamedNumberEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_signedNumber; stream_signedNumber->add(stream_signedNumber, sn.tree, NULL); }

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:607:55: dv= definedValue
            	    {
            	        FOLLOWPUSH(FOLLOW_definedValue_in_namedNumber6602);
            	        dv=definedValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenamedNumberEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_definedValue; stream_definedValue->add(stream_definedValue, dv.tree, NULL); }

            	    }
            	    break;

                }
            }
            R_PARAN410 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_namedNumber6605); 
            if  (HASEXCEPTION())
            {
                goto rulenamedNumberEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_R_PARAN; stream_R_PARAN->add(stream_R_PARAN, R_PARAN410, NULL); }


             
            /* AST REWRITE
             * elements          : sn, IDENTIFIER, dv
             * token labels      : 
             * rule labels       : retval, dv, sn
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_dv;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_sn;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_dv=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token dv", dv.tree != NULL ? dv.tree : NULL);
            	stream_sn=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token sn", sn.tree != NULL ? sn.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 607:80: -> ^( IDENTIFIER ( $sn)? ( $dv)? )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:607:83: ^( IDENTIFIER ( $sn)? ( $dv)? )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_IDENTIFIER == NULL ? NULL : stream_IDENTIFIER->nextNode(stream_IDENTIFIER), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:607:96: ( $sn)?
            	        {
            	        	if ( (stream_sn != NULL && stream_sn->hasNext(stream_sn))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_sn == NULL ? NULL : stream_sn->nextTree(stream_sn));

            	        	}
            	        	if ( stream_sn != NULL) stream_sn->reset(stream_sn);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:607:101: ( $dv)?
            	        {
            	        	if ( (stream_dv != NULL && stream_dv->hasNext(stream_dv))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_dv == NULL ? NULL : stream_dv->nextTree(stream_dv));

            	        	}
            	        	if ( stream_dv != NULL) stream_dv->reset(stream_dv);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_dv != NULL) stream_dv->free(stream_dv);
            	if (stream_sn != NULL) stream_sn->free(stream_sn);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenamedNumberEx; /* Prevent compiler warnings */
    rulenamedNumberEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_L_PARAN != NULL) stream_L_PARAN->free(stream_L_PARAN);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_R_PARAN != NULL) stream_R_PARAN->free(stream_R_PARAN);
        if (stream_definedValue != NULL) stream_definedValue->free(stream_definedValue);
        if (stream_signedNumber != NULL) stream_signedNumber->free(stream_signedNumber);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(124, namedNumber_StartIndex); }

    return retval;
}
/* $ANTLR end namedNumber */

/** 
 * $ANTLR start definedValue
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:609:1: definedValue : parameterizedValue ;
 */
static asn1Parser_definedValue_return
definedValue(pasn1Parser ctx)
{   
    asn1Parser_definedValue_return retval;
    ANTLR3_UINT32 definedValue_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_parameterizedValue_return parameterizedValue411;
    #undef	RETURN_TYPE_parameterizedValue411
    #define	RETURN_TYPE_parameterizedValue411 asn1Parser_parameterizedValue_return


    /* Initialize rule variables
     */
    definedValue_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(125)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    parameterizedValue411.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:609:14: ( parameterizedValue )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:612:3: parameterizedValue
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_parameterizedValue_in_definedValue6634);
            parameterizedValue411=parameterizedValue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledefinedValueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, parameterizedValue411.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledefinedValueEx; /* Prevent compiler warnings */
    ruledefinedValueEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(125, definedValue_StartIndex); }

    return retval;
}
/* $ANTLR end definedValue */

/** 
 * $ANTLR start parameterizedValue
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:614:1: parameterizedValue : simpleDefinedValue ( actualParameterList )? ;
 */
static asn1Parser_parameterizedValue_return
parameterizedValue(pasn1Parser ctx)
{   
    asn1Parser_parameterizedValue_return retval;
    ANTLR3_UINT32 parameterizedValue_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_simpleDefinedValue_return simpleDefinedValue412;
    #undef	RETURN_TYPE_simpleDefinedValue412
    #define	RETURN_TYPE_simpleDefinedValue412 asn1Parser_simpleDefinedValue_return

    asn1Parser_actualParameterList_return actualParameterList413;
    #undef	RETURN_TYPE_actualParameterList413
    #define	RETURN_TYPE_actualParameterList413 asn1Parser_actualParameterList_return


    /* Initialize rule variables
     */
    parameterizedValue_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(126)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    simpleDefinedValue412.tree = NULL;

    actualParameterList413.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:614:20: ( simpleDefinedValue ( actualParameterList )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:614:22: simpleDefinedValue ( actualParameterList )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_simpleDefinedValue_in_parameterizedValue6643);
            simpleDefinedValue412=simpleDefinedValue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparameterizedValueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, simpleDefinedValue412.tree);

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:614:41: ( actualParameterList )?
            {
                int alt134=2;
                switch ( LA(1) ) 
                {
                    case L_BRACE:
                    	{
                    		alt134=1;
                    	}
                        break;
                }

                switch (alt134) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:614:42: actualParameterList
            	    {
            	        FOLLOWPUSH(FOLLOW_actualParameterList_in_parameterizedValue6646);
            	        actualParameterList413=actualParameterList(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparameterizedValueEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, actualParameterList413.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparameterizedValueEx; /* Prevent compiler warnings */
    ruleparameterizedValueEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(126, parameterizedValue_StartIndex); }

    return retval;
}
/* $ANTLR end parameterizedValue */

/** 
 * $ANTLR start simpleDefinedValue
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:616:1: simpleDefinedValue : IDENTIFIER ( DOT IDENTIFIER )? ;
 */
static asn1Parser_simpleDefinedValue_return
simpleDefinedValue(pasn1Parser ctx)
{   
    asn1Parser_simpleDefinedValue_return retval;
    ANTLR3_UINT32 simpleDefinedValue_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER414;
    pANTLR3_COMMON_TOKEN    DOT415;
    pANTLR3_COMMON_TOKEN    IDENTIFIER416;

    pANTLR3_BASE_TREE IDENTIFIER414_tree;
    pANTLR3_BASE_TREE DOT415_tree;
    pANTLR3_BASE_TREE IDENTIFIER416_tree;

    /* Initialize rule variables
     */
    simpleDefinedValue_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(127)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IDENTIFIER414       = NULL;
    DOT415       = NULL;
    IDENTIFIER416       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER414_tree   = NULL;
    DOT415_tree   = NULL;
    IDENTIFIER416_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:616:20: ( IDENTIFIER ( DOT IDENTIFIER )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:616:22: IDENTIFIER ( DOT IDENTIFIER )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER414 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simpleDefinedValue6656); 
            if  (HASEXCEPTION())
            {
                goto rulesimpleDefinedValueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER414_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER414));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER414_tree);
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:616:33: ( DOT IDENTIFIER )?
            {
                int alt135=2;
                switch ( LA(1) ) 
                {
                    case DOT:
                    	{
                    		alt135=1;
                    	}
                        break;
                }

                switch (alt135) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:616:34: DOT IDENTIFIER
            	    {
            	        DOT415 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_simpleDefinedValue6659); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimpleDefinedValueEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        DOT415_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT415));
            	        ADAPTOR->addChild(ADAPTOR, root_0, DOT415_tree);
            	        }
            	        IDENTIFIER416 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_simpleDefinedValue6661); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesimpleDefinedValueEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        IDENTIFIER416_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER416));
            	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER416_tree);
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesimpleDefinedValueEx; /* Prevent compiler warnings */
    rulesimpleDefinedValueEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(127, simpleDefinedValue_StartIndex); }

    return retval;
}
/* $ANTLR end simpleDefinedValue */

/** 
 * $ANTLR start actualParameterList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:619:1: actualParameterList : L_BRACE ap1= actualParameter ( COMMA ap2= actualParameter )* R_BRACE -> ^( $ap1 ( $ap2)? ) ;
 */
static asn1Parser_actualParameterList_return
actualParameterList(pasn1Parser ctx)
{   
    asn1Parser_actualParameterList_return retval;
    ANTLR3_UINT32 actualParameterList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    L_BRACE417;
    pANTLR3_COMMON_TOKEN    COMMA418;
    pANTLR3_COMMON_TOKEN    R_BRACE419;
    asn1Parser_actualParameter_return ap1;
    #undef	RETURN_TYPE_ap1
    #define	RETURN_TYPE_ap1 asn1Parser_actualParameter_return

    asn1Parser_actualParameter_return ap2;
    #undef	RETURN_TYPE_ap2
    #define	RETURN_TYPE_ap2 asn1Parser_actualParameter_return

    pANTLR3_BASE_TREE L_BRACE417_tree;
    pANTLR3_BASE_TREE COMMA418_tree;
    pANTLR3_BASE_TREE R_BRACE419_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_COMMA;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_actualParameter;
    /* Initialize rule variables
     */
    actualParameterList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(128)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    L_BRACE417       = NULL;
    COMMA418       = NULL;
    R_BRACE419       = NULL;
    ap1.tree = NULL;

    ap2.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    L_BRACE417_tree   = NULL;
    COMMA418_tree   = NULL;
    R_BRACE419_tree   = NULL;

    stream_L_BRACE   = NULL;
    #define CREATE_stream_L_BRACE  if (stream_L_BRACE == NULL) {stream_L_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_BRACE"); } 
    stream_R_BRACE   = NULL;
    #define CREATE_stream_R_BRACE  if (stream_R_BRACE == NULL) {stream_R_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_BRACE"); } 
    stream_COMMA   = NULL;
    #define CREATE_stream_COMMA  if (stream_COMMA == NULL) {stream_COMMA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token COMMA"); } 
    stream_actualParameter   = NULL;
    #define CREATE_stream_actualParameter  if (stream_actualParameter == NULL) {stream_actualParameter = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule actualParameter"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:619:21: ( L_BRACE ap1= actualParameter ( COMMA ap2= actualParameter )* R_BRACE -> ^( $ap1 ( $ap2)? ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:619:23: L_BRACE ap1= actualParameter ( COMMA ap2= actualParameter )* R_BRACE
        {
            L_BRACE417 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_actualParameterList6672); 
            if  (HASEXCEPTION())
            {
                goto ruleactualParameterListEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_L_BRACE; stream_L_BRACE->add(stream_L_BRACE, L_BRACE417, NULL); }

            FOLLOWPUSH(FOLLOW_actualParameter_in_actualParameterList6676);
            ap1=actualParameter(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleactualParameterListEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) { CREATE_stream_actualParameter; stream_actualParameter->add(stream_actualParameter, ap1.tree, NULL); }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:619:51: ( COMMA ap2= actualParameter )*

            for (;;)
            {
                int alt136=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt136=1;
                	}
                    break;

                }

                switch (alt136) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:619:52: COMMA ap2= actualParameter
            	    {
            	        COMMA418 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_actualParameterList6679); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleactualParameterListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_COMMA; stream_COMMA->add(stream_COMMA, COMMA418, NULL); }

            	        FOLLOWPUSH(FOLLOW_actualParameter_in_actualParameterList6683);
            	        ap2=actualParameter(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleactualParameterListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_actualParameter; stream_actualParameter->add(stream_actualParameter, ap2.tree, NULL); }

            	    }
            	    break;

            	default:
            	    goto loop136;	/* break out of the loop */
            	    break;
                }
            }
            loop136: ; /* Jump out to here if this rule does not match */

            R_BRACE419 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_actualParameterList6687); 
            if  (HASEXCEPTION())
            {
                goto ruleactualParameterListEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_R_BRACE; stream_R_BRACE->add(stream_R_BRACE, R_BRACE419, NULL); }


             
            /* AST REWRITE
             * elements          : ap2, ap1
             * token labels      : 
             * rule labels       : retval, ap2, ap1
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_ap2;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_ap1;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_ap2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token ap2", ap2.tree != NULL ? ap2.tree : NULL);
            	stream_ap1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token ap1", ap1.tree != NULL ? ap1.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 619:88: -> ^( $ap1 ( $ap2)? )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:619:91: ^( $ap1 ( $ap2)? )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_ap1 == NULL ? NULL : stream_ap1->nextNode(stream_ap1), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:619:98: ( $ap2)?
            	        {
            	        	if ( (stream_ap2 != NULL && stream_ap2->hasNext(stream_ap2))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_ap2 == NULL ? NULL : stream_ap2->nextTree(stream_ap2));

            	        	}
            	        	if ( stream_ap2 != NULL) stream_ap2->reset(stream_ap2);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_ap2 != NULL) stream_ap2->free(stream_ap2);
            	if (stream_ap1 != NULL) stream_ap1->free(stream_ap1);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleactualParameterListEx; /* Prevent compiler warnings */
    ruleactualParameterListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_L_BRACE != NULL) stream_L_BRACE->free(stream_L_BRACE);
        if (stream_R_BRACE != NULL) stream_R_BRACE->free(stream_R_BRACE);
        if (stream_COMMA != NULL) stream_COMMA->free(stream_COMMA);
        if (stream_actualParameter != NULL) stream_actualParameter->free(stream_actualParameter);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(128, actualParameterList_StartIndex); }

    return retval;
}
/* $ANTLR end actualParameterList */

/** 
 * $ANTLR start actualParameter
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:621:1: actualParameter : (tp= type | vl= value -> ^( NODE_INFO ( $tp)? ( $vl)? ) );
 */
static asn1Parser_actualParameter_return
actualParameter(pasn1Parser ctx)
{   
    asn1Parser_actualParameter_return retval;
    ANTLR3_UINT32 actualParameter_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_type_return tp;
    #undef	RETURN_TYPE_tp
    #define	RETURN_TYPE_tp asn1Parser_type_return

    asn1Parser_value_return vl;
    #undef	RETURN_TYPE_vl
    #define	RETURN_TYPE_vl asn1Parser_value_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_value;
    /* Initialize rule variables
     */
    actualParameter_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(129)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    tp.tree = NULL;

    vl.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_value   = NULL;
    #define CREATE_stream_value  if (stream_value == NULL) {stream_value = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule value"); }

    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:621:17: (tp= type | vl= value -> ^( NODE_INFO ( $tp)? ( $vl)? ) )
            
            ANTLR3_UINT32 alt137;

            alt137=2;

            switch ( LA(1) ) 
            {
            case BOOLEAN_LITERAL:
            case INTEGER_LITERAL:
            case IA5_STRING_LITERAL:
            case ENUMERATED_LITERAL:
            case BIT_LITERAL:
            case OCTET_LITERAL:
            case NULL_LITERAL:
            case SEQUENCE_LITERAL:
            case SET_LITERAL:
            case TYPE_IDENTIFIER_LITERAL:
            case ABSTRACT_SYNTAX_LITERAL:
            case L_BRACKET:
            case CHOICE_LITERAL:
            case OBJECT_LITERAL:
            	{
            		alt137=1;
            	}
                break;
            case IDENTIFIER:
            	{

            		{
            		    int LA137_2 = LA(2);
            		    if ( (synpred186_asn1(ctx)) ) 
            		    {
            		        alt137=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt137=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 137;
            		        EXCEPTION->state        = 2;


            		        goto ruleactualParameterEx;
            		    }
            		}
            	}
                break;
            case TRUE_LITERAL:
            case FALSE_LITERAL:
            case TRUE_SMALL_LITERAL:
            case FALSE_SMALL_LITERAL:
            case L_BRACE:
            case MINUS:
            case NUMBER:
            case BSTRING:
            	{
            		alt137=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 137;
                EXCEPTION->state        = 0;


                goto ruleactualParameterEx;
            }

            switch (alt137) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:621:19: tp= type
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_type_in_actualParameter6708);
        	        tp=type(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactualParameterEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, tp.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:621:29: vl= value
        	    {
        	        FOLLOWPUSH(FOLLOW_value_in_actualParameter6714);
        	        vl=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleactualParameterEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) { CREATE_stream_value; stream_value->add(stream_value, vl.tree, NULL); }

        	         
        	        /* AST REWRITE
        	         * elements          : vl, tp
        	         * token labels      : 
        	         * rule labels       : vl, retval, tp
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        if ( BACKTRACKING==0 ) 
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_vl;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_tp;

        	        	stream_vl=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token vl", vl.tree != NULL ? vl.tree : NULL);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
        	        	stream_tp=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token tp", tp.tree != NULL ? tp.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 622:1: -> ^( NODE_INFO ( $tp)? ( $vl)? )
        	        	{
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:622:4: ^( NODE_INFO ( $tp)? ( $vl)? )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NODE_INFO, (pANTLR3_UINT8)"NODE_INFO"), root_1));

        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:622:16: ( $tp)?
        	        	        {
        	        	        	if ( (stream_tp != NULL && stream_tp->hasNext(stream_tp))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_tp == NULL ? NULL : stream_tp->nextTree(stream_tp));

        	        	        	}
        	        	        	if ( stream_tp != NULL) stream_tp->reset(stream_tp);

        	        	        }
        	        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:622:21: ( $vl)?
        	        	        {
        	        	        	if ( (stream_vl != NULL && stream_vl->hasNext(stream_vl))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_vl == NULL ? NULL : stream_vl->nextTree(stream_vl));

        	        	        	}
        	        	        	if ( stream_vl != NULL) stream_vl->reset(stream_vl);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_vl != NULL) stream_vl->free(stream_vl);
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);
        	        	if (stream_tp != NULL) stream_tp->free(stream_tp);


        	        }
        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleactualParameterEx; /* Prevent compiler warnings */
    ruleactualParameterEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_value != NULL) stream_value->free(stream_value);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(129, actualParameter_StartIndex); }

    return retval;
}
/* $ANTLR end actualParameter */

/** 
 * $ANTLR start exceptionSpec
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:624:1: exceptionSpec : ( EXCLAM exceptionIdentification )? ;
 */
static asn1Parser_exceptionSpec_return
exceptionSpec(pasn1Parser ctx)
{   
    asn1Parser_exceptionSpec_return retval;
    ANTLR3_UINT32 exceptionSpec_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EXCLAM420;
    asn1Parser_exceptionIdentification_return exceptionIdentification421;
    #undef	RETURN_TYPE_exceptionIdentification421
    #define	RETURN_TYPE_exceptionIdentification421 asn1Parser_exceptionIdentification_return

    pANTLR3_BASE_TREE EXCLAM420_tree;

    /* Initialize rule variables
     */
    exceptionSpec_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(130)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    EXCLAM420       = NULL;
    exceptionIdentification421.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    EXCLAM420_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:624:15: ( ( EXCLAM exceptionIdentification )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:624:17: ( EXCLAM exceptionIdentification )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:624:17: ( EXCLAM exceptionIdentification )?
            {
                int alt138=2;
                switch ( LA(1) ) 
                {
                    case EXCLAM:
                    	{
                    		{
                    		    int LA138_1 = LA(2);
                    		    if ( (synpred187_asn1(ctx)) ) 
                    		    {
                    		        alt138=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt138) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:624:18: EXCLAM exceptionIdentification
            	    {
            	        EXCLAM420 = (pANTLR3_COMMON_TOKEN) MATCHT(EXCLAM, &FOLLOW_EXCLAM_in_exceptionSpec6739); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexceptionSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        EXCLAM420_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EXCLAM420));
            	        ADAPTOR->addChild(ADAPTOR, root_0, EXCLAM420_tree);
            	        }
            	        FOLLOWPUSH(FOLLOW_exceptionIdentification_in_exceptionSpec6742);
            	        exceptionIdentification421=exceptionIdentification(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexceptionSpecEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, exceptionIdentification421.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexceptionSpecEx; /* Prevent compiler warnings */
    ruleexceptionSpecEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(130, exceptionSpec_StartIndex); }

    return retval;
}
/* $ANTLR end exceptionSpec */

/** 
 * $ANTLR start exceptionIdentification
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:626:1: exceptionIdentification : ( signedNumber | definedValue | type COLON value );
 */
static asn1Parser_exceptionIdentification_return
exceptionIdentification(pasn1Parser ctx)
{   
    asn1Parser_exceptionIdentification_return retval;
    ANTLR3_UINT32 exceptionIdentification_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COLON425;
    asn1Parser_signedNumber_return signedNumber422;
    #undef	RETURN_TYPE_signedNumber422
    #define	RETURN_TYPE_signedNumber422 asn1Parser_signedNumber_return

    asn1Parser_definedValue_return definedValue423;
    #undef	RETURN_TYPE_definedValue423
    #define	RETURN_TYPE_definedValue423 asn1Parser_definedValue_return

    asn1Parser_type_return type424;
    #undef	RETURN_TYPE_type424
    #define	RETURN_TYPE_type424 asn1Parser_type_return

    asn1Parser_value_return value426;
    #undef	RETURN_TYPE_value426
    #define	RETURN_TYPE_value426 asn1Parser_value_return

    pANTLR3_BASE_TREE COLON425_tree;

    /* Initialize rule variables
     */
    exceptionIdentification_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(131)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COLON425       = NULL;
    signedNumber422.tree = NULL;

    definedValue423.tree = NULL;

    type424.tree = NULL;

    value426.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COLON425_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  /secure/release14_git/mink/src/asn1/asn1c/asn1.g:626:25: ( signedNumber | definedValue | type COLON value )
            
            ANTLR3_UINT32 alt139;

            alt139=3;

            switch ( LA(1) ) 
            {
            case MINUS:
            case NUMBER:
            	{
            		alt139=1;
            	}
                break;
            case IDENTIFIER:
            	{

            		{
            		    int LA139_3 = LA(2);
            		    if ( (synpred189_asn1(ctx)) ) 
            		    {
            		        alt139=2;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt139=3;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 139;
            		        EXCEPTION->state        = 3;


            		        goto ruleexceptionIdentificationEx;
            		    }
            		}
            	}
                break;
            case BOOLEAN_LITERAL:
            case INTEGER_LITERAL:
            case IA5_STRING_LITERAL:
            case ENUMERATED_LITERAL:
            case BIT_LITERAL:
            case OCTET_LITERAL:
            case NULL_LITERAL:
            case SEQUENCE_LITERAL:
            case SET_LITERAL:
            case TYPE_IDENTIFIER_LITERAL:
            case ABSTRACT_SYNTAX_LITERAL:
            case L_BRACKET:
            case CHOICE_LITERAL:
            case OBJECT_LITERAL:
            	{
            		alt139=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 139;
                EXCEPTION->state        = 0;


                goto ruleexceptionIdentificationEx;
            }

            switch (alt139) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:626:27: signedNumber
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_signedNumber_in_exceptionIdentification6753);
        	        signedNumber422=signedNumber(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexceptionIdentificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, signedNumber422.tree);

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:627:8: definedValue
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_definedValue_in_exceptionIdentification6763);
        	        definedValue423=definedValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexceptionIdentificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, definedValue423.tree);

        	    }
        	    break;
        	case 3:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:628:8: type COLON value
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_type_in_exceptionIdentification6773);
        	        type424=type(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexceptionIdentificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, type424.tree);
        	        COLON425 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_exceptionIdentification6775); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexceptionIdentificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) {
        	        COLON425_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON425));
        	        ADAPTOR->addChild(ADAPTOR, root_0, COLON425_tree);
        	        }
        	        FOLLOWPUSH(FOLLOW_value_in_exceptionIdentification6777);
        	        value426=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexceptionIdentificationEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }
        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, value426.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexceptionIdentificationEx; /* Prevent compiler warnings */
    ruleexceptionIdentificationEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(131, exceptionIdentification_StartIndex); }

    return retval;
}
/* $ANTLR end exceptionIdentification */

/** 
 * $ANTLR start additionalEnumeration
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:630:1: additionalEnumeration : enumeration ;
 */
static asn1Parser_additionalEnumeration_return
additionalEnumeration(pasn1Parser ctx)
{   
    asn1Parser_additionalEnumeration_return retval;
    ANTLR3_UINT32 additionalEnumeration_StartIndex;
    pANTLR3_BASE_TREE root_0;

    asn1Parser_enumeration_return enumeration427;
    #undef	RETURN_TYPE_enumeration427
    #define	RETURN_TYPE_enumeration427 asn1Parser_enumeration_return


    /* Initialize rule variables
     */
    additionalEnumeration_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(132)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    enumeration427.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:630:23: ( enumeration )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:630:25: enumeration
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_enumeration_in_additionalEnumeration6786);
            enumeration427=enumeration(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleadditionalEnumerationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, enumeration427.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleadditionalEnumerationEx; /* Prevent compiler warnings */
    ruleadditionalEnumerationEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(132, additionalEnumeration_StartIndex); }

    return retval;
}
/* $ANTLR end additionalEnumeration */

/** 
 * $ANTLR start integerType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:1: integerType : INTEGER_LITERAL ( L_BRACE nnl= namedNumberList R_BRACE )? ( L_PARAN ( SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )? -> ^( INTEGER_LITERAL ( ^( $nnl) )? ^( TAG_SPECIFIC ( $c1)? ( $c2)? ) ) ;
 */
static asn1Parser_integerType_return
integerType(pasn1Parser ctx)
{   
    asn1Parser_integerType_return retval;
    ANTLR3_UINT32 integerType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    INTEGER_LITERAL428;
    pANTLR3_COMMON_TOKEN    L_BRACE429;
    pANTLR3_COMMON_TOKEN    R_BRACE430;
    pANTLR3_COMMON_TOKEN    L_PARAN431;
    pANTLR3_COMMON_TOKEN    SIZE_LITERAL432;
    pANTLR3_COMMON_TOKEN    R_PARAN433;
    asn1Parser_namedNumberList_return nnl;
    #undef	RETURN_TYPE_nnl
    #define	RETURN_TYPE_nnl asn1Parser_namedNumberList_return

    asn1Parser_constraint_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 asn1Parser_constraint_return

    asn1Parser_sizeConstraint_return c2;
    #undef	RETURN_TYPE_c2
    #define	RETURN_TYPE_c2 asn1Parser_sizeConstraint_return

    pANTLR3_BASE_TREE INTEGER_LITERAL428_tree;
    pANTLR3_BASE_TREE L_BRACE429_tree;
    pANTLR3_BASE_TREE R_BRACE430_tree;
    pANTLR3_BASE_TREE L_PARAN431_tree;
    pANTLR3_BASE_TREE SIZE_LITERAL432_tree;
    pANTLR3_BASE_TREE R_PARAN433_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SIZE_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_PARAN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_INTEGER_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_PARAN;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_constraint;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_namedNumberList;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_sizeConstraint;
    /* Initialize rule variables
     */
    integerType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(133)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    INTEGER_LITERAL428       = NULL;
    L_BRACE429       = NULL;
    R_BRACE430       = NULL;
    L_PARAN431       = NULL;
    SIZE_LITERAL432       = NULL;
    R_PARAN433       = NULL;
    nnl.tree = NULL;

    c1.tree = NULL;

    c2.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    INTEGER_LITERAL428_tree   = NULL;
    L_BRACE429_tree   = NULL;
    R_BRACE430_tree   = NULL;
    L_PARAN431_tree   = NULL;
    SIZE_LITERAL432_tree   = NULL;
    R_PARAN433_tree   = NULL;

    stream_L_BRACE   = NULL;
    #define CREATE_stream_L_BRACE  if (stream_L_BRACE == NULL) {stream_L_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_BRACE"); } 
    stream_R_BRACE   = NULL;
    #define CREATE_stream_R_BRACE  if (stream_R_BRACE == NULL) {stream_R_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_BRACE"); } 
    stream_SIZE_LITERAL   = NULL;
    #define CREATE_stream_SIZE_LITERAL  if (stream_SIZE_LITERAL == NULL) {stream_SIZE_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SIZE_LITERAL"); } 
    stream_L_PARAN   = NULL;
    #define CREATE_stream_L_PARAN  if (stream_L_PARAN == NULL) {stream_L_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_PARAN"); } 
    stream_INTEGER_LITERAL   = NULL;
    #define CREATE_stream_INTEGER_LITERAL  if (stream_INTEGER_LITERAL == NULL) {stream_INTEGER_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token INTEGER_LITERAL"); } 
    stream_R_PARAN   = NULL;
    #define CREATE_stream_R_PARAN  if (stream_R_PARAN == NULL) {stream_R_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_PARAN"); } 
    stream_constraint   = NULL;
    #define CREATE_stream_constraint  if (stream_constraint == NULL) {stream_constraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule constraint"); }
    stream_namedNumberList   = NULL;
    #define CREATE_stream_namedNumberList  if (stream_namedNumberList == NULL) {stream_namedNumberList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule namedNumberList"); }
    stream_sizeConstraint   = NULL;
    #define CREATE_stream_sizeConstraint  if (stream_sizeConstraint == NULL) {stream_sizeConstraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule sizeConstraint"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:13: ( INTEGER_LITERAL ( L_BRACE nnl= namedNumberList R_BRACE )? ( L_PARAN ( SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )? -> ^( INTEGER_LITERAL ( ^( $nnl) )? ^( TAG_SPECIFIC ( $c1)? ( $c2)? ) ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:15: INTEGER_LITERAL ( L_BRACE nnl= namedNumberList R_BRACE )? ( L_PARAN ( SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )?
        {
            INTEGER_LITERAL428 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER_LITERAL, &FOLLOW_INTEGER_LITERAL_in_integerType6794); 
            if  (HASEXCEPTION())
            {
                goto ruleintegerTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_INTEGER_LITERAL; stream_INTEGER_LITERAL->add(stream_INTEGER_LITERAL, INTEGER_LITERAL428, NULL); }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:32: ( L_BRACE nnl= namedNumberList R_BRACE )?
            {
                int alt140=2;
                switch ( LA(1) ) 
                {
                    case L_BRACE:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		    case IDENTIFIER:
                    		    	{
                    		    		switch ( LA(3) ) 
                    		    		{
                    		    		    case L_PARAN:
                    		    		    	{
                    		    		    		alt140=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt140) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:33: L_BRACE nnl= namedNumberList R_BRACE
            	    {
            	        L_BRACE429 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_integerType6798); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintegerTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_L_BRACE; stream_L_BRACE->add(stream_L_BRACE, L_BRACE429, NULL); }

            	        FOLLOWPUSH(FOLLOW_namedNumberList_in_integerType6802);
            	        nnl=namedNumberList(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintegerTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_namedNumberList; stream_namedNumberList->add(stream_namedNumberList, nnl.tree, NULL); }
            	        R_BRACE430 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_integerType6804); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintegerTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_R_BRACE; stream_R_BRACE->add(stream_R_BRACE, R_BRACE430, NULL); }


            	    }
            	    break;

                }
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:71: ( L_PARAN ( SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )?
            {
                int alt143=2;
                switch ( LA(1) ) 
                {
                    case L_PARAN:
                    	{
                    		alt143=1;
                    	}
                        break;
                }

                switch (alt143) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:72: L_PARAN ( SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN
            	    {
            	        L_PARAN431 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_integerType6809); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintegerTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_L_PARAN; stream_L_PARAN->add(stream_L_PARAN, L_PARAN431, NULL); }


            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:80: ( SIZE_LITERAL )*

            	        for (;;)
            	        {
            	            int alt141=2;
            	            switch ( LA(1) ) 
            	            {
            	            case SIZE_LITERAL:
            	            	{
            	            		{
            	            		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            		    */
            	            		    int LA141_12 = LA(2);
            	            		    if ( (synpred191_asn1(ctx)) ) 
            	            		    {
            	            		        alt141=1;
            	            		    }

            	            		}
            	            	}
            	                break;

            	            }

            	            switch (alt141) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: SIZE_LITERAL
            	        	    {
            	        	        SIZE_LITERAL432 = (pANTLR3_COMMON_TOKEN) MATCHT(SIZE_LITERAL, &FOLLOW_SIZE_LITERAL_in_integerType6811); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleintegerTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        } 
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_SIZE_LITERAL; stream_SIZE_LITERAL->add(stream_SIZE_LITERAL, SIZE_LITERAL432, NULL); }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop141;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop141: ; /* Jump out to here if this rule does not match */


            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:94: (c1= constraint | c2= sizeConstraint )
            	        {
            	            int alt142=2;
            	            switch ( LA(1) ) 
            	            {
            	            case TRUE_LITERAL:
            	            case FALSE_LITERAL:
            	            case TRUE_SMALL_LITERAL:
            	            case FALSE_SMALL_LITERAL:
            	            case L_BRACE:
            	            case L_PARAN:
            	            case MINUS:
            	            case CONTAINING_LITERAL:
            	            case ALL_LITERAL:
            	            case MIN_LITERAL:
            	            case PATTERN_LITERAL:
            	            case CONSTRAINED_LITERAL:
            	            case ENCODED_LITERAL:
            	            case IDENTIFIER:
            	            case NUMBER:
            	            case BSTRING:
            	            	{
            	            		alt142=1;
            	            	}
            	                break;
            	            case SIZE_LITERAL:
            	            	{

            	            		{
            	            		    int LA142_12 = LA(2);
            	            		    if ( (synpred192_asn1(ctx)) ) 
            	            		    {
            	            		        alt142=1;
            	            		    }
            	            		    else if ( (ANTLR3_TRUE) ) 
            	            		    {
            	            		        alt142=2;
            	            		    }
            	            		    else 
            	            		    {
            	            		        if (BACKTRACKING>0)
            	            		        {
            	            		            FAILEDFLAG = ANTLR3_TRUE;
            	            		            return retval;
            	            		        }
            	            		    
            	            		        CONSTRUCTEX();
            	            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		        EXCEPTION->message      = (void *)"";
            	            		        EXCEPTION->decisionNum  = 142;
            	            		        EXCEPTION->state        = 12;


            	            		        goto ruleintegerTypeEx;
            	            		    }
            	            		}
            	            	}
            	                break;

            	            default:
            	                if (BACKTRACKING>0)
            	                {
            	                    FAILEDFLAG = ANTLR3_TRUE;
            	                    return retval;
            	                }
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 142;
            	                EXCEPTION->state        = 0;


            	                goto ruleintegerTypeEx;
            	            }

            	            switch (alt142) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:95: c1= constraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constraint_in_integerType6817);
            	        	        c1=constraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleintegerTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_constraint; stream_constraint->add(stream_constraint, c1.tree, NULL); }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:111: c2= sizeConstraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_sizeConstraint_in_integerType6823);
            	        	        c2=sizeConstraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleintegerTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_sizeConstraint; stream_sizeConstraint->add(stream_sizeConstraint, c2.tree, NULL); }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        R_PARAN433 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_integerType6826); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleintegerTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_R_PARAN; stream_R_PARAN->add(stream_R_PARAN, R_PARAN433, NULL); }


            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : c2, c1, INTEGER_LITERAL, nnl
             * token labels      : 
             * rule labels       : retval, c1, c2, nnl
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c2;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_nnl;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_c1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c1", c1.tree != NULL ? c1.tree : NULL);
            	stream_c2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c2", c2.tree != NULL ? c2.tree : NULL);
            	stream_nnl=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token nnl", nnl.tree != NULL ? nnl.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 633:6: -> ^( INTEGER_LITERAL ( ^( $nnl) )? ^( TAG_SPECIFIC ( $c1)? ( $c2)? ) )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:633:9: ^( INTEGER_LITERAL ( ^( $nnl) )? ^( TAG_SPECIFIC ( $c1)? ( $c2)? ) )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_INTEGER_LITERAL == NULL ? NULL : stream_INTEGER_LITERAL->nextNode(stream_INTEGER_LITERAL), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:633:27: ( ^( $nnl) )?
            	        {
            	        	if ( (stream_nnl != NULL && stream_nnl->hasNext(stream_nnl))  )
            	        	{
            	        		// /secure/release14_git/mink/src/asn1/asn1c/asn1.g:633:27: ^( $nnl)
            	        		{
            	        		    pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        		    root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_nnl == NULL ? NULL : stream_nnl->nextNode(stream_nnl), root_2));

            	        		    ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        		}

            	        	}
            	        	if ( stream_nnl != NULL) stream_nnl->reset(stream_nnl);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:633:36: ^( TAG_SPECIFIC ( $c1)? ( $c2)? )
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TAG_SPECIFIC, (pANTLR3_UINT8)"TAG_SPECIFIC"), root_2));

            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:633:51: ( $c1)?
            	            {
            	            	if ( (stream_c1 != NULL && stream_c1->hasNext(stream_c1))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_c1 == NULL ? NULL : stream_c1->nextTree(stream_c1));

            	            	}
            	            	if ( stream_c1 != NULL) stream_c1->reset(stream_c1);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:633:56: ( $c2)?
            	            {
            	            	if ( (stream_c2 != NULL && stream_c2->hasNext(stream_c2))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_c2 == NULL ? NULL : stream_c2->nextTree(stream_c2));

            	            	}
            	            	if ( stream_c2 != NULL) stream_c2->reset(stream_c2);

            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_c1 != NULL) stream_c1->free(stream_c1);
            	if (stream_c2 != NULL) stream_c2->free(stream_c2);
            	if (stream_nnl != NULL) stream_nnl->free(stream_nnl);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleintegerTypeEx; /* Prevent compiler warnings */
    ruleintegerTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_L_BRACE != NULL) stream_L_BRACE->free(stream_L_BRACE);
        if (stream_R_BRACE != NULL) stream_R_BRACE->free(stream_R_BRACE);
        if (stream_SIZE_LITERAL != NULL) stream_SIZE_LITERAL->free(stream_SIZE_LITERAL);
        if (stream_L_PARAN != NULL) stream_L_PARAN->free(stream_L_PARAN);
        if (stream_INTEGER_LITERAL != NULL) stream_INTEGER_LITERAL->free(stream_INTEGER_LITERAL);
        if (stream_R_PARAN != NULL) stream_R_PARAN->free(stream_R_PARAN);
        if (stream_constraint != NULL) stream_constraint->free(stream_constraint);
        if (stream_namedNumberList != NULL) stream_namedNumberList->free(stream_namedNumberList);
        if (stream_sizeConstraint != NULL) stream_sizeConstraint->free(stream_sizeConstraint);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(133, integerType_StartIndex); }

    return retval;
}
/* $ANTLR end integerType */

/** 
 * $ANTLR start namedNumberList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:635:1: namedNumberList : (nn= namedNumber ) ( COMMA nn1+= namedNumber )* -> ^( TAG_SPECIFIC $nn ( $nn1)* ) ;
 */
static asn1Parser_namedNumberList_return
namedNumberList(pasn1Parser ctx)
{   
    asn1Parser_namedNumberList_return retval;
    ANTLR3_UINT32 namedNumberList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA434;
    pANTLR3_VECTOR    list_nn1;
    asn1Parser_namedNumber_return nn;
    #undef	RETURN_TYPE_nn
    #define	RETURN_TYPE_nn asn1Parser_namedNumber_return

    asn1Parser_namedNumber_return nn1;
    #undef	RETURN_TYPE_nn1
    #define	RETURN_TYPE_nn1 asn1Parser_namedNumber_return

    pANTLR3_BASE_TREE COMMA434_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_COMMA;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_namedNumber;
    /* Initialize rule variables
     */
    namedNumberList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(134)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA434       = NULL;
    list_nn1     = NULL;
    nn.tree = NULL;

    nn1.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA434_tree   = NULL;

    stream_COMMA   = NULL;
    #define CREATE_stream_COMMA  if (stream_COMMA == NULL) {stream_COMMA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token COMMA"); } 
    stream_namedNumber   = NULL;
    #define CREATE_stream_namedNumber  if (stream_namedNumber == NULL) {stream_namedNumber = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule namedNumber"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:635:17: ( (nn= namedNumber ) ( COMMA nn1+= namedNumber )* -> ^( TAG_SPECIFIC $nn ( $nn1)* ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:635:19: (nn= namedNumber ) ( COMMA nn1+= namedNumber )*
        {
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:635:19: (nn= namedNumber )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:635:20: nn= namedNumber
            {
                FOLLOWPUSH(FOLLOW_namedNumber_in_namedNumberList6868);
                nn=namedNumber(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulenamedNumberListEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) { CREATE_stream_namedNumber; stream_namedNumber->add(stream_namedNumber, nn.tree, NULL); }

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:635:36: ( COMMA nn1+= namedNumber )*

            for (;;)
            {
                int alt144=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt144=1;
                	}
                    break;

                }

                switch (alt144) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:635:37: COMMA nn1+= namedNumber
            	    {
            	        COMMA434 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_namedNumberList6872); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenamedNumberListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_COMMA; stream_COMMA->add(stream_COMMA, COMMA434, NULL); }

            	        FOLLOWPUSH(FOLLOW_namedNumber_in_namedNumberList6876);
            	        nn1=namedNumber(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenamedNumberListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_namedNumber; stream_namedNumber->add(stream_namedNumber, nn1.tree, NULL); }
            	        /* listLabelTrack(label)
            	         */
            	        if (list_nn1 == NULL)
            	        {
            	            list_nn1=ctx->vectors->newVector(ctx->vectors);
            	        }
            	        list_nn1->add(list_nn1, nn1.tree, NULL);

            	    }
            	    break;

            	default:
            	    goto loop144;	/* break out of the loop */
            	    break;
                }
            }
            loop144: ; /* Jump out to here if this rule does not match */


             
            /* AST REWRITE
             * elements          : nn1, nn
             * token labels      : 
             * rule labels       : retval, nn
             * token list labels : 
             * rule list labels  : nn1
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_nn;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_nn1;
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_nn=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token nn", nn.tree != NULL ? nn.tree : NULL);
            	stream_nn1=antlr3RewriteRuleSubtreeStreamNewAEV(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token nn1", list_nn1);
            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 635:62: -> ^( TAG_SPECIFIC $nn ( $nn1)* )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:635:65: ^( TAG_SPECIFIC $nn ( $nn1)* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TAG_SPECIFIC, (pANTLR3_UINT8)"TAG_SPECIFIC"), root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_nn == NULL ? NULL : stream_nn->nextTree(stream_nn));
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:635:84: ( $nn1)*
            	        {
            	        	while ( (stream_nn1 != NULL && stream_nn1->hasNext(stream_nn1))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_nn1 == NULL ? NULL : stream_nn1->nextTree(stream_nn1));

            	        	}
            	        	if (stream_nn1 != NULL) stream_nn1->reset(stream_nn1);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_nn != NULL) stream_nn->free(stream_nn);
            	if (stream_nn1 != NULL) stream_nn1->free(stream_nn1);

            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenamedNumberListEx; /* Prevent compiler warnings */
    rulenamedNumberListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_COMMA != NULL) stream_COMMA->free(stream_COMMA);
        if (stream_namedNumber != NULL) stream_namedNumber->free(stream_namedNumber);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(134, namedNumberList_StartIndex); }

    return retval;
}
/* $ANTLR end namedNumberList */

/** 
 * $ANTLR start objectidentifiertype
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:637:1: objectidentifiertype : OBJECT_LITERAL IDENTIFIER_LITERAL -> ^( NODE_INFO[\"OBJECT_IDENTIFIER\"] ) ;
 */
static asn1Parser_objectidentifiertype_return
objectidentifiertype(pasn1Parser ctx)
{   
    asn1Parser_objectidentifiertype_return retval;
    ANTLR3_UINT32 objectidentifiertype_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OBJECT_LITERAL435;
    pANTLR3_COMMON_TOKEN    IDENTIFIER_LITERAL436;

    pANTLR3_BASE_TREE OBJECT_LITERAL435_tree;
    pANTLR3_BASE_TREE IDENTIFIER_LITERAL436_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_OBJECT_LITERAL;

    /* Initialize rule variables
     */
    objectidentifiertype_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(135)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    OBJECT_LITERAL435       = NULL;
    IDENTIFIER_LITERAL436       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    OBJECT_LITERAL435_tree   = NULL;
    IDENTIFIER_LITERAL436_tree   = NULL;

    stream_IDENTIFIER_LITERAL   = NULL;
    #define CREATE_stream_IDENTIFIER_LITERAL  if (stream_IDENTIFIER_LITERAL == NULL) {stream_IDENTIFIER_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER_LITERAL"); } 
    stream_OBJECT_LITERAL   = NULL;
    #define CREATE_stream_OBJECT_LITERAL  if (stream_OBJECT_LITERAL == NULL) {stream_OBJECT_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token OBJECT_LITERAL"); } 

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:637:23: ( OBJECT_LITERAL IDENTIFIER_LITERAL -> ^( NODE_INFO[\"OBJECT_IDENTIFIER\"] ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:637:26: OBJECT_LITERAL IDENTIFIER_LITERAL
        {
            OBJECT_LITERAL435 = (pANTLR3_COMMON_TOKEN) MATCHT(OBJECT_LITERAL, &FOLLOW_OBJECT_LITERAL_in_objectidentifiertype6901); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectidentifiertypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_OBJECT_LITERAL; stream_OBJECT_LITERAL->add(stream_OBJECT_LITERAL, OBJECT_LITERAL435, NULL); }

            IDENTIFIER_LITERAL436 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER_LITERAL, &FOLLOW_IDENTIFIER_LITERAL_in_objectidentifiertype6903); 
            if  (HASEXCEPTION())
            {
                goto ruleobjectidentifiertypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER_LITERAL; stream_IDENTIFIER_LITERAL->add(stream_IDENTIFIER_LITERAL, IDENTIFIER_LITERAL436, NULL); }


             
            /* AST REWRITE
             * elements          : 
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 637:60: -> ^( NODE_INFO[\"OBJECT_IDENTIFIER\"] )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:637:63: ^( NODE_INFO[\"OBJECT_IDENTIFIER\"] )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        #if 1 == 2
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, NODE_INFO, TOKTEXT("OBJECT_IDENTIFIER"))
            	        #else
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NODE_INFO, (pANTLR3_UINT8)"OBJECT_IDENTIFIER")
            	        #endif
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleobjectidentifiertypeEx; /* Prevent compiler warnings */
    ruleobjectidentifiertypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_IDENTIFIER_LITERAL != NULL) stream_IDENTIFIER_LITERAL->free(stream_IDENTIFIER_LITERAL);
        if (stream_OBJECT_LITERAL != NULL) stream_OBJECT_LITERAL->free(stream_OBJECT_LITERAL);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(135, objectidentifiertype_StartIndex); }

    return retval;
}
/* $ANTLR end objectidentifiertype */

/** 
 * $ANTLR start componentRelationConstraint
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:639:1: componentRelationConstraint : L_BRACE ( IDENTIFIER ( DOT IDENTIFIER )? ) R_BRACE ( L_BRACE atNotation ( COMMA atNotation )* R_BRACE )? ;
 */
static asn1Parser_componentRelationConstraint_return
componentRelationConstraint(pasn1Parser ctx)
{   
    asn1Parser_componentRelationConstraint_return retval;
    ANTLR3_UINT32 componentRelationConstraint_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    L_BRACE437;
    pANTLR3_COMMON_TOKEN    IDENTIFIER438;
    pANTLR3_COMMON_TOKEN    DOT439;
    pANTLR3_COMMON_TOKEN    IDENTIFIER440;
    pANTLR3_COMMON_TOKEN    R_BRACE441;
    pANTLR3_COMMON_TOKEN    L_BRACE442;
    pANTLR3_COMMON_TOKEN    COMMA444;
    pANTLR3_COMMON_TOKEN    R_BRACE446;
    asn1Parser_atNotation_return atNotation443;
    #undef	RETURN_TYPE_atNotation443
    #define	RETURN_TYPE_atNotation443 asn1Parser_atNotation_return

    asn1Parser_atNotation_return atNotation445;
    #undef	RETURN_TYPE_atNotation445
    #define	RETURN_TYPE_atNotation445 asn1Parser_atNotation_return

    pANTLR3_BASE_TREE L_BRACE437_tree;
    pANTLR3_BASE_TREE IDENTIFIER438_tree;
    pANTLR3_BASE_TREE DOT439_tree;
    pANTLR3_BASE_TREE IDENTIFIER440_tree;
    pANTLR3_BASE_TREE R_BRACE441_tree;
    pANTLR3_BASE_TREE L_BRACE442_tree;
    pANTLR3_BASE_TREE COMMA444_tree;
    pANTLR3_BASE_TREE R_BRACE446_tree;

    /* Initialize rule variables
     */
    componentRelationConstraint_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(136)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    L_BRACE437       = NULL;
    IDENTIFIER438       = NULL;
    DOT439       = NULL;
    IDENTIFIER440       = NULL;
    R_BRACE441       = NULL;
    L_BRACE442       = NULL;
    COMMA444       = NULL;
    R_BRACE446       = NULL;
    atNotation443.tree = NULL;

    atNotation445.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    L_BRACE437_tree   = NULL;
    IDENTIFIER438_tree   = NULL;
    DOT439_tree   = NULL;
    IDENTIFIER440_tree   = NULL;
    R_BRACE441_tree   = NULL;
    L_BRACE442_tree   = NULL;
    COMMA444_tree   = NULL;
    R_BRACE446_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:639:29: ( L_BRACE ( IDENTIFIER ( DOT IDENTIFIER )? ) R_BRACE ( L_BRACE atNotation ( COMMA atNotation )* R_BRACE )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:639:31: L_BRACE ( IDENTIFIER ( DOT IDENTIFIER )? ) R_BRACE ( L_BRACE atNotation ( COMMA atNotation )* R_BRACE )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            L_BRACE437 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_componentRelationConstraint6919); 
            if  (HASEXCEPTION())
            {
                goto rulecomponentRelationConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            L_BRACE437_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, L_BRACE437));
            ADAPTOR->addChild(ADAPTOR, root_0, L_BRACE437_tree);
            }
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:639:39: ( IDENTIFIER ( DOT IDENTIFIER )? )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:639:40: IDENTIFIER ( DOT IDENTIFIER )?
            {
                IDENTIFIER438 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_componentRelationConstraint6922); 
                if  (HASEXCEPTION())
                {
                    goto rulecomponentRelationConstraintEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) {
                IDENTIFIER438_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER438));
                ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER438_tree);
                }

                // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:639:51: ( DOT IDENTIFIER )?
                {
                    int alt145=2;
                    switch ( LA(1) ) 
                    {
                        case DOT:
                        	{
                        		alt145=1;
                        	}
                            break;
                    }

                    switch (alt145) 
                    {
                	case 1:
                	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:639:52: DOT IDENTIFIER
                	    {
                	        DOT439 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_componentRelationConstraint6925); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecomponentRelationConstraintEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }
                	        if ( BACKTRACKING==0 ) {
                	        DOT439_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT439));
                	        ADAPTOR->addChild(ADAPTOR, root_0, DOT439_tree);
                	        }
                	        IDENTIFIER440 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_componentRelationConstraint6927); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecomponentRelationConstraintEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }
                	        if ( BACKTRACKING==0 ) {
                	        IDENTIFIER440_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER440));
                	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER440_tree);
                	        }

                	    }
                	    break;

                    }
                }

            }

            R_BRACE441 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_componentRelationConstraint6932); 
            if  (HASEXCEPTION())
            {
                goto rulecomponentRelationConstraintEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            R_BRACE441_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, R_BRACE441));
            ADAPTOR->addChild(ADAPTOR, root_0, R_BRACE441_tree);
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:640:9: ( L_BRACE atNotation ( COMMA atNotation )* R_BRACE )?
            {
                int alt147=2;
                switch ( LA(1) ) 
                {
                    case L_BRACE:
                    	{
                    		alt147=1;
                    	}
                        break;
                }

                switch (alt147) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:640:10: L_BRACE atNotation ( COMMA atNotation )* R_BRACE
            	    {
            	        L_BRACE442 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_componentRelationConstraint6945); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomponentRelationConstraintEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        L_BRACE442_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, L_BRACE442));
            	        ADAPTOR->addChild(ADAPTOR, root_0, L_BRACE442_tree);
            	        }
            	        FOLLOWPUSH(FOLLOW_atNotation_in_componentRelationConstraint6947);
            	        atNotation443=atNotation(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomponentRelationConstraintEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, atNotation443.tree);

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:640:29: ( COMMA atNotation )*

            	        for (;;)
            	        {
            	            int alt146=2;
            	            switch ( LA(1) ) 
            	            {
            	            case COMMA:
            	            	{
            	            		alt146=1;
            	            	}
            	                break;

            	            }

            	            switch (alt146) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:640:30: COMMA atNotation
            	        	    {
            	        	        COMMA444 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_componentRelationConstraint6950); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulecomponentRelationConstraintEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) {
            	        	        COMMA444_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA444));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA444_tree);
            	        	        }
            	        	        FOLLOWPUSH(FOLLOW_atNotation_in_componentRelationConstraint6952);
            	        	        atNotation445=atNotation(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulecomponentRelationConstraintEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, atNotation445.tree);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop146;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop146: ; /* Jump out to here if this rule does not match */

            	        R_BRACE446 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_componentRelationConstraint6956); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomponentRelationConstraintEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        R_BRACE446_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, R_BRACE446));
            	        ADAPTOR->addChild(ADAPTOR, root_0, R_BRACE446_tree);
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecomponentRelationConstraintEx; /* Prevent compiler warnings */
    rulecomponentRelationConstraintEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(136, componentRelationConstraint_StartIndex); }

    return retval;
}
/* $ANTLR end componentRelationConstraint */

/** 
 * $ANTLR start atNotation
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:642:1: atNotation : ( A_ROND | ( A_ROND_DOT level ) ) componentIdList ;
 */
static asn1Parser_atNotation_return
atNotation(pasn1Parser ctx)
{   
    asn1Parser_atNotation_return retval;
    ANTLR3_UINT32 atNotation_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    A_ROND447;
    pANTLR3_COMMON_TOKEN    A_ROND_DOT448;
    asn1Parser_level_return level449;
    #undef	RETURN_TYPE_level449
    #define	RETURN_TYPE_level449 asn1Parser_level_return

    asn1Parser_componentIdList_return componentIdList450;
    #undef	RETURN_TYPE_componentIdList450
    #define	RETURN_TYPE_componentIdList450 asn1Parser_componentIdList_return

    pANTLR3_BASE_TREE A_ROND447_tree;
    pANTLR3_BASE_TREE A_ROND_DOT448_tree;

    /* Initialize rule variables
     */
    atNotation_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(137)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    A_ROND447       = NULL;
    A_ROND_DOT448       = NULL;
    level449.tree = NULL;

    componentIdList450.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    A_ROND447_tree   = NULL;
    A_ROND_DOT448_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:642:12: ( ( A_ROND | ( A_ROND_DOT level ) ) componentIdList )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:642:15: ( A_ROND | ( A_ROND_DOT level ) ) componentIdList
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:642:15: ( A_ROND | ( A_ROND_DOT level ) )
            {
                int alt148=2;
                switch ( LA(1) ) 
                {
                case A_ROND:
                	{
                		alt148=1;
                	}
                    break;
                case A_ROND_DOT:
                	{
                		alt148=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 148;
                    EXCEPTION->state        = 0;


                    goto ruleatNotationEx;
                }

                switch (alt148) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:642:16: A_ROND
            	    {
            	        A_ROND447 = (pANTLR3_COMMON_TOKEN) MATCHT(A_ROND, &FOLLOW_A_ROND_in_atNotation6968); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleatNotationEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        A_ROND447_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, A_ROND447));
            	        ADAPTOR->addChild(ADAPTOR, root_0, A_ROND447_tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:642:25: ( A_ROND_DOT level )
            	    {
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:642:25: ( A_ROND_DOT level )
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:642:26: A_ROND_DOT level
            	        {
            	            A_ROND_DOT448 = (pANTLR3_COMMON_TOKEN) MATCHT(A_ROND_DOT, &FOLLOW_A_ROND_DOT_in_atNotation6973); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleatNotationEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }
            	            if ( BACKTRACKING==0 ) {
            	            A_ROND_DOT448_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, A_ROND_DOT448));
            	            ADAPTOR->addChild(ADAPTOR, root_0, A_ROND_DOT448_tree);
            	            }
            	            FOLLOWPUSH(FOLLOW_level_in_atNotation6975);
            	            level449=level(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleatNotationEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }
            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, level449.tree);

            	        }


            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_componentIdList_in_atNotation6979);
            componentIdList450=componentIdList(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleatNotationEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, componentIdList450.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleatNotationEx; /* Prevent compiler warnings */
    ruleatNotationEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(137, atNotation_StartIndex); }

    return retval;
}
/* $ANTLR end atNotation */

/** 
 * $ANTLR start level
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:644:1: level : ( DOT level )? ;
 */
static asn1Parser_level_return
level(pasn1Parser ctx)
{   
    asn1Parser_level_return retval;
    ANTLR3_UINT32 level_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DOT451;
    asn1Parser_level_return level452;
    #undef	RETURN_TYPE_level452
    #define	RETURN_TYPE_level452 asn1Parser_level_return

    pANTLR3_BASE_TREE DOT451_tree;

    /* Initialize rule variables
     */
    level_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(138)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    DOT451       = NULL;
    level452.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    DOT451_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:644:7: ( ( DOT level )? )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:644:9: ( DOT level )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:644:9: ( DOT level )?
            {
                int alt149=2;
                switch ( LA(1) ) 
                {
                    case DOT:
                    	{
                    		alt149=1;
                    	}
                        break;
                }

                switch (alt149) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:644:10: DOT level
            	    {
            	        DOT451 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_level6989); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelevelEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        DOT451_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT451));
            	        ADAPTOR->addChild(ADAPTOR, root_0, DOT451_tree);
            	        }
            	        FOLLOWPUSH(FOLLOW_level_in_level6991);
            	        level452=level(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelevelEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, level452.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelevelEx; /* Prevent compiler warnings */
    rulelevelEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(138, level_StartIndex); }

    return retval;
}
/* $ANTLR end level */

/** 
 * $ANTLR start componentIdList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:647:1: componentIdList : IDENTIFIER ( DOT IDENTIFIER )* ;
 */
static asn1Parser_componentIdList_return
componentIdList(pasn1Parser ctx)
{   
    asn1Parser_componentIdList_return retval;
    ANTLR3_UINT32 componentIdList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER453;
    pANTLR3_COMMON_TOKEN    DOT454;
    pANTLR3_COMMON_TOKEN    IDENTIFIER455;

    pANTLR3_BASE_TREE IDENTIFIER453_tree;
    pANTLR3_BASE_TREE DOT454_tree;
    pANTLR3_BASE_TREE IDENTIFIER455_tree;

    /* Initialize rule variables
     */
    componentIdList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(139)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    IDENTIFIER453       = NULL;
    DOT454       = NULL;
    IDENTIFIER455       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER453_tree   = NULL;
    DOT454_tree   = NULL;
    IDENTIFIER455_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:647:17: ( IDENTIFIER ( DOT IDENTIFIER )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:647:19: IDENTIFIER ( DOT IDENTIFIER )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER453 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_componentIdList7003); 
            if  (HASEXCEPTION())
            {
                goto rulecomponentIdListEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            IDENTIFIER453_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER453));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER453_tree);
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:647:30: ( DOT IDENTIFIER )*

            for (;;)
            {
                int alt150=2;
                switch ( LA(1) ) 
                {
                case DOT:
                	{
                		alt150=1;
                	}
                    break;

                }

                switch (alt150) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:647:31: DOT IDENTIFIER
            	    {
            	        DOT454 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_componentIdList7006); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomponentIdListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        DOT454_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT454));
            	        ADAPTOR->addChild(ADAPTOR, root_0, DOT454_tree);
            	        }
            	        IDENTIFIER455 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_componentIdList7008); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomponentIdListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) {
            	        IDENTIFIER455_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER455));
            	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER455_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop150;	/* break out of the loop */
            	    break;
                }
            }
            loop150: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecomponentIdListEx; /* Prevent compiler warnings */
    rulecomponentIdListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(139, componentIdList_StartIndex); }

    return retval;
}
/* $ANTLR end componentIdList */

/** 
 * $ANTLR start octetStringType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:1: octetStringType : OCTET_LITERAL STRING_LITERAL ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )? -> ^( NODE_INFO[\"OCTET_STRING\"] ^( TAG_SPECIFIC ( $sl)? ( $c1)? ( $c2)? ) ) ;
 */
static asn1Parser_octetStringType_return
octetStringType(pasn1Parser ctx)
{   
    asn1Parser_octetStringType_return retval;
    ANTLR3_UINT32 octetStringType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    sl;
    pANTLR3_COMMON_TOKEN    OCTET_LITERAL456;
    pANTLR3_COMMON_TOKEN    STRING_LITERAL457;
    pANTLR3_COMMON_TOKEN    L_PARAN458;
    pANTLR3_COMMON_TOKEN    R_PARAN459;
    asn1Parser_constraint_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 asn1Parser_constraint_return

    asn1Parser_sizeConstraint_return c2;
    #undef	RETURN_TYPE_c2
    #define	RETURN_TYPE_c2 asn1Parser_sizeConstraint_return

    pANTLR3_BASE_TREE sl_tree;
    pANTLR3_BASE_TREE OCTET_LITERAL456_tree;
    pANTLR3_BASE_TREE STRING_LITERAL457_tree;
    pANTLR3_BASE_TREE L_PARAN458_tree;
    pANTLR3_BASE_TREE R_PARAN459_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_STRING_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SIZE_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_PARAN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_OCTET_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_PARAN;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_constraint;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_sizeConstraint;
    /* Initialize rule variables
     */
    octetStringType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(140)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    sl       = NULL;
    OCTET_LITERAL456       = NULL;
    STRING_LITERAL457       = NULL;
    L_PARAN458       = NULL;
    R_PARAN459       = NULL;
    c1.tree = NULL;

    c2.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    sl_tree   = NULL;
    OCTET_LITERAL456_tree   = NULL;
    STRING_LITERAL457_tree   = NULL;
    L_PARAN458_tree   = NULL;
    R_PARAN459_tree   = NULL;

    stream_STRING_LITERAL   = NULL;
    #define CREATE_stream_STRING_LITERAL  if (stream_STRING_LITERAL == NULL) {stream_STRING_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token STRING_LITERAL"); } 
    stream_SIZE_LITERAL   = NULL;
    #define CREATE_stream_SIZE_LITERAL  if (stream_SIZE_LITERAL == NULL) {stream_SIZE_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SIZE_LITERAL"); } 
    stream_L_PARAN   = NULL;
    #define CREATE_stream_L_PARAN  if (stream_L_PARAN == NULL) {stream_L_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_PARAN"); } 
    stream_OCTET_LITERAL   = NULL;
    #define CREATE_stream_OCTET_LITERAL  if (stream_OCTET_LITERAL == NULL) {stream_OCTET_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token OCTET_LITERAL"); } 
    stream_R_PARAN   = NULL;
    #define CREATE_stream_R_PARAN  if (stream_R_PARAN == NULL) {stream_R_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_PARAN"); } 
    stream_constraint   = NULL;
    #define CREATE_stream_constraint  if (stream_constraint == NULL) {stream_constraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule constraint"); }
    stream_sizeConstraint   = NULL;
    #define CREATE_stream_sizeConstraint  if (stream_sizeConstraint == NULL) {stream_sizeConstraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule sizeConstraint"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:18: ( OCTET_LITERAL STRING_LITERAL ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )? -> ^( NODE_INFO[\"OCTET_STRING\"] ^( TAG_SPECIFIC ( $sl)? ( $c1)? ( $c2)? ) ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:21: OCTET_LITERAL STRING_LITERAL ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )?
        {
            OCTET_LITERAL456 = (pANTLR3_COMMON_TOKEN) MATCHT(OCTET_LITERAL, &FOLLOW_OCTET_LITERAL_in_octetStringType7022); 
            if  (HASEXCEPTION())
            {
                goto ruleoctetStringTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_OCTET_LITERAL; stream_OCTET_LITERAL->add(stream_OCTET_LITERAL, OCTET_LITERAL456, NULL); }

            STRING_LITERAL457 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_octetStringType7024); 
            if  (HASEXCEPTION())
            {
                goto ruleoctetStringTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_STRING_LITERAL; stream_STRING_LITERAL->add(stream_STRING_LITERAL, STRING_LITERAL457, NULL); }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:50: ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )?
            {
                int alt153=2;
                switch ( LA(1) ) 
                {
                    case L_PARAN:
                    	{
                    		alt153=1;
                    	}
                        break;
                }

                switch (alt153) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:51: L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN
            	    {
            	        L_PARAN458 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_octetStringType7027); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoctetStringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_L_PARAN; stream_L_PARAN->add(stream_L_PARAN, L_PARAN458, NULL); }


            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:61: (sl= SIZE_LITERAL )*

            	        for (;;)
            	        {
            	            int alt151=2;
            	            switch ( LA(1) ) 
            	            {
            	            case SIZE_LITERAL:
            	            	{
            	            		{
            	            		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            		    */
            	            		    int LA151_12 = LA(2);
            	            		    if ( (synpred201_asn1(ctx)) ) 
            	            		    {
            	            		        alt151=1;
            	            		    }

            	            		}
            	            	}
            	                break;

            	            }

            	            switch (alt151) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: sl= SIZE_LITERAL
            	        	    {
            	        	        sl = (pANTLR3_COMMON_TOKEN) MATCHT(SIZE_LITERAL, &FOLLOW_SIZE_LITERAL_in_octetStringType7031); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleoctetStringTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        } 
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_SIZE_LITERAL; stream_SIZE_LITERAL->add(stream_SIZE_LITERAL, sl, NULL); }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop151;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop151: ; /* Jump out to here if this rule does not match */


            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:76: (c1= constraint | c2= sizeConstraint )
            	        {
            	            int alt152=2;
            	            switch ( LA(1) ) 
            	            {
            	            case TRUE_LITERAL:
            	            case FALSE_LITERAL:
            	            case TRUE_SMALL_LITERAL:
            	            case FALSE_SMALL_LITERAL:
            	            case L_BRACE:
            	            case L_PARAN:
            	            case MINUS:
            	            case CONTAINING_LITERAL:
            	            case ALL_LITERAL:
            	            case MIN_LITERAL:
            	            case PATTERN_LITERAL:
            	            case CONSTRAINED_LITERAL:
            	            case ENCODED_LITERAL:
            	            case IDENTIFIER:
            	            case NUMBER:
            	            case BSTRING:
            	            	{
            	            		alt152=1;
            	            	}
            	                break;
            	            case SIZE_LITERAL:
            	            	{

            	            		{
            	            		    int LA152_12 = LA(2);
            	            		    if ( (synpred202_asn1(ctx)) ) 
            	            		    {
            	            		        alt152=1;
            	            		    }
            	            		    else if ( (ANTLR3_TRUE) ) 
            	            		    {
            	            		        alt152=2;
            	            		    }
            	            		    else 
            	            		    {
            	            		        if (BACKTRACKING>0)
            	            		        {
            	            		            FAILEDFLAG = ANTLR3_TRUE;
            	            		            return retval;
            	            		        }
            	            		    
            	            		        CONSTRUCTEX();
            	            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		        EXCEPTION->message      = (void *)"";
            	            		        EXCEPTION->decisionNum  = 152;
            	            		        EXCEPTION->state        = 12;


            	            		        goto ruleoctetStringTypeEx;
            	            		    }
            	            		}
            	            	}
            	                break;

            	            default:
            	                if (BACKTRACKING>0)
            	                {
            	                    FAILEDFLAG = ANTLR3_TRUE;
            	                    return retval;
            	                }
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 152;
            	                EXCEPTION->state        = 0;


            	                goto ruleoctetStringTypeEx;
            	            }

            	            switch (alt152) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:77: c1= constraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constraint_in_octetStringType7037);
            	        	        c1=constraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleoctetStringTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_constraint; stream_constraint->add(stream_constraint, c1.tree, NULL); }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:93: c2= sizeConstraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_sizeConstraint_in_octetStringType7043);
            	        	        c2=sizeConstraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleoctetStringTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_sizeConstraint; stream_sizeConstraint->add(stream_sizeConstraint, c2.tree, NULL); }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        R_PARAN459 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_octetStringType7046); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoctetStringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_R_PARAN; stream_R_PARAN->add(stream_R_PARAN, R_PARAN459, NULL); }


            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : c2, c1, sl
             * token labels      : sl
             * rule labels       : retval, c1, c2
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_sl;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c2;

            	stream_sl=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token sl", sl);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_c1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c1", c1.tree != NULL ? c1.tree : NULL);
            	stream_c2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c2", c2.tree != NULL ? c2.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 650:3: -> ^( NODE_INFO[\"OCTET_STRING\"] ^( TAG_SPECIFIC ( $sl)? ( $c1)? ( $c2)? ) )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:650:6: ^( NODE_INFO[\"OCTET_STRING\"] ^( TAG_SPECIFIC ( $sl)? ( $c1)? ( $c2)? ) )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        #if 1 == 2
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, NODE_INFO, TOKTEXT("OCTET_STRING"))
            	        #else
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NODE_INFO, (pANTLR3_UINT8)"OCTET_STRING")
            	        #endif
            	        , root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:650:34: ^( TAG_SPECIFIC ( $sl)? ( $c1)? ( $c2)? )
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TAG_SPECIFIC, (pANTLR3_UINT8)"TAG_SPECIFIC"), root_2));

            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:650:49: ( $sl)?
            	            {
            	            	if ( (stream_sl != NULL && stream_sl->hasNext(stream_sl))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_sl == NULL ? NULL : stream_sl->nextNode(stream_sl));

            	            	}
            	            	if ( stream_sl != NULL) stream_sl->reset(stream_sl);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:650:54: ( $c1)?
            	            {
            	            	if ( (stream_c1 != NULL && stream_c1->hasNext(stream_c1))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_c1 == NULL ? NULL : stream_c1->nextTree(stream_c1));

            	            	}
            	            	if ( stream_c1 != NULL) stream_c1->reset(stream_c1);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:650:59: ( $c2)?
            	            {
            	            	if ( (stream_c2 != NULL && stream_c2->hasNext(stream_c2))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_c2 == NULL ? NULL : stream_c2->nextTree(stream_c2));

            	            	}
            	            	if ( stream_c2 != NULL) stream_c2->reset(stream_c2);

            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_sl != NULL) stream_sl->free(stream_sl); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_c1 != NULL) stream_c1->free(stream_c1);
            	if (stream_c2 != NULL) stream_c2->free(stream_c2);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleoctetStringTypeEx; /* Prevent compiler warnings */
    ruleoctetStringTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_STRING_LITERAL != NULL) stream_STRING_LITERAL->free(stream_STRING_LITERAL);
        if (stream_SIZE_LITERAL != NULL) stream_SIZE_LITERAL->free(stream_SIZE_LITERAL);
        if (stream_L_PARAN != NULL) stream_L_PARAN->free(stream_L_PARAN);
        if (stream_OCTET_LITERAL != NULL) stream_OCTET_LITERAL->free(stream_OCTET_LITERAL);
        if (stream_R_PARAN != NULL) stream_R_PARAN->free(stream_R_PARAN);
        if (stream_constraint != NULL) stream_constraint->free(stream_constraint);
        if (stream_sizeConstraint != NULL) stream_sizeConstraint->free(stream_sizeConstraint);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(140, octetStringType_StartIndex); }

    return retval;
}
/* $ANTLR end octetStringType */

/** 
 * $ANTLR start ia5stringType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:1: ia5stringType : IA5_STRING_LITERAL ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )? -> ^( NODE_INFO[\"IA5String\"] ^( TAG_SPECIFIC ( $sl)? ( $c1)? ( $c2)? ) ) ;
 */
static asn1Parser_ia5stringType_return
ia5stringType(pasn1Parser ctx)
{   
    asn1Parser_ia5stringType_return retval;
    ANTLR3_UINT32 ia5stringType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    sl;
    pANTLR3_COMMON_TOKEN    IA5_STRING_LITERAL460;
    pANTLR3_COMMON_TOKEN    L_PARAN461;
    pANTLR3_COMMON_TOKEN    R_PARAN462;
    asn1Parser_constraint_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 asn1Parser_constraint_return

    asn1Parser_sizeConstraint_return c2;
    #undef	RETURN_TYPE_c2
    #define	RETURN_TYPE_c2 asn1Parser_sizeConstraint_return

    pANTLR3_BASE_TREE sl_tree;
    pANTLR3_BASE_TREE IA5_STRING_LITERAL460_tree;
    pANTLR3_BASE_TREE L_PARAN461_tree;
    pANTLR3_BASE_TREE R_PARAN462_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IA5_STRING_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SIZE_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_PARAN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_PARAN;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_constraint;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_sizeConstraint;
    /* Initialize rule variables
     */
    ia5stringType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(141)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    sl       = NULL;
    IA5_STRING_LITERAL460       = NULL;
    L_PARAN461       = NULL;
    R_PARAN462       = NULL;
    c1.tree = NULL;

    c2.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    sl_tree   = NULL;
    IA5_STRING_LITERAL460_tree   = NULL;
    L_PARAN461_tree   = NULL;
    R_PARAN462_tree   = NULL;

    stream_IA5_STRING_LITERAL   = NULL;
    #define CREATE_stream_IA5_STRING_LITERAL  if (stream_IA5_STRING_LITERAL == NULL) {stream_IA5_STRING_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IA5_STRING_LITERAL"); } 
    stream_SIZE_LITERAL   = NULL;
    #define CREATE_stream_SIZE_LITERAL  if (stream_SIZE_LITERAL == NULL) {stream_SIZE_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SIZE_LITERAL"); } 
    stream_L_PARAN   = NULL;
    #define CREATE_stream_L_PARAN  if (stream_L_PARAN == NULL) {stream_L_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_PARAN"); } 
    stream_R_PARAN   = NULL;
    #define CREATE_stream_R_PARAN  if (stream_R_PARAN == NULL) {stream_R_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_PARAN"); } 
    stream_constraint   = NULL;
    #define CREATE_stream_constraint  if (stream_constraint == NULL) {stream_constraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule constraint"); }
    stream_sizeConstraint   = NULL;
    #define CREATE_stream_sizeConstraint  if (stream_sizeConstraint == NULL) {stream_sizeConstraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule sizeConstraint"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:16: ( IA5_STRING_LITERAL ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )? -> ^( NODE_INFO[\"IA5String\"] ^( TAG_SPECIFIC ( $sl)? ( $c1)? ( $c2)? ) ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:19: IA5_STRING_LITERAL ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )?
        {
            IA5_STRING_LITERAL460 = (pANTLR3_COMMON_TOKEN) MATCHT(IA5_STRING_LITERAL, &FOLLOW_IA5_STRING_LITERAL_in_ia5stringType7085); 
            if  (HASEXCEPTION())
            {
                goto ruleia5stringTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_IA5_STRING_LITERAL; stream_IA5_STRING_LITERAL->add(stream_IA5_STRING_LITERAL, IA5_STRING_LITERAL460, NULL); }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:38: ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )?
            {
                int alt156=2;
                switch ( LA(1) ) 
                {
                    case L_PARAN:
                    	{
                    		alt156=1;
                    	}
                        break;
                }

                switch (alt156) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:39: L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN
            	    {
            	        L_PARAN461 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_ia5stringType7088); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleia5stringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_L_PARAN; stream_L_PARAN->add(stream_L_PARAN, L_PARAN461, NULL); }


            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:49: (sl= SIZE_LITERAL )*

            	        for (;;)
            	        {
            	            int alt154=2;
            	            switch ( LA(1) ) 
            	            {
            	            case SIZE_LITERAL:
            	            	{
            	            		{
            	            		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            		    */
            	            		    int LA154_12 = LA(2);
            	            		    if ( (synpred204_asn1(ctx)) ) 
            	            		    {
            	            		        alt154=1;
            	            		    }

            	            		}
            	            	}
            	                break;

            	            }

            	            switch (alt154) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: sl= SIZE_LITERAL
            	        	    {
            	        	        sl = (pANTLR3_COMMON_TOKEN) MATCHT(SIZE_LITERAL, &FOLLOW_SIZE_LITERAL_in_ia5stringType7092); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleia5stringTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        } 
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_SIZE_LITERAL; stream_SIZE_LITERAL->add(stream_SIZE_LITERAL, sl, NULL); }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop154;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop154: ; /* Jump out to here if this rule does not match */


            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:64: (c1= constraint | c2= sizeConstraint )
            	        {
            	            int alt155=2;
            	            switch ( LA(1) ) 
            	            {
            	            case TRUE_LITERAL:
            	            case FALSE_LITERAL:
            	            case TRUE_SMALL_LITERAL:
            	            case FALSE_SMALL_LITERAL:
            	            case L_BRACE:
            	            case L_PARAN:
            	            case MINUS:
            	            case CONTAINING_LITERAL:
            	            case ALL_LITERAL:
            	            case MIN_LITERAL:
            	            case PATTERN_LITERAL:
            	            case CONSTRAINED_LITERAL:
            	            case ENCODED_LITERAL:
            	            case IDENTIFIER:
            	            case NUMBER:
            	            case BSTRING:
            	            	{
            	            		alt155=1;
            	            	}
            	                break;
            	            case SIZE_LITERAL:
            	            	{

            	            		{
            	            		    int LA155_12 = LA(2);
            	            		    if ( (synpred205_asn1(ctx)) ) 
            	            		    {
            	            		        alt155=1;
            	            		    }
            	            		    else if ( (ANTLR3_TRUE) ) 
            	            		    {
            	            		        alt155=2;
            	            		    }
            	            		    else 
            	            		    {
            	            		        if (BACKTRACKING>0)
            	            		        {
            	            		            FAILEDFLAG = ANTLR3_TRUE;
            	            		            return retval;
            	            		        }
            	            		    
            	            		        CONSTRUCTEX();
            	            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		        EXCEPTION->message      = (void *)"";
            	            		        EXCEPTION->decisionNum  = 155;
            	            		        EXCEPTION->state        = 12;


            	            		        goto ruleia5stringTypeEx;
            	            		    }
            	            		}
            	            	}
            	                break;

            	            default:
            	                if (BACKTRACKING>0)
            	                {
            	                    FAILEDFLAG = ANTLR3_TRUE;
            	                    return retval;
            	                }
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 155;
            	                EXCEPTION->state        = 0;


            	                goto ruleia5stringTypeEx;
            	            }

            	            switch (alt155) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:65: c1= constraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constraint_in_ia5stringType7098);
            	        	        c1=constraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleia5stringTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_constraint; stream_constraint->add(stream_constraint, c1.tree, NULL); }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:81: c2= sizeConstraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_sizeConstraint_in_ia5stringType7104);
            	        	        c2=sizeConstraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleia5stringTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_sizeConstraint; stream_sizeConstraint->add(stream_sizeConstraint, c2.tree, NULL); }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        R_PARAN462 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_ia5stringType7107); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleia5stringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_R_PARAN; stream_R_PARAN->add(stream_R_PARAN, R_PARAN462, NULL); }


            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : c2, c1, sl
             * token labels      : sl
             * rule labels       : retval, c1, c2
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_sl;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c2;

            	stream_sl=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token sl", sl);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_c1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c1", c1.tree != NULL ? c1.tree : NULL);
            	stream_c2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c2", c2.tree != NULL ? c2.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 654:3: -> ^( NODE_INFO[\"IA5String\"] ^( TAG_SPECIFIC ( $sl)? ( $c1)? ( $c2)? ) )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:654:6: ^( NODE_INFO[\"IA5String\"] ^( TAG_SPECIFIC ( $sl)? ( $c1)? ( $c2)? ) )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        #if 1 == 2
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, NODE_INFO, TOKTEXT("IA5String"))
            	        #else
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NODE_INFO, (pANTLR3_UINT8)"IA5String")
            	        #endif
            	        , root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:654:31: ^( TAG_SPECIFIC ( $sl)? ( $c1)? ( $c2)? )
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TAG_SPECIFIC, (pANTLR3_UINT8)"TAG_SPECIFIC"), root_2));

            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:654:46: ( $sl)?
            	            {
            	            	if ( (stream_sl != NULL && stream_sl->hasNext(stream_sl))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_sl == NULL ? NULL : stream_sl->nextNode(stream_sl));

            	            	}
            	            	if ( stream_sl != NULL) stream_sl->reset(stream_sl);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:654:51: ( $c1)?
            	            {
            	            	if ( (stream_c1 != NULL && stream_c1->hasNext(stream_c1))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_c1 == NULL ? NULL : stream_c1->nextTree(stream_c1));

            	            	}
            	            	if ( stream_c1 != NULL) stream_c1->reset(stream_c1);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:654:56: ( $c2)?
            	            {
            	            	if ( (stream_c2 != NULL && stream_c2->hasNext(stream_c2))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_c2 == NULL ? NULL : stream_c2->nextTree(stream_c2));

            	            	}
            	            	if ( stream_c2 != NULL) stream_c2->reset(stream_c2);

            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_sl != NULL) stream_sl->free(stream_sl); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_c1 != NULL) stream_c1->free(stream_c1);
            	if (stream_c2 != NULL) stream_c2->free(stream_c2);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleia5stringTypeEx; /* Prevent compiler warnings */
    ruleia5stringTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_IA5_STRING_LITERAL != NULL) stream_IA5_STRING_LITERAL->free(stream_IA5_STRING_LITERAL);
        if (stream_SIZE_LITERAL != NULL) stream_SIZE_LITERAL->free(stream_SIZE_LITERAL);
        if (stream_L_PARAN != NULL) stream_L_PARAN->free(stream_L_PARAN);
        if (stream_R_PARAN != NULL) stream_R_PARAN->free(stream_R_PARAN);
        if (stream_constraint != NULL) stream_constraint->free(stream_constraint);
        if (stream_sizeConstraint != NULL) stream_sizeConstraint->free(stream_sizeConstraint);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(141, ia5stringType_StartIndex); }

    return retval;
}
/* $ANTLR end ia5stringType */

/** 
 * $ANTLR start nullType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:658:1: nullType : NULL_LITERAL ;
 */
static asn1Parser_nullType_return
nullType(pasn1Parser ctx)
{   
    asn1Parser_nullType_return retval;
    ANTLR3_UINT32 nullType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    NULL_LITERAL463;

    pANTLR3_BASE_TREE NULL_LITERAL463_tree;

    /* Initialize rule variables
     */
    nullType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(142)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    NULL_LITERAL463       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    NULL_LITERAL463_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:658:10: ( NULL_LITERAL )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:658:13: NULL_LITERAL
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            NULL_LITERAL463 = (pANTLR3_COMMON_TOKEN) MATCHT(NULL_LITERAL, &FOLLOW_NULL_LITERAL_in_nullType7147); 
            if  (HASEXCEPTION())
            {
                goto rulenullTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            NULL_LITERAL463_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NULL_LITERAL463));
            ADAPTOR->addChild(ADAPTOR, root_0, NULL_LITERAL463_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenullTypeEx; /* Prevent compiler warnings */
    rulenullTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(142, nullType_StartIndex); }

    return retval;
}
/* $ANTLR end nullType */

/** 
 * $ANTLR start booleanType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:660:1: booleanType : BOOLEAN_LITERAL ;
 */
static asn1Parser_booleanType_return
booleanType(pasn1Parser ctx)
{   
    asn1Parser_booleanType_return retval;
    ANTLR3_UINT32 booleanType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    BOOLEAN_LITERAL464;

    pANTLR3_BASE_TREE BOOLEAN_LITERAL464_tree;

    /* Initialize rule variables
     */
    booleanType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(143)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    BOOLEAN_LITERAL464       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    BOOLEAN_LITERAL464_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:660:13: ( BOOLEAN_LITERAL )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:660:15: BOOLEAN_LITERAL
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            BOOLEAN_LITERAL464 = (pANTLR3_COMMON_TOKEN) MATCHT(BOOLEAN_LITERAL, &FOLLOW_BOOLEAN_LITERAL_in_booleanType7155); 
            if  (HASEXCEPTION())
            {
                goto rulebooleanTypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            BOOLEAN_LITERAL464_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BOOLEAN_LITERAL464));
            ADAPTOR->addChild(ADAPTOR, root_0, BOOLEAN_LITERAL464_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebooleanTypeEx; /* Prevent compiler warnings */
    rulebooleanTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(143, booleanType_StartIndex); }

    return retval;
}
/* $ANTLR end booleanType */

/** 
 * $ANTLR start bitStringType
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:1: bitStringType : ( BIT_LITERAL STRING_LITERAL ) ( L_BRACE nb= namedBitList R_BRACE )? ( DEFAULT_LITERAL L_BRACE nb2= namedBitList R_BRACE )? ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )? -> ^( NODE_INFO[\"BIT_STRING\"] ^( TAG_SPECIFIC ( $nb)? ( $sl)? ( $c1)? ( $c2)? ) ) ;
 */
static asn1Parser_bitStringType_return
bitStringType(pasn1Parser ctx)
{   
    asn1Parser_bitStringType_return retval;
    ANTLR3_UINT32 bitStringType_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    sl;
    pANTLR3_COMMON_TOKEN    BIT_LITERAL465;
    pANTLR3_COMMON_TOKEN    STRING_LITERAL466;
    pANTLR3_COMMON_TOKEN    L_BRACE467;
    pANTLR3_COMMON_TOKEN    R_BRACE468;
    pANTLR3_COMMON_TOKEN    DEFAULT_LITERAL469;
    pANTLR3_COMMON_TOKEN    L_BRACE470;
    pANTLR3_COMMON_TOKEN    R_BRACE471;
    pANTLR3_COMMON_TOKEN    L_PARAN472;
    pANTLR3_COMMON_TOKEN    R_PARAN473;
    asn1Parser_namedBitList_return nb;
    #undef	RETURN_TYPE_nb
    #define	RETURN_TYPE_nb asn1Parser_namedBitList_return

    asn1Parser_namedBitList_return nb2;
    #undef	RETURN_TYPE_nb2
    #define	RETURN_TYPE_nb2 asn1Parser_namedBitList_return

    asn1Parser_constraint_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 asn1Parser_constraint_return

    asn1Parser_sizeConstraint_return c2;
    #undef	RETURN_TYPE_c2
    #define	RETURN_TYPE_c2 asn1Parser_sizeConstraint_return

    pANTLR3_BASE_TREE sl_tree;
    pANTLR3_BASE_TREE BIT_LITERAL465_tree;
    pANTLR3_BASE_TREE STRING_LITERAL466_tree;
    pANTLR3_BASE_TREE L_BRACE467_tree;
    pANTLR3_BASE_TREE R_BRACE468_tree;
    pANTLR3_BASE_TREE DEFAULT_LITERAL469_tree;
    pANTLR3_BASE_TREE L_BRACE470_tree;
    pANTLR3_BASE_TREE R_BRACE471_tree;
    pANTLR3_BASE_TREE L_PARAN472_tree;
    pANTLR3_BASE_TREE R_PARAN473_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_STRING_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_BRACE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SIZE_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BIT_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_PARAN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_DEFAULT_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_PARAN;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_constraint;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_namedBitList;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_sizeConstraint;
    /* Initialize rule variables
     */
    bitStringType_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(144)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    sl       = NULL;
    BIT_LITERAL465       = NULL;
    STRING_LITERAL466       = NULL;
    L_BRACE467       = NULL;
    R_BRACE468       = NULL;
    DEFAULT_LITERAL469       = NULL;
    L_BRACE470       = NULL;
    R_BRACE471       = NULL;
    L_PARAN472       = NULL;
    R_PARAN473       = NULL;
    nb.tree = NULL;

    nb2.tree = NULL;

    c1.tree = NULL;

    c2.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    sl_tree   = NULL;
    BIT_LITERAL465_tree   = NULL;
    STRING_LITERAL466_tree   = NULL;
    L_BRACE467_tree   = NULL;
    R_BRACE468_tree   = NULL;
    DEFAULT_LITERAL469_tree   = NULL;
    L_BRACE470_tree   = NULL;
    R_BRACE471_tree   = NULL;
    L_PARAN472_tree   = NULL;
    R_PARAN473_tree   = NULL;

    stream_L_BRACE   = NULL;
    #define CREATE_stream_L_BRACE  if (stream_L_BRACE == NULL) {stream_L_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_BRACE"); } 
    stream_STRING_LITERAL   = NULL;
    #define CREATE_stream_STRING_LITERAL  if (stream_STRING_LITERAL == NULL) {stream_STRING_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token STRING_LITERAL"); } 
    stream_R_BRACE   = NULL;
    #define CREATE_stream_R_BRACE  if (stream_R_BRACE == NULL) {stream_R_BRACE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_BRACE"); } 
    stream_SIZE_LITERAL   = NULL;
    #define CREATE_stream_SIZE_LITERAL  if (stream_SIZE_LITERAL == NULL) {stream_SIZE_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SIZE_LITERAL"); } 
    stream_BIT_LITERAL   = NULL;
    #define CREATE_stream_BIT_LITERAL  if (stream_BIT_LITERAL == NULL) {stream_BIT_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BIT_LITERAL"); } 
    stream_L_PARAN   = NULL;
    #define CREATE_stream_L_PARAN  if (stream_L_PARAN == NULL) {stream_L_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_PARAN"); } 
    stream_DEFAULT_LITERAL   = NULL;
    #define CREATE_stream_DEFAULT_LITERAL  if (stream_DEFAULT_LITERAL == NULL) {stream_DEFAULT_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token DEFAULT_LITERAL"); } 
    stream_R_PARAN   = NULL;
    #define CREATE_stream_R_PARAN  if (stream_R_PARAN == NULL) {stream_R_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_PARAN"); } 
    stream_constraint   = NULL;
    #define CREATE_stream_constraint  if (stream_constraint == NULL) {stream_constraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule constraint"); }
    stream_namedBitList   = NULL;
    #define CREATE_stream_namedBitList  if (stream_namedBitList == NULL) {stream_namedBitList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule namedBitList"); }
    stream_sizeConstraint   = NULL;
    #define CREATE_stream_sizeConstraint  if (stream_sizeConstraint == NULL) {stream_sizeConstraint = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule sizeConstraint"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:18: ( ( BIT_LITERAL STRING_LITERAL ) ( L_BRACE nb= namedBitList R_BRACE )? ( DEFAULT_LITERAL L_BRACE nb2= namedBitList R_BRACE )? ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )? -> ^( NODE_INFO[\"BIT_STRING\"] ^( TAG_SPECIFIC ( $nb)? ( $sl)? ( $c1)? ( $c2)? ) ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:20: ( BIT_LITERAL STRING_LITERAL ) ( L_BRACE nb= namedBitList R_BRACE )? ( DEFAULT_LITERAL L_BRACE nb2= namedBitList R_BRACE )? ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )?
        {
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:20: ( BIT_LITERAL STRING_LITERAL )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:21: BIT_LITERAL STRING_LITERAL
            {
                BIT_LITERAL465 = (pANTLR3_COMMON_TOKEN) MATCHT(BIT_LITERAL, &FOLLOW_BIT_LITERAL_in_bitStringType7169); 
                if  (HASEXCEPTION())
                {
                    goto rulebitStringTypeEx;
                }
                if (HASFAILED())
                {
                    return retval;
                } 
                if ( BACKTRACKING==0 ) { CREATE_stream_BIT_LITERAL; stream_BIT_LITERAL->add(stream_BIT_LITERAL, BIT_LITERAL465, NULL); }

                STRING_LITERAL466 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_bitStringType7171); 
                if  (HASEXCEPTION())
                {
                    goto rulebitStringTypeEx;
                }
                if (HASFAILED())
                {
                    return retval;
                } 
                if ( BACKTRACKING==0 ) { CREATE_stream_STRING_LITERAL; stream_STRING_LITERAL->add(stream_STRING_LITERAL, STRING_LITERAL466, NULL); }


            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:49: ( L_BRACE nb= namedBitList R_BRACE )?
            {
                int alt157=2;
                switch ( LA(1) ) 
                {
                    case L_BRACE:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		    case IDENTIFIER:
                    		    	{
                    		    		switch ( LA(3) ) 
                    		    		{
                    		    		    case COMMA:
                    		    		    	{
                    		    		    		switch ( LA(4) ) 
                    		    		    		{
                    		    		    		    case IDENTIFIER:
                    		    		    		    	{
                    		    		    		    		alt157=1;
                    		    		    		    	}
                    		    		    		        break;
                    		    		    		}

                    		    		    	}
                    		    		        break;
                    		    		    case R_BRACE:
                    		    		    	{
                    		    		    		{
                    		    		    		    int LA157_5 = LA(4);
                    		    		    		    if ( (synpred207_asn1(ctx)) ) 
                    		    		    		    {
                    		    		    		        alt157=1;
                    		    		    		    }
                    		    		    		}
                    		    		    	}
                    		    		        break;
                    		    		    case L_PARAN:
                    		    		    case R_PARAN:
                    		    		    case IDENTIFIER:
                    		    		    case NUMBER:
                    		    		    	{
                    		    		    		alt157=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt157) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:50: L_BRACE nb= namedBitList R_BRACE
            	    {
            	        L_BRACE467 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_bitStringType7175); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitStringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_L_BRACE; stream_L_BRACE->add(stream_L_BRACE, L_BRACE467, NULL); }

            	        FOLLOWPUSH(FOLLOW_namedBitList_in_bitStringType7179);
            	        nb=namedBitList(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitStringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_namedBitList; stream_namedBitList->add(stream_namedBitList, nb.tree, NULL); }
            	        R_BRACE468 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_bitStringType7181); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitStringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_R_BRACE; stream_R_BRACE->add(stream_R_BRACE, R_BRACE468, NULL); }


            	    }
            	    break;

                }
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:84: ( DEFAULT_LITERAL L_BRACE nb2= namedBitList R_BRACE )?
            {
                int alt158=2;
                switch ( LA(1) ) 
                {
                    case DEFAULT_LITERAL:
                    	{
                    		{
                    		    int LA158_1 = LA(2);
                    		    if ( (synpred208_asn1(ctx)) ) 
                    		    {
                    		        alt158=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt158) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:85: DEFAULT_LITERAL L_BRACE nb2= namedBitList R_BRACE
            	    {
            	        DEFAULT_LITERAL469 = (pANTLR3_COMMON_TOKEN) MATCHT(DEFAULT_LITERAL, &FOLLOW_DEFAULT_LITERAL_in_bitStringType7186); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitStringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_DEFAULT_LITERAL; stream_DEFAULT_LITERAL->add(stream_DEFAULT_LITERAL, DEFAULT_LITERAL469, NULL); }

            	        L_BRACE470 = (pANTLR3_COMMON_TOKEN) MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_bitStringType7188); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitStringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_L_BRACE; stream_L_BRACE->add(stream_L_BRACE, L_BRACE470, NULL); }

            	        FOLLOWPUSH(FOLLOW_namedBitList_in_bitStringType7192);
            	        nb2=namedBitList(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitStringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_namedBitList; stream_namedBitList->add(stream_namedBitList, nb2.tree, NULL); }
            	        R_BRACE471 = (pANTLR3_COMMON_TOKEN) MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_bitStringType7194); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitStringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_R_BRACE; stream_R_BRACE->add(stream_R_BRACE, R_BRACE471, NULL); }


            	    }
            	    break;

                }
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:136: ( L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN )?
            {
                int alt161=2;
                switch ( LA(1) ) 
                {
                    case L_PARAN:
                    	{
                    		alt161=1;
                    	}
                        break;
                }

                switch (alt161) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:137: L_PARAN (sl= SIZE_LITERAL )* (c1= constraint | c2= sizeConstraint ) R_PARAN
            	    {
            	        L_PARAN472 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_bitStringType7199); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitStringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_L_PARAN; stream_L_PARAN->add(stream_L_PARAN, L_PARAN472, NULL); }


            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:147: (sl= SIZE_LITERAL )*

            	        for (;;)
            	        {
            	            int alt159=2;
            	            switch ( LA(1) ) 
            	            {
            	            case SIZE_LITERAL:
            	            	{
            	            		{
            	            		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            		    */
            	            		    int LA159_12 = LA(2);
            	            		    if ( (synpred209_asn1(ctx)) ) 
            	            		    {
            	            		        alt159=1;
            	            		    }

            	            		}
            	            	}
            	                break;

            	            }

            	            switch (alt159) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: sl= SIZE_LITERAL
            	        	    {
            	        	        sl = (pANTLR3_COMMON_TOKEN) MATCHT(SIZE_LITERAL, &FOLLOW_SIZE_LITERAL_in_bitStringType7203); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebitStringTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        } 
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_SIZE_LITERAL; stream_SIZE_LITERAL->add(stream_SIZE_LITERAL, sl, NULL); }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop159;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop159: ; /* Jump out to here if this rule does not match */


            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:162: (c1= constraint | c2= sizeConstraint )
            	        {
            	            int alt160=2;
            	            switch ( LA(1) ) 
            	            {
            	            case TRUE_LITERAL:
            	            case FALSE_LITERAL:
            	            case TRUE_SMALL_LITERAL:
            	            case FALSE_SMALL_LITERAL:
            	            case L_BRACE:
            	            case L_PARAN:
            	            case MINUS:
            	            case CONTAINING_LITERAL:
            	            case ALL_LITERAL:
            	            case MIN_LITERAL:
            	            case PATTERN_LITERAL:
            	            case CONSTRAINED_LITERAL:
            	            case ENCODED_LITERAL:
            	            case IDENTIFIER:
            	            case NUMBER:
            	            case BSTRING:
            	            	{
            	            		alt160=1;
            	            	}
            	                break;
            	            case SIZE_LITERAL:
            	            	{

            	            		{
            	            		    int LA160_12 = LA(2);
            	            		    if ( (synpred210_asn1(ctx)) ) 
            	            		    {
            	            		        alt160=1;
            	            		    }
            	            		    else if ( (ANTLR3_TRUE) ) 
            	            		    {
            	            		        alt160=2;
            	            		    }
            	            		    else 
            	            		    {
            	            		        if (BACKTRACKING>0)
            	            		        {
            	            		            FAILEDFLAG = ANTLR3_TRUE;
            	            		            return retval;
            	            		        }
            	            		    
            	            		        CONSTRUCTEX();
            	            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		        EXCEPTION->message      = (void *)"";
            	            		        EXCEPTION->decisionNum  = 160;
            	            		        EXCEPTION->state        = 12;


            	            		        goto rulebitStringTypeEx;
            	            		    }
            	            		}
            	            	}
            	                break;

            	            default:
            	                if (BACKTRACKING>0)
            	                {
            	                    FAILEDFLAG = ANTLR3_TRUE;
            	                    return retval;
            	                }
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 160;
            	                EXCEPTION->state        = 0;


            	                goto rulebitStringTypeEx;
            	            }

            	            switch (alt160) 
            	            {
            	        	case 1:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:163: c1= constraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constraint_in_bitStringType7209);
            	        	        c1=constraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebitStringTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_constraint; stream_constraint->add(stream_constraint, c1.tree, NULL); }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:179: c2= sizeConstraint
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_sizeConstraint_in_bitStringType7215);
            	        	        c2=sizeConstraint(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebitStringTypeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_sizeConstraint; stream_sizeConstraint->add(stream_sizeConstraint, c2.tree, NULL); }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        R_PARAN473 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_bitStringType7218); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebitStringTypeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_R_PARAN; stream_R_PARAN->add(stream_R_PARAN, R_PARAN473, NULL); }


            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : c2, sl, nb, c1
             * token labels      : sl
             * rule labels       : retval, c1, nb, c2
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_sl;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_nb;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c2;

            	stream_sl=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token sl", sl);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_c1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c1", c1.tree != NULL ? c1.tree : NULL);
            	stream_nb=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token nb", nb.tree != NULL ? nb.tree : NULL);
            	stream_c2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c2", c2.tree != NULL ? c2.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 664:3: -> ^( NODE_INFO[\"BIT_STRING\"] ^( TAG_SPECIFIC ( $nb)? ( $sl)? ( $c1)? ( $c2)? ) )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:664:6: ^( NODE_INFO[\"BIT_STRING\"] ^( TAG_SPECIFIC ( $nb)? ( $sl)? ( $c1)? ( $c2)? ) )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        #if 1 == 2
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, NODE_INFO, TOKTEXT("BIT_STRING"))
            	        #else
            	        	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NODE_INFO, (pANTLR3_UINT8)"BIT_STRING")
            	        #endif
            	        , root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:664:32: ^( TAG_SPECIFIC ( $nb)? ( $sl)? ( $c1)? ( $c2)? )
            	        {
            	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TAG_SPECIFIC, (pANTLR3_UINT8)"TAG_SPECIFIC"), root_2));

            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:664:47: ( $nb)?
            	            {
            	            	if ( (stream_nb != NULL && stream_nb->hasNext(stream_nb))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_nb == NULL ? NULL : stream_nb->nextTree(stream_nb));

            	            	}
            	            	if ( stream_nb != NULL) stream_nb->reset(stream_nb);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:664:52: ( $sl)?
            	            {
            	            	if ( (stream_sl != NULL && stream_sl->hasNext(stream_sl))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_sl == NULL ? NULL : stream_sl->nextNode(stream_sl));

            	            	}
            	            	if ( stream_sl != NULL) stream_sl->reset(stream_sl);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:664:57: ( $c1)?
            	            {
            	            	if ( (stream_c1 != NULL && stream_c1->hasNext(stream_c1))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_c1 == NULL ? NULL : stream_c1->nextTree(stream_c1));

            	            	}
            	            	if ( stream_c1 != NULL) stream_c1->reset(stream_c1);

            	            }
            	            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:664:62: ( $c2)?
            	            {
            	            	if ( (stream_c2 != NULL && stream_c2->hasNext(stream_c2))  )
            	            	{
            	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_c2 == NULL ? NULL : stream_c2->nextTree(stream_c2));

            	            	}
            	            	if ( stream_c2 != NULL) stream_c2->reset(stream_c2);

            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_sl != NULL) stream_sl->free(stream_sl); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_c1 != NULL) stream_c1->free(stream_c1);
            	if (stream_nb != NULL) stream_nb->free(stream_nb);
            	if (stream_c2 != NULL) stream_c2->free(stream_c2);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebitStringTypeEx; /* Prevent compiler warnings */
    rulebitStringTypeEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_L_BRACE != NULL) stream_L_BRACE->free(stream_L_BRACE);
        if (stream_STRING_LITERAL != NULL) stream_STRING_LITERAL->free(stream_STRING_LITERAL);
        if (stream_R_BRACE != NULL) stream_R_BRACE->free(stream_R_BRACE);
        if (stream_SIZE_LITERAL != NULL) stream_SIZE_LITERAL->free(stream_SIZE_LITERAL);
        if (stream_BIT_LITERAL != NULL) stream_BIT_LITERAL->free(stream_BIT_LITERAL);
        if (stream_L_PARAN != NULL) stream_L_PARAN->free(stream_L_PARAN);
        if (stream_DEFAULT_LITERAL != NULL) stream_DEFAULT_LITERAL->free(stream_DEFAULT_LITERAL);
        if (stream_R_PARAN != NULL) stream_R_PARAN->free(stream_R_PARAN);
        if (stream_constraint != NULL) stream_constraint->free(stream_constraint);
        if (stream_namedBitList != NULL) stream_namedBitList->free(stream_namedBitList);
        if (stream_sizeConstraint != NULL) stream_sizeConstraint->free(stream_sizeConstraint);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(144, bitStringType_StartIndex); }

    return retval;
}
/* $ANTLR end bitStringType */

/** 
 * $ANTLR start namedBitList
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:666:1: namedBitList : ( namedBit ) ( COMMA namedBit )* ;
 */
static asn1Parser_namedBitList_return
namedBitList(pasn1Parser ctx)
{   
    asn1Parser_namedBitList_return retval;
    ANTLR3_UINT32 namedBitList_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA475;
    asn1Parser_namedBit_return namedBit474;
    #undef	RETURN_TYPE_namedBit474
    #define	RETURN_TYPE_namedBit474 asn1Parser_namedBit_return

    asn1Parser_namedBit_return namedBit476;
    #undef	RETURN_TYPE_namedBit476
    #define	RETURN_TYPE_namedBit476 asn1Parser_namedBit_return

    pANTLR3_BASE_TREE COMMA475_tree;

    /* Initialize rule variables
     */
    namedBitList_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(145)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    COMMA475       = NULL;
    namedBit474.tree = NULL;

    namedBit476.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA475_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:666:13: ( ( namedBit ) ( COMMA namedBit )* )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:666:15: ( namedBit ) ( COMMA namedBit )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:666:15: ( namedBit )
            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:666:16: namedBit
            {
                FOLLOWPUSH(FOLLOW_namedBit_in_namedBitList7257);
                namedBit474=namedBit(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulenamedBitListEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, namedBit474.tree);

            }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:666:26: ( COMMA namedBit )*

            for (;;)
            {
                int alt162=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt162=1;
                	}
                    break;

                }

                switch (alt162) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:666:27: COMMA namedBit
            	    {
            	        COMMA475 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_namedBitList7261); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenamedBitListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_namedBit_in_namedBitList7264);
            	        namedBit476=namedBit(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenamedBitListEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, namedBit476.tree);

            	    }
            	    break;

            	default:
            	    goto loop162;	/* break out of the loop */
            	    break;
                }
            }
            loop162: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenamedBitListEx; /* Prevent compiler warnings */
    rulenamedBitListEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(145, namedBitList_StartIndex); }

    return retval;
}
/* $ANTLR end namedBitList */

/** 
 * $ANTLR start namedBit
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:668:1: namedBit : IDENTIFIER ( L_PARAN )? (num= NUMBER | dv= definedValue )? ( R_PARAN )? -> ^( IDENTIFIER ( $num)? ( $dv)? ) ;
 */
static asn1Parser_namedBit_return
namedBit(pasn1Parser ctx)
{   
    asn1Parser_namedBit_return retval;
    ANTLR3_UINT32 namedBit_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    num;
    pANTLR3_COMMON_TOKEN    IDENTIFIER477;
    pANTLR3_COMMON_TOKEN    L_PARAN478;
    pANTLR3_COMMON_TOKEN    R_PARAN479;
    asn1Parser_definedValue_return dv;
    #undef	RETURN_TYPE_dv
    #define	RETURN_TYPE_dv asn1Parser_definedValue_return

    pANTLR3_BASE_TREE num_tree;
    pANTLR3_BASE_TREE IDENTIFIER477_tree;
    pANTLR3_BASE_TREE L_PARAN478_tree;
    pANTLR3_BASE_TREE R_PARAN479_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_L_PARAN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_R_PARAN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NUMBER;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_definedValue;
    /* Initialize rule variables
     */
    namedBit_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(146)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    num       = NULL;
    IDENTIFIER477       = NULL;
    L_PARAN478       = NULL;
    R_PARAN479       = NULL;
    dv.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    num_tree   = NULL;
    IDENTIFIER477_tree   = NULL;
    L_PARAN478_tree   = NULL;
    R_PARAN479_tree   = NULL;

    stream_L_PARAN   = NULL;
    #define CREATE_stream_L_PARAN  if (stream_L_PARAN == NULL) {stream_L_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token L_PARAN"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_R_PARAN   = NULL;
    #define CREATE_stream_R_PARAN  if (stream_R_PARAN == NULL) {stream_R_PARAN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token R_PARAN"); } 
    stream_NUMBER   = NULL;
    #define CREATE_stream_NUMBER  if (stream_NUMBER == NULL) {stream_NUMBER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token NUMBER"); } 
    stream_definedValue   = NULL;
    #define CREATE_stream_definedValue  if (stream_definedValue == NULL) {stream_definedValue = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule definedValue"); }

    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:668:15: ( IDENTIFIER ( L_PARAN )? (num= NUMBER | dv= definedValue )? ( R_PARAN )? -> ^( IDENTIFIER ( $num)? ( $dv)? ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:668:17: IDENTIFIER ( L_PARAN )? (num= NUMBER | dv= definedValue )? ( R_PARAN )?
        {
            IDENTIFIER477 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_namedBit7280); 
            if  (HASEXCEPTION())
            {
                goto rulenamedBitEx;
            }
            if (HASFAILED())
            {
                return retval;
            } 
            if ( BACKTRACKING==0 ) { CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, IDENTIFIER477, NULL); }


            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:668:28: ( L_PARAN )?
            {
                int alt163=2;
                switch ( LA(1) ) 
                {
                    case L_PARAN:
                    	{
                    		alt163=1;
                    	}
                        break;
                }

                switch (alt163) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: L_PARAN
            	    {
            	        L_PARAN478 = (pANTLR3_COMMON_TOKEN) MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_namedBit7282); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenamedBitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_L_PARAN; stream_L_PARAN->add(stream_L_PARAN, L_PARAN478, NULL); }


            	    }
            	    break;

                }
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:668:37: (num= NUMBER | dv= definedValue )?
            {
                int alt164=3;
                switch ( LA(1) ) 
                {
                    case NUMBER:
                    	{
                    		alt164=1;
                    	}
                        break;
                    case IDENTIFIER:
                    	{
                    		alt164=2;
                    	}
                        break;
                }

                switch (alt164) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:668:38: num= NUMBER
            	    {
            	        num = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_namedBit7288); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenamedBitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_NUMBER; stream_NUMBER->add(stream_NUMBER, num, NULL); }


            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:668:51: dv= definedValue
            	    {
            	        FOLLOWPUSH(FOLLOW_definedValue_in_namedBit7294);
            	        dv=definedValue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenamedBitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        if ( BACKTRACKING==0 ) { CREATE_stream_definedValue; stream_definedValue->add(stream_definedValue, dv.tree, NULL); }

            	    }
            	    break;

                }
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:668:69: ( R_PARAN )?
            {
                int alt165=2;
                switch ( LA(1) ) 
                {
                    case R_PARAN:
                    	{
                    		alt165=1;
                    	}
                        break;
                }

                switch (alt165) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: R_PARAN
            	    {
            	        R_PARAN479 = (pANTLR3_COMMON_TOKEN) MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_namedBit7298); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenamedBitEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        } 
            	        if ( BACKTRACKING==0 ) { CREATE_stream_R_PARAN; stream_R_PARAN->add(stream_R_PARAN, R_PARAN479, NULL); }


            	    }
            	    break;

                }
            }

             
            /* AST REWRITE
             * elements          : num, IDENTIFIER, dv
             * token labels      : num
             * rule labels       : retval, dv
             * token list labels : 
             * rule list labels  : 
             */
            if ( BACKTRACKING==0 ) 
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_num;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_dv;

            	stream_num=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token num", num);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_dv=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token dv", dv.tree != NULL ? dv.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 668:78: -> ^( IDENTIFIER ( $num)? ( $dv)? )
            	{
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:668:81: ^( IDENTIFIER ( $num)? ( $dv)? )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_IDENTIFIER == NULL ? NULL : stream_IDENTIFIER->nextNode(stream_IDENTIFIER), root_1));

            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:668:94: ( $num)?
            	        {
            	        	if ( (stream_num != NULL && stream_num->hasNext(stream_num))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_num == NULL ? NULL : stream_num->nextNode(stream_num));

            	        	}
            	        	if ( stream_num != NULL) stream_num->reset(stream_num);

            	        }
            	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:668:100: ( $dv)?
            	        {
            	        	if ( (stream_dv != NULL && stream_dv->hasNext(stream_dv))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_dv == NULL ? NULL : stream_dv->nextTree(stream_dv));

            	        	}
            	        	if ( stream_dv != NULL) stream_dv->reset(stream_dv);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}

            	retval.tree = root_0; // set result root
            	if (stream_num != NULL) stream_num->free(stream_num); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_dv != NULL) stream_dv->free(stream_dv);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenamedBitEx; /* Prevent compiler warnings */
    rulenamedBitEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_L_PARAN != NULL) stream_L_PARAN->free(stream_L_PARAN);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_R_PARAN != NULL) stream_R_PARAN->free(stream_R_PARAN);
        if (stream_NUMBER != NULL) stream_NUMBER->free(stream_NUMBER);
        if (stream_definedValue != NULL) stream_definedValue->free(stream_definedValue);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(146, namedBit_StartIndex); }

    return retval;
}
/* $ANTLR end namedBit */

/** 
 * $ANTLR start booleanValue
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:671:1: booleanValue : ( TRUE_LITERAL | FALSE_LITERAL | TRUE_SMALL_LITERAL | FALSE_SMALL_LITERAL );
 */
static asn1Parser_booleanValue_return
booleanValue(pasn1Parser ctx)
{   
    asn1Parser_booleanValue_return retval;
    ANTLR3_UINT32 booleanValue_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set480;

    pANTLR3_BASE_TREE set480_tree;

    /* Initialize rule variables
     */
    booleanValue_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(147)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    set480       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set480_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:671:13: ( TRUE_LITERAL | FALSE_LITERAL | TRUE_SMALL_LITERAL | FALSE_SMALL_LITERAL )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set480=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= TRUE_LITERAL) && (LA(1) <= FALSE_LITERAL)) || ((LA(1) >= TRUE_SMALL_LITERAL) && (LA(1) <= FALSE_SMALL_LITERAL)) )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set480)));
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_booleanValue0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_booleanValue0);    goto rulebooleanValueEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebooleanValueEx; /* Prevent compiler warnings */
    rulebooleanValueEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(147, booleanValue_StartIndex); }

    return retval;
}
/* $ANTLR end booleanValue */

/** 
 * $ANTLR start bitValue
 * /secure/release14_git/mink/src/asn1/asn1c/asn1.g:674:1: bitValue : BSTRING ;
 */
static asn1Parser_bitValue_return
bitValue(pasn1Parser ctx)
{   
    asn1Parser_bitValue_return retval;
    ANTLR3_UINT32 bitValue_StartIndex;
    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    BSTRING481;

    pANTLR3_BASE_TREE BSTRING481_tree;

    /* Initialize rule variables
     */
    bitValue_StartIndex = INDEX();


    root_0 = NULL;

    if ( (BACKTRACKING>0) && (HAVEPARSEDRULE(148)) )
    {
    	retval.start = 0;

        {
        }


        return retval; 
    }
    BSTRING481       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    BSTRING481_tree   = NULL;


    retval.tree  = NULL;
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:674:9: ( BSTRING )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:674:11: BSTRING
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            BSTRING481 = (pANTLR3_COMMON_TOKEN) MATCHT(BSTRING, &FOLLOW_BSTRING_in_bitValue7344); 
            if  (HASEXCEPTION())
            {
                goto rulebitValueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) {
            BSTRING481_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BSTRING481));
            ADAPTOR->addChild(ADAPTOR, root_0, BSTRING481_tree);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebitValueEx; /* Prevent compiler warnings */
    rulebitValueEx: ;
    retval.stop = LT(-1);

    if ( BACKTRACKING==0 )
    {
    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    if ( BACKTRACKING>0 ) { MEMOIZE(148, bitValue_StartIndex); }

    return retval;
}
/* $ANTLR end bitValue */

// $ANTLR start synpred23_asn1
static void synpred23_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_valueAssignment_return as1;
	#undef	RETURN_TYPE_as1
	#define	RETURN_TYPE_as1 asn1Parser_valueAssignment_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:202:6: (as1= valueAssignment )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:202:6: as1= valueAssignment
    {
        FOLLOWPUSH(FOLLOW_valueAssignment_in_synpred23_asn13783);
        as1=valueAssignment(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred23_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred23_asn1Ex; /* Prevent compiler warnings */
rulesynpred23_asn1Ex: ;

}
// $ANTLR end synpred23_asn1

// $ANTLR start synpred24_asn1
static void synpred24_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_typeAssignment_return as2;
	#undef	RETURN_TYPE_as2
	#define	RETURN_TYPE_as2 asn1Parser_typeAssignment_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:203:5: (as2= typeAssignment )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:203:5: as2= typeAssignment
    {
        FOLLOWPUSH(FOLLOW_typeAssignment_in_synpred24_asn13792);
        as2=typeAssignment(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred24_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred24_asn1Ex; /* Prevent compiler warnings */
rulesynpred24_asn1Ex: ;

}
// $ANTLR end synpred24_asn1

// $ANTLR start synpred25_asn1
static void synpred25_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_parameterizedAssignment_return as3;
	#undef	RETURN_TYPE_as3
	#define	RETURN_TYPE_as3 asn1Parser_parameterizedAssignment_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:204:5: (as3= parameterizedAssignment )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:204:5: as3= parameterizedAssignment
    {
        FOLLOWPUSH(FOLLOW_parameterizedAssignment_in_synpred25_asn13800);
        as3=parameterizedAssignment(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred25_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred25_asn1Ex; /* Prevent compiler warnings */
rulesynpred25_asn1Ex: ;

}
// $ANTLR end synpred25_asn1

// $ANTLR start synpred26_asn1
static void synpred26_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:212:41: ( extensionAndException optionalExtensionMarker )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:212:41: extensionAndException optionalExtensionMarker
    {
        FOLLOWPUSH(FOLLOW_extensionAndException_in_synpred26_asn13856);
        extensionAndException(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred26_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_optionalExtensionMarker_in_synpred26_asn13859);
        optionalExtensionMarker(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred26_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred26_asn1Ex; /* Prevent compiler warnings */
rulesynpred26_asn1Ex: ;

}
// $ANTLR end synpred26_asn1

// $ANTLR start synpred27_asn1
static void synpred27_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:212:90: ( componentTypeLists )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:212:90: componentTypeLists
    {
        FOLLOWPUSH(FOLLOW_componentTypeLists_in_synpred27_asn13863);
        componentTypeLists(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred27_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred27_asn1Ex; /* Prevent compiler warnings */
rulesynpred27_asn1Ex: ;

}
// $ANTLR end synpred27_asn1

// $ANTLR start synpred28_asn1
static void synpred28_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:215:37: ( exceptionSpec )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:215:37: exceptionSpec
    {
        FOLLOWPUSH(FOLLOW_exceptionSpec_in_synpred28_asn13897);
        exceptionSpec(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred28_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred28_asn1Ex; /* Prevent compiler warnings */
rulesynpred28_asn1Ex: ;

}
// $ANTLR end synpred28_asn1

// $ANTLR start synpred42_asn1
static void synpred42_asn1_fragment(pasn1Parser ctx ) 
{
	pANTLR3_COMMON_TOKEN    sz;
	pANTLR3_VECTOR    list_sz;

	sz       = NULL;
	list_sz     = NULL;

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:38: (sz+= SIZE_LITERAL )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:38: sz+= SIZE_LITERAL
    {
        sz = (pANTLR3_COMMON_TOKEN) MATCHT(SIZE_LITERAL, &FOLLOW_SIZE_LITERAL_in_synpred42_asn14193); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred42_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
        if (list_sz == NULL)
        {
            list_sz=ctx->vectors->newVector(ctx->vectors);
        }
        list_sz->add(list_sz, sz, NULL);

    }

// This is where rules clean up and exit
//
goto rulesynpred42_asn1Ex; /* Prevent compiler warnings */
rulesynpred42_asn1Ex: ;

}
// $ANTLR end synpred42_asn1

// $ANTLR start synpred43_asn1
static void synpred43_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:55: ( L_PARAN )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:55: L_PARAN
    {
         MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_synpred43_asn14197); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred43_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred43_asn1Ex; /* Prevent compiler warnings */
rulesynpred43_asn1Ex: ;

}
// $ANTLR end synpred43_asn1

// $ANTLR start synpred44_asn1
static void synpred44_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_constraint_return c1;
	#undef	RETURN_TYPE_c1
	#define	RETURN_TYPE_c1 asn1Parser_constraint_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:65: (c1= constraint )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:65: c1= constraint
    {
        FOLLOWPUSH(FOLLOW_constraint_in_synpred44_asn14203);
        c1=constraint(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred44_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred44_asn1Ex; /* Prevent compiler warnings */
rulesynpred44_asn1Ex: ;

}
// $ANTLR end synpred44_asn1

// $ANTLR start synpred47_asn1
static void synpred47_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_type_return tp;
	#undef	RETURN_TYPE_tp
	#define	RETURN_TYPE_tp asn1Parser_type_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:123: (tp= type )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:247:123: tp= type
    {
        FOLLOWPUSH(FOLLOW_type_in_synpred47_asn14222);
        tp=type(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred47_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred47_asn1Ex; /* Prevent compiler warnings */
rulesynpred47_asn1Ex: ;

}
// $ANTLR end synpred47_asn1

// $ANTLR start synpred48_asn1
static void synpred48_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:257:3: ( type )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:257:3: type
    {
        FOLLOWPUSH(FOLLOW_type_in_synpred48_asn14296);
        type(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred48_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred48_asn1Ex; /* Prevent compiler warnings */
rulesynpred48_asn1Ex: ;

}
// $ANTLR end synpred48_asn1

// $ANTLR start synpred49_asn1
static void synpred49_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:258:5: ( value )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:258:5: value
    {
        FOLLOWPUSH(FOLLOW_value_in_synpred49_asn14303);
        value(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred49_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred49_asn1Ex; /* Prevent compiler warnings */
rulesynpred49_asn1Ex: ;

}
// $ANTLR end synpred49_asn1

// $ANTLR start synpred51_asn1
static void synpred51_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:263:4: ( object )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:263:4: object
    {
        FOLLOWPUSH(FOLLOW_object_in_synpred51_asn14327);
        object(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred51_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred51_asn1Ex; /* Prevent compiler warnings */
rulesynpred51_asn1Ex: ;

}
// $ANTLR end synpred51_asn1

// $ANTLR start synpred52_asn1
static void synpred52_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:264:5: ( objectClass )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:264:5: objectClass
    {
        FOLLOWPUSH(FOLLOW_objectClass_in_synpred52_asn14334);
        objectClass(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred52_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred52_asn1Ex; /* Prevent compiler warnings */
rulesynpred52_asn1Ex: ;

}
// $ANTLR end synpred52_asn1

// $ANTLR start synpred55_asn1
static void synpred55_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:280:17: ( governor )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:280:17: governor
    {
        FOLLOWPUSH(FOLLOW_governor_in_synpred55_asn14395);
        governor(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred55_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred55_asn1Ex; /* Prevent compiler warnings */
rulesynpred55_asn1Ex: ;

}
// $ANTLR end synpred55_asn1

// $ANTLR start synpred56_asn1
static void synpred56_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:285:12: ( type )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:285:12: type
    {
        FOLLOWPUSH(FOLLOW_type_in_synpred56_asn14411);
        type(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred56_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred56_asn1Ex; /* Prevent compiler warnings */
rulesynpred56_asn1Ex: ;

}
// $ANTLR end synpred56_asn1

// $ANTLR start synpred57_asn1
static void synpred57_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_definedObjectClass_return a1;
	#undef	RETURN_TYPE_a1
	#define	RETURN_TYPE_a1 asn1Parser_definedObjectClass_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:292:15: (a1= definedObjectClass )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:292:15: a1= definedObjectClass
    {
        FOLLOWPUSH(FOLLOW_definedObjectClass_in_synpred57_asn14444);
        a1=definedObjectClass(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred57_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred57_asn1Ex; /* Prevent compiler warnings */
rulesynpred57_asn1Ex: ;

}
// $ANTLR end synpred57_asn1

// $ANTLR start synpred62_asn1
static void synpred62_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_constraint_return c1;
	#undef	RETURN_TYPE_c1
	#define	RETURN_TYPE_c1 asn1Parser_constraint_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:299:14: (c1= constraint )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:299:14: c1= constraint
    {
        FOLLOWPUSH(FOLLOW_constraint_in_synpred62_asn14529);
        c1=constraint(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred62_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred62_asn1Ex; /* Prevent compiler warnings */
rulesynpred62_asn1Ex: ;

}
// $ANTLR end synpred62_asn1

// $ANTLR start synpred75_asn1
static void synpred75_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:12: ( ( valueSetOptionalitySpec )? )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:12: ( valueSetOptionalitySpec )?
    {

        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:12: ( valueSetOptionalitySpec )?
        {
            int alt185=2;
            switch ( LA(1) ) 
            {
                case OPTIONAL_LITERAL:
                case DEFAULT_LITERAL:
                	{
                		alt185=1;
                	}
                    break;
            }

            switch (alt185) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: valueSetOptionalitySpec
        	    {
        	        FOLLOWPUSH(FOLLOW_valueSetOptionalitySpec_in_synpred75_asn14765);
        	        valueSetOptionalitySpec(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesynpred75_asn1Ex;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred75_asn1Ex; /* Prevent compiler warnings */
rulesynpred75_asn1Ex: ;

}
// $ANTLR end synpred75_asn1

// $ANTLR start synpred78_asn1
static void synpred78_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:6: ( type ( ( valueSetOptionalitySpec )? | ( UNIQUE_LITERAL )? ( valueOptionalitySpec )? ) )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:6: type ( ( valueSetOptionalitySpec )? | ( UNIQUE_LITERAL )? ( valueOptionalitySpec )? )
    {
        FOLLOWPUSH(FOLLOW_type_in_synpred78_asn14762);
        type(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred78_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:11: ( ( valueSetOptionalitySpec )? | ( UNIQUE_LITERAL )? ( valueOptionalitySpec )? )
        {
            int alt189=2;
            switch ( LA(1) ) 
            {
            case OPTIONAL_LITERAL:
            	{

            		{
            		    int LA189_1 = LA(2);
            		    if ( (synpred75_asn1(ctx)) ) 
            		    {
            		        alt189=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt189=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 189;
            		        EXCEPTION->state        = 1;


            		        goto rulesynpred78_asn1Ex;
            		    }
            		}
            	}
                break;
            case DEFAULT_LITERAL:
            	{
            		switch ( LA(2) ) 
            		{
            		case L_BRACE:
            			{
            				switch ( LA(3) ) 
            				{
            				case NUMBER:
            					{
            						switch ( LA(4) ) 
            						{
            						case IDENTIFIER:
            						case NUMBER:
            							{
            								alt189=2;
            							}
            						    break;
            						case R_BRACE:
            							{

            								{
            								    int LA189_9 = LA(5);
            								    if ( (synpred75_asn1(ctx)) ) 
            								    {
            								        alt189=1;
            								    }
            								    else if ( (ANTLR3_TRUE) ) 
            								    {
            								        alt189=2;
            								    }
            								    else 
            								    {
            								        if (BACKTRACKING>0)
            								        {
            								            FAILEDFLAG = ANTLR3_TRUE;
            								            return ;
            								        }
            								    
            								        CONSTRUCTEX();
            								        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								        EXCEPTION->message      = (void *)"";
            								        EXCEPTION->decisionNum  = 189;
            								        EXCEPTION->state        = 9;


            								        goto rulesynpred78_asn1Ex;
            								    }
            								}
            							}
            						    break;
            						case DOUBLE_DOT:
            						case LESS_THAN:
            						case COMMA:
            						case EXCEPT_LITERAL:
            						case POWER:
            						case PIPE:
            						case UNION_LITERAL:
            						case INTERSECTION_LITERAL:
            							{
            								alt189=1;
            							}
            						    break;

            						default:
            						    if (BACKTRACKING>0)
            						    {
            						        FAILEDFLAG = ANTLR3_TRUE;
            						        return ;
            						    }
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 189;
            						    EXCEPTION->state        = 7;


            						    goto rulesynpred78_asn1Ex;
            						}

            					}
            				    break;
            				case IDENTIFIER:
            					{
            						switch ( LA(4) ) 
            						{
            						case DOUBLE_DOT:
            						case LESS_THAN:
            						case COMMA:
            						case EXCEPT_LITERAL:
            						case POWER:
            						case PIPE:
            						case UNION_LITERAL:
            						case INTERSECTION_LITERAL:
            						case COLON:
            							{
            								alt189=1;
            							}
            						    break;
            						case R_BRACE:
            							{

            								{
            								    int LA189_9 = LA(5);
            								    if ( (synpred75_asn1(ctx)) ) 
            								    {
            								        alt189=1;
            								    }
            								    else if ( (ANTLR3_TRUE) ) 
            								    {
            								        alt189=2;
            								    }
            								    else 
            								    {
            								        if (BACKTRACKING>0)
            								        {
            								            FAILEDFLAG = ANTLR3_TRUE;
            								            return ;
            								        }
            								    
            								        CONSTRUCTEX();
            								        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								        EXCEPTION->message      = (void *)"";
            								        EXCEPTION->decisionNum  = 189;
            								        EXCEPTION->state        = 9;


            								        goto rulesynpred78_asn1Ex;
            								    }
            								}
            							}
            						    break;
            						case DOT:
            						case L_BRACE:
            						case L_PARAN:
            						case IDENTIFIER:
            						case NUMBER:
            							{
            								alt189=2;
            							}
            						    break;

            						default:
            						    if (BACKTRACKING>0)
            						    {
            						        FAILEDFLAG = ANTLR3_TRUE;
            						        return ;
            						    }
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 189;
            						    EXCEPTION->state        = 8;


            						    goto rulesynpred78_asn1Ex;
            						}

            					}
            				    break;
            				case TRUE_LITERAL:
            				case FALSE_LITERAL:
            				case TRUE_SMALL_LITERAL:
            				case FALSE_SMALL_LITERAL:
            				case L_BRACE:
            				case MINUS:
            				case ALL_LITERAL:
            				case MIN_LITERAL:
            				case SIZE_LITERAL:
            				case PATTERN_LITERAL:
            				case BSTRING:
            					{
            						alt189=1;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 189;
            				    EXCEPTION->state        = 6;


            				    goto rulesynpred78_asn1Ex;
            				}

            			}
            		    break;
            		case TRUE_LITERAL:
            		case FALSE_LITERAL:
            		case TRUE_SMALL_LITERAL:
            		case FALSE_SMALL_LITERAL:
            		case MINUS:
            		case IDENTIFIER:
            		case NUMBER:
            		case BSTRING:
            			{
            				alt189=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 189;
            		    EXCEPTION->state        = 2;


            		    goto rulesynpred78_asn1Ex;
            		}

            	}
                break;
            case EOF:
            	{

            		{
            		    int LA189_3 = LA(2);
            		    if ( (synpred75_asn1(ctx)) ) 
            		    {
            		        alt189=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt189=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 189;
            		        EXCEPTION->state        = 3;


            		        goto rulesynpred78_asn1Ex;
            		    }
            		}
            	}
                break;
            case UNIQUE_LITERAL:
            	{
            		alt189=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 189;
                EXCEPTION->state        = 0;


                goto rulesynpred78_asn1Ex;
            }

            switch (alt189) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:12: ( valueSetOptionalitySpec )?
        	    {

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:12: ( valueSetOptionalitySpec )?
        	        {
        	            int alt186=2;
        	            switch ( LA(1) ) 
        	            {
        	                case OPTIONAL_LITERAL:
        	                case DEFAULT_LITERAL:
        	                	{
        	                		alt186=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt186) 
        	            {
        	        	case 1:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: valueSetOptionalitySpec
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_valueSetOptionalitySpec_in_synpred78_asn14765);
        	        	        valueSetOptionalitySpec(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesynpred78_asn1Ex;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:40: ( UNIQUE_LITERAL )? ( valueOptionalitySpec )?
        	    {

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:40: ( UNIQUE_LITERAL )?
        	        {
        	            int alt187=2;
        	            switch ( LA(1) ) 
        	            {
        	                case UNIQUE_LITERAL:
        	                	{
        	                		alt187=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt187) 
        	            {
        	        	case 1:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: UNIQUE_LITERAL
        	        	    {
        	        	         MATCHT(UNIQUE_LITERAL, &FOLLOW_UNIQUE_LITERAL_in_synpred78_asn14771); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesynpred78_asn1Ex;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:336:56: ( valueOptionalitySpec )?
        	        {
        	            int alt188=2;
        	            switch ( LA(1) ) 
        	            {
        	                case OPTIONAL_LITERAL:
        	                case DEFAULT_LITERAL:
        	                	{
        	                		alt188=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt188) 
        	            {
        	        	case 1:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: valueOptionalitySpec
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_valueOptionalitySpec_in_synpred78_asn14774);
        	        	        valueOptionalitySpec(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesynpred78_asn1Ex;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred78_asn1Ex; /* Prevent compiler warnings */
rulesynpred78_asn1Ex: ;

}
// $ANTLR end synpred78_asn1

// $ANTLR start synpred80_asn1
static void synpred80_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:337:52: ( valueSet )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:337:52: valueSet
    {
        FOLLOWPUSH(FOLLOW_valueSet_in_synpred80_asn14793);
        valueSet(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred80_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred80_asn1Ex; /* Prevent compiler warnings */
rulesynpred80_asn1Ex: ;

}
// $ANTLR end synpred80_asn1

// $ANTLR start synpred102_asn1
static void synpred102_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:391:22: ( COMMA ELLIPSIS ( COMMA additionalElementSetSpec )? )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:391:22: COMMA ELLIPSIS ( COMMA additionalElementSetSpec )?
    {
         MATCHT(COMMA, &FOLLOW_COMMA_in_synpred102_asn15104); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred102_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(ELLIPSIS, &FOLLOW_ELLIPSIS_in_synpred102_asn15106); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred102_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:391:37: ( COMMA additionalElementSetSpec )?
        {
            int alt197=2;
            switch ( LA(1) ) 
            {
                case COMMA:
                	{
                		alt197=1;
                	}
                    break;
            }

            switch (alt197) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:391:38: COMMA additionalElementSetSpec
        	    {
        	         MATCHT(COMMA, &FOLLOW_COMMA_in_synpred102_asn15109); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesynpred102_asn1Ex;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        FOLLOWPUSH(FOLLOW_additionalElementSetSpec_in_synpred102_asn15111);
        	        additionalElementSetSpec(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesynpred102_asn1Ex;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred102_asn1Ex; /* Prevent compiler warnings */
rulesynpred102_asn1Ex: ;

}
// $ANTLR end synpred102_asn1

// $ANTLR start synpred104_asn1
static void synpred104_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:399:29: ( unionMark intersections )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:399:29: unionMark intersections
    {
        FOLLOWPUSH(FOLLOW_unionMark_in_synpred104_asn15164);
        unionMark(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred104_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_intersections_in_synpred104_asn15166);
        intersections(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred104_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred104_asn1Ex; /* Prevent compiler warnings */
rulesynpred104_asn1Ex: ;

}
// $ANTLR end synpred104_asn1

// $ANTLR start synpred105_asn1
static void synpred105_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:403:41: ( intersectionMark intersectionElements )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:403:41: intersectionMark intersectionElements
    {
        FOLLOWPUSH(FOLLOW_intersectionMark_in_synpred105_asn15192);
        intersectionMark(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred105_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_intersectionElements_in_synpred105_asn15194);
        intersectionElements(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred105_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred105_asn1Ex; /* Prevent compiler warnings */
rulesynpred105_asn1Ex: ;

}
// $ANTLR end synpred105_asn1

// $ANTLR start synpred108_asn1
static void synpred108_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:416:5: ( object )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:416:5: object
    {
        FOLLOWPUSH(FOLLOW_object_in_synpred108_asn15263);
        object(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred108_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred108_asn1Ex; /* Prevent compiler warnings */
rulesynpred108_asn1Ex: ;

}
// $ANTLR end synpred108_asn1

// $ANTLR start synpred109_asn1
static void synpred109_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:420:34: ( exclusions )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:420:34: exclusions
    {
        FOLLOWPUSH(FOLLOW_exclusions_in_synpred109_asn15282);
        exclusions(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred109_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred109_asn1Ex; /* Prevent compiler warnings */
rulesynpred109_asn1Ex: ;

}
// $ANTLR end synpred109_asn1

// $ANTLR start synpred114_asn1
static void synpred114_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:3: ( ( ( value | MIN_LITERAL ) ( LESS_THAN )? DOUBLE_DOT ( LESS_THAN )? ( value | MAX_LITERAL ) ) )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:3: ( ( value | MIN_LITERAL ) ( LESS_THAN )? DOUBLE_DOT ( LESS_THAN )? ( value | MAX_LITERAL ) )
    {
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:3: ( ( value | MIN_LITERAL ) ( LESS_THAN )? DOUBLE_DOT ( LESS_THAN )? ( value | MAX_LITERAL ) )
        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:4: ( value | MIN_LITERAL ) ( LESS_THAN )? DOUBLE_DOT ( LESS_THAN )? ( value | MAX_LITERAL )
        {

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:4: ( value | MIN_LITERAL )
            {
                int alt198=2;
                switch ( LA(1) ) 
                {
                case TRUE_LITERAL:
                case FALSE_LITERAL:
                case TRUE_SMALL_LITERAL:
                case FALSE_SMALL_LITERAL:
                case L_BRACE:
                case MINUS:
                case IDENTIFIER:
                case NUMBER:
                case BSTRING:
                	{
                		alt198=1;
                	}
                    break;
                case MIN_LITERAL:
                	{
                		alt198=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 198;
                    EXCEPTION->state        = 0;


                    goto rulesynpred114_asn1Ex;
                }

                switch (alt198) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:5: value
            	    {
            	        FOLLOWPUSH(FOLLOW_value_in_synpred114_asn15300);
            	        value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesynpred114_asn1Ex;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:13: MIN_LITERAL
            	    {
            	         MATCHT(MIN_LITERAL, &FOLLOW_MIN_LITERAL_in_synpred114_asn15304); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesynpred114_asn1Ex;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:26: ( LESS_THAN )?
            {
                int alt199=2;
                switch ( LA(1) ) 
                {
                    case LESS_THAN:
                    	{
                    		alt199=1;
                    	}
                        break;
                }

                switch (alt199) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: LESS_THAN
            	    {
            	         MATCHT(LESS_THAN, &FOLLOW_LESS_THAN_in_synpred114_asn15307); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesynpred114_asn1Ex;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(DOUBLE_DOT, &FOLLOW_DOUBLE_DOT_in_synpred114_asn15311); 
            if  (HASEXCEPTION())
            {
                goto rulesynpred114_asn1Ex;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:49: ( LESS_THAN )?
            {
                int alt200=2;
                switch ( LA(1) ) 
                {
                    case LESS_THAN:
                    	{
                    		alt200=1;
                    	}
                        break;
                }

                switch (alt200) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:0:0: LESS_THAN
            	    {
            	         MATCHT(LESS_THAN, &FOLLOW_LESS_THAN_in_synpred114_asn15313); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesynpred114_asn1Ex;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

            // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:61: ( value | MAX_LITERAL )
            {
                int alt201=2;
                switch ( LA(1) ) 
                {
                case TRUE_LITERAL:
                case FALSE_LITERAL:
                case TRUE_SMALL_LITERAL:
                case FALSE_SMALL_LITERAL:
                case L_BRACE:
                case MINUS:
                case IDENTIFIER:
                case NUMBER:
                case BSTRING:
                	{
                		alt201=1;
                	}
                    break;
                case MAX_LITERAL:
                	{
                		alt201=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 201;
                    EXCEPTION->state        = 0;


                    goto rulesynpred114_asn1Ex;
                }

                switch (alt201) 
                {
            	case 1:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:62: value
            	    {
            	        FOLLOWPUSH(FOLLOW_value_in_synpred114_asn15318);
            	        value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesynpred114_asn1Ex;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:423:70: MAX_LITERAL
            	    {
            	         MATCHT(MAX_LITERAL, &FOLLOW_MAX_LITERAL_in_synpred114_asn15322); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesynpred114_asn1Ex;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }


    }

// This is where rules clean up and exit
//
goto rulesynpred114_asn1Ex; /* Prevent compiler warnings */
rulesynpred114_asn1Ex: ;

}
// $ANTLR end synpred114_asn1

// $ANTLR start synpred137_asn1
static void synpred137_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:471:4: ( sequenceType )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:471:4: sequenceType
    {
        FOLLOWPUSH(FOLLOW_sequenceType_in_synpred137_asn15687);
        sequenceType(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred137_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred137_asn1Ex; /* Prevent compiler warnings */
rulesynpred137_asn1Ex: ;

}
// $ANTLR end synpred137_asn1

// $ANTLR start synpred138_asn1
static void synpred138_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:472:4: ( sequenceOfType )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:472:4: sequenceOfType
    {
        FOLLOWPUSH(FOLLOW_sequenceOfType_in_synpred138_asn15693);
        sequenceOfType(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred138_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred138_asn1Ex; /* Prevent compiler warnings */
rulesynpred138_asn1Ex: ;

}
// $ANTLR end synpred138_asn1

// $ANTLR start synpred139_asn1
static void synpred139_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:473:4: ( setType )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:473:4: setType
    {
        FOLLOWPUSH(FOLLOW_setType_in_synpred139_asn15699);
        setType(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred139_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred139_asn1Ex; /* Prevent compiler warnings */
rulesynpred139_asn1Ex: ;

}
// $ANTLR end synpred139_asn1

// $ANTLR start synpred140_asn1
static void synpred140_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:474:4: ( setOfType )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:474:4: setOfType
    {
        FOLLOWPUSH(FOLLOW_setOfType_in_synpred140_asn15705);
        setOfType(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred140_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred140_asn1Ex; /* Prevent compiler warnings */
rulesynpred140_asn1Ex: ;

}
// $ANTLR end synpred140_asn1

// $ANTLR start synpred142_asn1
static void synpred142_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:484:35: ( extensionAndException optionalExtensionMarker )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:484:35: extensionAndException optionalExtensionMarker
    {
        FOLLOWPUSH(FOLLOW_extensionAndException_in_synpred142_asn15752);
        extensionAndException(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred142_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_optionalExtensionMarker_in_synpred142_asn15755);
        optionalExtensionMarker(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred142_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred142_asn1Ex; /* Prevent compiler warnings */
rulesynpred142_asn1Ex: ;

}
// $ANTLR end synpred142_asn1

// $ANTLR start synpred143_asn1
static void synpred143_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:484:85: ( componentTypeLists )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:484:85: componentTypeLists
    {
        FOLLOWPUSH(FOLLOW_componentTypeLists_in_synpred143_asn15760);
        componentTypeLists(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred143_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred143_asn1Ex; /* Prevent compiler warnings */
rulesynpred143_asn1Ex: ;

}
// $ANTLR end synpred143_asn1

// $ANTLR start synpred144_asn1
static void synpred144_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:29: ( constraint )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:29: constraint
    {
        FOLLOWPUSH(FOLLOW_constraint_in_synpred144_asn15782);
        constraint(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred144_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred144_asn1Ex; /* Prevent compiler warnings */
rulesynpred144_asn1Ex: ;

}
// $ANTLR end synpred144_asn1

// $ANTLR start synpred145_asn1
static void synpred145_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:42: ( sizeConstraint )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:42: sizeConstraint
    {
        FOLLOWPUSH(FOLLOW_sizeConstraint_in_synpred145_asn15786);
        sizeConstraint(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred145_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred145_asn1Ex; /* Prevent compiler warnings */
rulesynpred145_asn1Ex: ;

}
// $ANTLR end synpred145_asn1

// $ANTLR start synpred146_asn1
static void synpred146_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:71: ( type )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:487:71: type
    {
        FOLLOWPUSH(FOLLOW_type_in_synpred146_asn15793);
        type(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred146_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred146_asn1Ex; /* Prevent compiler warnings */
rulesynpred146_asn1Ex: ;

}
// $ANTLR end synpred146_asn1

// $ANTLR start synpred148_asn1
static void synpred148_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_actualParameterList_return pl;
	#undef	RETURN_TYPE_pl
	#define	RETURN_TYPE_pl asn1Parser_actualParameterList_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:498:35: (pl= actualParameterList )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:498:35: pl= actualParameterList
    {
        FOLLOWPUSH(FOLLOW_actualParameterList_in_synpred148_asn15844);
        pl=actualParameterList(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred148_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred148_asn1Ex; /* Prevent compiler warnings */
rulesynpred148_asn1Ex: ;

}
// $ANTLR end synpred148_asn1

// $ANTLR start synpred150_asn1
static void synpred150_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:507:18: ( generalConstraint )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:507:18: generalConstraint
    {
        FOLLOWPUSH(FOLLOW_generalConstraint_in_synpred150_asn15897);
        generalConstraint(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred150_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred150_asn1Ex; /* Prevent compiler warnings */
rulesynpred150_asn1Ex: ;

}
// $ANTLR end synpred150_asn1

// $ANTLR start synpred155_asn1
static void synpred155_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:517:6: ( valueSet )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:517:6: valueSet
    {
        FOLLOWPUSH(FOLLOW_valueSet_in_synpred155_asn15973);
        valueSet(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred155_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred155_asn1Ex; /* Prevent compiler warnings */
rulesynpred155_asn1Ex: ;

}
// $ANTLR end synpred155_asn1

// $ANTLR start synpred157_asn1
static void synpred157_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:519:6: ( objectSet )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:519:6: objectSet
    {
        FOLLOWPUSH(FOLLOW_objectSet_in_synpred157_asn15987);
        objectSet(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred157_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred157_asn1Ex; /* Prevent compiler warnings */
rulesynpred157_asn1Ex: ;

}
// $ANTLR end synpred157_asn1

// $ANTLR start synpred158_asn1
static void synpred158_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:530:4: ( CONTAINING_LITERAL type )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:530:4: CONTAINING_LITERAL type
    {
         MATCHT(CONTAINING_LITERAL, &FOLLOW_CONTAINING_LITERAL_in_synpred158_asn16028); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred158_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_type_in_synpred158_asn16030);
        type(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred158_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred158_asn1Ex; /* Prevent compiler warnings */
rulesynpred158_asn1Ex: ;

}
// $ANTLR end synpred158_asn1

// $ANTLR start synpred160_asn1
static void synpred160_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:546:3: ( enumeratedValue )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:546:3: enumeratedValue
    {
        FOLLOWPUSH(FOLLOW_enumeratedValue_in_synpred160_asn16107);
        enumeratedValue(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred160_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred160_asn1Ex; /* Prevent compiler warnings */
rulesynpred160_asn1Ex: ;

}
// $ANTLR end synpred160_asn1

// $ANTLR start synpred161_asn1
static void synpred161_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:547:4: ( integerValue )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:547:4: integerValue
    {
        FOLLOWPUSH(FOLLOW_integerValue_in_synpred161_asn16112);
        integerValue(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred161_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred161_asn1Ex; /* Prevent compiler warnings */
rulesynpred161_asn1Ex: ;

}
// $ANTLR end synpred161_asn1

// $ANTLR start synpred169_asn1
static void synpred169_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:8: ( IDENTIFIER ( L_PARAN ( NUMBER | definedValue ) R_PARAN )? )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:8: IDENTIFIER ( L_PARAN ( NUMBER | definedValue ) R_PARAN )?
    {
         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_synpred169_asn16198); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred169_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:19: ( L_PARAN ( NUMBER | definedValue ) R_PARAN )?
        {
            int alt204=2;
            switch ( LA(1) ) 
            {
                case L_PARAN:
                	{
                		alt204=1;
                	}
                    break;
            }

            switch (alt204) 
            {
        	case 1:
        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:20: L_PARAN ( NUMBER | definedValue ) R_PARAN
        	    {
        	         MATCHT(L_PARAN, &FOLLOW_L_PARAN_in_synpred169_asn16201); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesynpred169_asn1Ex;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	        // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:28: ( NUMBER | definedValue )
        	        {
        	            int alt203=2;
        	            switch ( LA(1) ) 
        	            {
        	            case NUMBER:
        	            	{
        	            		alt203=1;
        	            	}
        	                break;
        	            case IDENTIFIER:
        	            	{
        	            		alt203=2;
        	            	}
        	                break;

        	            default:
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 203;
        	                EXCEPTION->state        = 0;


        	                goto rulesynpred169_asn1Ex;
        	            }

        	            switch (alt203) 
        	            {
        	        	case 1:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:29: NUMBER
        	        	    {
        	        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_synpred169_asn16204); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesynpred169_asn1Ex;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:562:38: definedValue
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_definedValue_in_synpred169_asn16208);
        	        	        definedValue(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesynpred169_asn1Ex;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }
        	         MATCHT(R_PARAN, &FOLLOW_R_PARAN_in_synpred169_asn16212); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesynpred169_asn1Ex;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred169_asn1Ex; /* Prevent compiler warnings */
rulesynpred169_asn1Ex: ;

}
// $ANTLR end synpred169_asn1

// $ANTLR start synpred180_asn1
static void synpred180_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:605:19: ( IDENTIFIER )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:605:19: IDENTIFIER
    {
         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_synpred180_asn16571); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred180_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred180_asn1Ex; /* Prevent compiler warnings */
rulesynpred180_asn1Ex: ;

}
// $ANTLR end synpred180_asn1

// $ANTLR start synpred186_asn1
static void synpred186_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_type_return tp;
	#undef	RETURN_TYPE_tp
	#define	RETURN_TYPE_tp asn1Parser_type_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:621:19: (tp= type )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:621:19: tp= type
    {
        FOLLOWPUSH(FOLLOW_type_in_synpred186_asn16708);
        tp=type(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred186_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred186_asn1Ex; /* Prevent compiler warnings */
rulesynpred186_asn1Ex: ;

}
// $ANTLR end synpred186_asn1

// $ANTLR start synpred187_asn1
static void synpred187_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:624:18: ( EXCLAM exceptionIdentification )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:624:18: EXCLAM exceptionIdentification
    {
         MATCHT(EXCLAM, &FOLLOW_EXCLAM_in_synpred187_asn16739); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred187_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_exceptionIdentification_in_synpred187_asn16742);
        exceptionIdentification(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred187_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred187_asn1Ex; /* Prevent compiler warnings */
rulesynpred187_asn1Ex: ;

}
// $ANTLR end synpred187_asn1

// $ANTLR start synpred189_asn1
static void synpred189_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:627:8: ( definedValue )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:627:8: definedValue
    {
        FOLLOWPUSH(FOLLOW_definedValue_in_synpred189_asn16763);
        definedValue(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred189_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred189_asn1Ex; /* Prevent compiler warnings */
rulesynpred189_asn1Ex: ;

}
// $ANTLR end synpred189_asn1

// $ANTLR start synpred191_asn1
static void synpred191_asn1_fragment(pasn1Parser ctx ) 
{
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:80: ( SIZE_LITERAL )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:80: SIZE_LITERAL
    {
         MATCHT(SIZE_LITERAL, &FOLLOW_SIZE_LITERAL_in_synpred191_asn16811); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred191_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred191_asn1Ex; /* Prevent compiler warnings */
rulesynpred191_asn1Ex: ;

}
// $ANTLR end synpred191_asn1

// $ANTLR start synpred192_asn1
static void synpred192_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_constraint_return c1;
	#undef	RETURN_TYPE_c1
	#define	RETURN_TYPE_c1 asn1Parser_constraint_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:95: (c1= constraint )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:632:95: c1= constraint
    {
        FOLLOWPUSH(FOLLOW_constraint_in_synpred192_asn16817);
        c1=constraint(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred192_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred192_asn1Ex; /* Prevent compiler warnings */
rulesynpred192_asn1Ex: ;

}
// $ANTLR end synpred192_asn1

// $ANTLR start synpred201_asn1
static void synpred201_asn1_fragment(pasn1Parser ctx ) 
{
	pANTLR3_COMMON_TOKEN    sl;

	sl       = NULL;

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:61: (sl= SIZE_LITERAL )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:61: sl= SIZE_LITERAL
    {
        sl = (pANTLR3_COMMON_TOKEN) MATCHT(SIZE_LITERAL, &FOLLOW_SIZE_LITERAL_in_synpred201_asn17031); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred201_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred201_asn1Ex; /* Prevent compiler warnings */
rulesynpred201_asn1Ex: ;

}
// $ANTLR end synpred201_asn1

// $ANTLR start synpred202_asn1
static void synpred202_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_constraint_return c1;
	#undef	RETURN_TYPE_c1
	#define	RETURN_TYPE_c1 asn1Parser_constraint_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:77: (c1= constraint )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:649:77: c1= constraint
    {
        FOLLOWPUSH(FOLLOW_constraint_in_synpred202_asn17037);
        c1=constraint(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred202_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred202_asn1Ex; /* Prevent compiler warnings */
rulesynpred202_asn1Ex: ;

}
// $ANTLR end synpred202_asn1

// $ANTLR start synpred204_asn1
static void synpred204_asn1_fragment(pasn1Parser ctx ) 
{
	pANTLR3_COMMON_TOKEN    sl;

	sl       = NULL;

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:49: (sl= SIZE_LITERAL )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:49: sl= SIZE_LITERAL
    {
        sl = (pANTLR3_COMMON_TOKEN) MATCHT(SIZE_LITERAL, &FOLLOW_SIZE_LITERAL_in_synpred204_asn17092); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred204_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred204_asn1Ex; /* Prevent compiler warnings */
rulesynpred204_asn1Ex: ;

}
// $ANTLR end synpred204_asn1

// $ANTLR start synpred205_asn1
static void synpred205_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_constraint_return c1;
	#undef	RETURN_TYPE_c1
	#define	RETURN_TYPE_c1 asn1Parser_constraint_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:65: (c1= constraint )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:653:65: c1= constraint
    {
        FOLLOWPUSH(FOLLOW_constraint_in_synpred205_asn17098);
        c1=constraint(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred205_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred205_asn1Ex; /* Prevent compiler warnings */
rulesynpred205_asn1Ex: ;

}
// $ANTLR end synpred205_asn1

// $ANTLR start synpred207_asn1
static void synpred207_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_namedBitList_return nb;
	#undef	RETURN_TYPE_nb
	#define	RETURN_TYPE_nb asn1Parser_namedBitList_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:50: ( L_BRACE nb= namedBitList R_BRACE )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:50: L_BRACE nb= namedBitList R_BRACE
    {
         MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_synpred207_asn17175); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred207_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_namedBitList_in_synpred207_asn17179);
        nb=namedBitList(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred207_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_synpred207_asn17181); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred207_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred207_asn1Ex; /* Prevent compiler warnings */
rulesynpred207_asn1Ex: ;

}
// $ANTLR end synpred207_asn1

// $ANTLR start synpred208_asn1
static void synpred208_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_namedBitList_return nb2;
	#undef	RETURN_TYPE_nb2
	#define	RETURN_TYPE_nb2 asn1Parser_namedBitList_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:85: ( DEFAULT_LITERAL L_BRACE nb2= namedBitList R_BRACE )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:85: DEFAULT_LITERAL L_BRACE nb2= namedBitList R_BRACE
    {
         MATCHT(DEFAULT_LITERAL, &FOLLOW_DEFAULT_LITERAL_in_synpred208_asn17186); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred208_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(L_BRACE, &FOLLOW_L_BRACE_in_synpred208_asn17188); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred208_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_namedBitList_in_synpred208_asn17192);
        nb2=namedBitList(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred208_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(R_BRACE, &FOLLOW_R_BRACE_in_synpred208_asn17194); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred208_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred208_asn1Ex; /* Prevent compiler warnings */
rulesynpred208_asn1Ex: ;

}
// $ANTLR end synpred208_asn1

// $ANTLR start synpred209_asn1
static void synpred209_asn1_fragment(pasn1Parser ctx ) 
{
	pANTLR3_COMMON_TOKEN    sl;

	sl       = NULL;

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:147: (sl= SIZE_LITERAL )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:147: sl= SIZE_LITERAL
    {
        sl = (pANTLR3_COMMON_TOKEN) MATCHT(SIZE_LITERAL, &FOLLOW_SIZE_LITERAL_in_synpred209_asn17203); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred209_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred209_asn1Ex; /* Prevent compiler warnings */
rulesynpred209_asn1Ex: ;

}
// $ANTLR end synpred209_asn1

// $ANTLR start synpred210_asn1
static void synpred210_asn1_fragment(pasn1Parser ctx ) 
{
	asn1Parser_constraint_return c1;
	#undef	RETURN_TYPE_c1
	#define	RETURN_TYPE_c1 asn1Parser_constraint_return

    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:163: (c1= constraint )
    // /secure/release14_git/mink/src/asn1/asn1c/asn1.g:663:163: c1= constraint
    {
        FOLLOWPUSH(FOLLOW_constraint_in_synpred210_asn17209);
        c1=constraint(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred210_asn1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred210_asn1Ex; /* Prevent compiler warnings */
rulesynpred210_asn1Ex: ;

}
// $ANTLR end synpred210_asn1
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred62_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred62_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred191_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred191_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred47_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred47_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred192_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred192_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred78_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred78_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred104_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred104_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred42_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred42_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred161_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred161_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred204_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred204_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred189_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred189_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred105_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred105_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred75_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred75_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred150_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred150_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred158_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred158_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred205_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred205_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred55_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred55_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred143_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred143_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred146_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred146_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred160_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred160_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred180_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred180_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred25_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred25_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred27_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred27_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred202_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred202_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred108_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred108_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred102_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred102_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred142_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred142_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred51_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred51_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred144_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred144_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred109_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred109_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred145_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred145_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred48_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred48_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred80_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred80_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred28_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred28_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred43_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred43_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred148_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred148_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred201_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred201_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred52_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred52_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred187_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred187_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred208_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred208_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred157_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred157_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred140_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred140_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred56_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred56_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred138_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred138_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred26_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred26_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred209_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred209_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred137_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred137_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred169_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred169_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred57_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred57_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred49_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred49_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred210_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred210_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred23_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred23_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred139_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred139_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred44_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred44_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred207_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred207_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred24_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred24_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred114_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred114_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred155_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred155_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred186_asn1(pasn1Parser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred186_asn1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
